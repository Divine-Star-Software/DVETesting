{"version":3,"file":"compiled_environments_electron_client_dataloader_js.DVE.js","mappings":";;;;;;;;;;;;;;AAAO;AACP,YAAY;AACZ;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACP2C;AACL;AACc;AACH;AAC1C;AACP,UAAU;AACV;AACA,cAAc,sDAAe;AAC7B;AACA;AACA,qCAAqC,+DAAwB;AAC7D;AACA,uBAAuB,+DAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA,uBAAuB,4DAAqB;AAC5C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAAmB;AAC5C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,8BAA8B,sEAA4B;AAC1D;AACA;AACA;AACA,8DAA8D,sEAAmB;AACjF;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc,+DAAwB;AACtC;AACA,KAAK;AACL;AACA,8BAA8B,sEAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,kBAAkB,+DAAc;AAChC;AACA;AACA,qBAAqB,sEAAmB;AACxC;AACA,8BAA8B,sEAA4B;AAC1D;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC3FuD;AACT;AAC2B;AAClE;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,4BAA4B,4EAAiC,CAAC,yGAAiC;AAC/F;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B,yEAA8B,CAAC,yGAAiC;AAC7F;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B,mEAAwB,CAAC,yGAAiC;AACvF;AACA;AACA,+BAA+B,iFAAiC;AAChE;AACA,KAAK;AACL;AACA,iCAAiC,+EAA+B;AAChE,cAAc,mEAAwB,CAAC,yGAAiC;AACxE,cAAc,4EAAiC,CAAC,yGAAiC;AACjF;AACA,KAAK;AACL;AACA,mCAAmC,iFAAiC;AACpE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC/CuD;AACa;AACb;AACoB;AACV;AACjE,MAAM,uEAAW,CAAC,sEAAe;AACjC,MAAM,+DAAY;AAClB,MAAM,yEAAiB;AACvB,iFAAe,CAAC,iEAAK;;;;;;;;;;;;;;;;;;;ACRgD;AACjB;AACpD;AACO;AACP;AACA;AACA,yBAAyB,wEAAqB;AAC9C,qBAAqB,qFAAuB;AAC5C,KAAK;AACL;AACA;AACA,yBAAyB,wEAAqB;AAC9C,qBAAqB,qFAAuB;AAC5C,KAAK;AACL;AACA;AACA,yBAAyB,8EAA2B;AACpD,qBAAqB,2FAA6B;AAClD,KAAK;AACL;AACA;AACA,yBAAyB,wEAAqB;AAC9C,qBAAqB,qFAAuB;AAC5C,KAAK;AACL;AACA;AACA,yBAAyB,wEAAqB;AAC9C,qBAAqB,qFAAuB;AAC5C,KAAK;AACL;AACA;AACA,mBAAmB,qEAAkB;AACrC,eAAe,kFAAoB;AACnC,KAAK;AACL;AACA;AACA,yBAAyB,0EAAuB;AAChD,qBAAqB,uFAAyB;AAC9C,KAAK;AACL;AACA;AACA,yBAAyB,6EAA0B;AACnD,qBAAqB,0FAA4B;AACjD,KAAK;AACL;;;;;;;;;;;;;;;;AC5CuD;AAChD;AACP;AACA;AACA;AACA,iCAAiC,+EAA+B;AAChE;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B,GAAG,WAAW;AACrE;AACA;AACA;AACA,uBAAuB,oCAAoC;AAC3D,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yDAAyD,GAAG;AAC5D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA,uCAAuC,4FAA4C;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,oDAAoD,qBAAqB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mDAAmD,qBAAqB,SAAS,MAAM;AACvF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mCAAmC,iFAAiC;AACpE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC5IiE;AAC1D;AACP,UAAU,yEAAiB;AAC3B;AACA,cAAc,gFAAwB;AACtC;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACRA;AACO;AACP;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACfO;AACP,gBAAgB;AAChB;AACA,kBAAkB;AAClB;AACA;AACA,mCAAmC,GAAG;AACtC,kCAAkC,GAAG;AACrC,kCAAkC,GAAG;AACrC,6BAA6B,GAAG;AAChC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB,IAAI,GAAG,KAAK;AAClC,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB,IAAI,GAAG,KAAK;AAClC,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB,IAAI,GAAG,KAAK;AAClC,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;AC7EsC;AACsB;AACrD;AACP;AACA,cAAc,sDAAe;AAC7B,KAAK;AACL;AACA;AACA,qCAAqC,+DAAwB;AAC7D;AACA,uBAAuB,+DAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,YAAY,8EAAsB;AAClC;AACA;AACA,uBAAuB,4DAAqB;AAC5C,YAAY,8EAAsB;AAClC;AACA,cAAc,kFAA0B;AACxC,eAAe,qEAAa;AAC5B,KAAK;AACL;AACA,cAAc,+DAAwB;AACtC,KAAK;AACL;;;;;;;;;;;;;;;;;;AC/BiD;AACL;;;;;;;;;;;;;;;;;;;ACD5C;AAC0D;AACoB;AACH;AACxB;AACnD,2BAA2B,mFAAc;AAClC;AACP,eAAe;AACf;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wBAAwB,2EAAuB;AAC/C,YAAY,qFAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,oBAAoB;AAClF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,+BAA+B,mGAAkC;AACjE;AACA;AACA;AACA;AACA;AACA,iEAAiE,oBAAoB;AACrF;AACA;AACA;AACA,2DAA2D,oBAAoB;AAC/E;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,yBAAyB,qGAAoC;AAC7D;AACA,YAAY,qFAAwB;AACpC;AACA,gBAAgB,qFAAwB;AACxC;AACA;AACA;AACA;AACA,uDAAuD,oBAAoB;AAC3E;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,GAAG;AACxD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kEAAkE,oBAAoB;AACtF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iEAAiE,oBAAoB;AACrF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;ACxGA;AACoE;AACpB;AACO;AACF;AACqB;AAC1E;AACyD;AACG;AAC5D;AACkD;AACW;AACY;AACjC;AACjC;AACP;AACA;AACA,QAAQ,mDAAU;AAClB,UAAU,wDAAI;AACd,cAAc,4EAAc;AAC5B,kBAAkB,+DAAY;AAC9B,UAAU,6DAAW;AACrB,eAAe,kEAAS;AACxB,gBAAgB,qEAAU;AAC1B,WAAW,sEAAe;AAC1B,gBAAgB,mFAAkB;AAClC,iBAAiB,kFAAkB;AACnC;AACA;AACA;AACA,KAAK;AACL,iBAAiB;AACjB;AACA;AACA,KAAK;AACL;AACA;AACA,cAAc,+DAAU;AACxB,KAAK;AACL;;;;;;;;;;;;;;;;ACvCwC;AACjC;AACP;AACA;AACA;AACA;AACA,UAAU,wDAAgB;AAC1B;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACbA;AAC8E;AACA;AACF;AACc;AACnF;AACP,iBAAiB,mFAAc;AAC/B,iBAAiB,mFAAc;AAC/B,gBAAgB,iFAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B,4EAAgB;AAC/C,+BAA+B,mFAAuB;AACtD,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kFAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC9E0D;AAClB;AACgD;AACjF;AACP,gBAAgB,gEAAwB;AACxC,cAAc,wGAA6B;AAC3C;AACA,KAAK;AACL,gBAAgB,gEAAwB;AACxC,cAAc,wGAA6B;AAC3C;AACA,KAAK;AACL,sBAAsB,gEAAwB;AAC9C,8BAA8B,8GAAmC;AACjE;AACA,KAAK;AACL,gBAAgB,gEAAwB;AACxC,cAAc,wGAA6B;AAC3C;AACA,KAAK;AACL,gBAAgB,gEAAwB;AACxC,cAAc,wGAA6B;AAC3C;AACA,gBAAgB,gGAAmC;AACnD;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,kBAAkB,gEAAwB;AAC1C,cAAc,wGAA6B;AAC3C,QAAQ,qFAAwB;AAChC;AACA,iBAAiB,gGAAmC;AACpD;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,aAAa,gEAAwB;AACrC,cAAc,qGAA0B;AACxC;AACA,KAAK;AACL,kBAAkB,gEAAwB;AAC1C,6BAA6B,0GAA+B;AAC5D;AACA;AACA;AACA;AACA,KAAK;AACL,qBAAqB,gEAAwB;AAC7C,2BAA2B,6GAAkC;AAC7D;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACzD6D;AACrB;AACxC,mBAAmB,yDAAiB;AACpC;AACA;AACA;AACA;AACA,IAAI,oFAAuB;AAC3B,CAAC;AACD;AACA;AACA,IAAI,+EAAkB;AACtB,CAAC;AACD;AACA,IAAI,0EAAa;AACjB,CAAC;AACM;;;;;;;;;;;;;;;;AChBiC;AACxC,kBAAkB,6DAAqB,YAAY;AAC5C;;;;;;;;;;;;;;;;ACF0C;;;;;;;;;;;;;;;;ACA1C;AACA;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACLA;AACwC;AACiB;AACe;AACX;AACiB;AACvB;AACqB;AAClB;AACT;AACC;AAC4B;AACvE;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kBAAkB,6DAAqB,CAAC,6FAA0B;AAClE,QAAQ,sFAAkC;AAC1C,KAAK;AACL,eAAe,6DAAqB,CAAC,0FAAuB;AAC5D,QAAQ,gEAAe;AACvB,QAAQ,+DAAc;AACtB;AACA,KAAK;AACL,eAAe,6DAAqB,CAAC,0FAAuB;AAC5D,WAAW,6DAAqB,CAAC,sFAAmB;AACpD,YAAY,6DAAqB,CAAC,uFAAoB;AACtD,YAAY,6DAAqB,CAAC,uFAAoB;AACtD,kBAAkB,6DAAqB,CAAC,6FAA0B;AAClE,eAAe,6DAAqB,CAAC,0FAAuB;AAC5D,gBAAgB,6DAAqB,CAAC,2FAAwB;AAC9D,gBAAgB,6DAAqB,CAAC,2FAAwB;AAC9D,eAAe,6DAAqB,CAAC,kGAA+B;AACpE,QAAQ,oFAAiC;AACzC,KAAK;AACL;AACA;AACA,IAAI,yGAAoC;AACxC,CAAC;AACD;AACA,IAAI,4EAAuB;AAC3B,CAAC;AACD;AACA,IAAI,+EAA0B;AAC9B,CAAC;AACD;AACA,IAAI,6EAAwB;AAC5B,CAAC;AACD;AACA,IAAI,gFAA2B;AAC/B,CAAC;AACD;AACA,IAAI,6EAAwB;AAC5B,CAAC;AACD;AACA,IAAI,gFAA2B;AAC/B,CAAC;AACD;AACA,IAAI,4FAAwB;AAC5B,CAAC;AACD;AACA,IAAI,sEAAe;AACnB,CAAC;AACD;AACA,IAAI,yEAAgB;AACpB,CAAC;AACD;AACA,IAAI,yEAAgB;AACpB,IAAI,+EAAsB;AAC1B,CAAC;;;;;;;;;;;;;;;;;;AC9EmD;AACJ;AACM;AAC/C;AACP;AACA;AACA;AACA,WAAW,wDAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kBAAkB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kBAAkB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8EAA+B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,uBAAuB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,IAAI,8BAA8B,+BAA+B;AAChG;AACA,mBAAmB,8DAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,eAAe;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;AClZU;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;ACAmC;AACF;AACE;;;;;;;;;;;;;;;ACFtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChBmD;AAC5C;AACP;AACA,UAAU,4DAAa;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACzBkD;AACH;AACxC;AACP,gBAAgB;AAChB;AACA,uBAAuB;AACvB,UAAU,wDAAW;AACrB;AACA,4BAA4B,2DAAQ;AACpC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA,SAAS;AACT,6BAA6B,2DAAQ;AACrC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,cAAc;AAC1D;AACA,6BAA6B,2DAAQ;AACrC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,aAAa,GAAG,gBAAgB;AAC7F;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACrFO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACjB+B;AACQ;AACA;;;;;;;;;;;;;;;;;;;ACFF;AACK;;;;;;;;;;;;;;;ACDnC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;ACxFqC;AAC9B;AACP,UAAU,8CAAM;AAChB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;ACZuC;;;;;;;;;;;;;;;;ACAM;;;;;;;UCA7C;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;;;;WClCA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;WACA;WACA,IAAI;WACJ;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,CAAC;WACD;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;WACA,sGAAsG;WACtG;WACA;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA,EAAE;WACF;WACA;;;;;WChEA;WACA;WACA;WACA;WACA,+BAA+B,wCAAwC;WACvE;WACA;WACA;WACA;WACA,iBAAiB,qBAAqB;WACtC;WACA;WACA,kBAAkB,qBAAqB;WACvC;WACA;WACA,KAAK;WACL;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WC3BA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;;;;;WCRA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WCfA;;WAEA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,aAAa;WACb;WACA;WACA;WACA;;WAEA;WACA;WACA;;WAEA;;WAEA;;;;;WCpCA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;UENA;UACA","sources":["webpack://dve-testing/./compiled/core/data/ENV/DVEENV.js","webpack://dve-testing/./compiled/databases/App/AppDataBase.js","webpack://dve-testing/./compiled/databases/World/DVEDDataBase.js","webpack://dve-testing/./compiled/environments/electron/client/dataloader.js","webpack://dve-testing/./compiled/io/client/DataHandler.js","webpack://dve-testing/./compiled/io/client/Server/DVEDServer.js","webpack://dve-testing/./compiled/io/client/Tasks/RegisterIOTasks.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/util/index.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngineData/dist/Broswer/DataBase/WorldDataBase.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngineData/dist/Broswer/DivineVoxelEngineDataClient.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngineData/dist/Broswer/index.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/DataLoader/DataHandler/DataHandlerWrapper.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/DataLoader/DivineVoxelEngineDataLoader.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/DataLoader/Init/InitWorker.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/DataLoader/Serializers/WorldDataSerializer.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/DataLoader/Tasks/DataLoaderTasks.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/DataLoader/Threads/Parent/ParentComm.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/DataLoader/Threads/World/WorldComm.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/DataLoader/index.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Constants/DataHeaders.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/DataSyncNode.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/Database/Database.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/Meta/Database/Database.types.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/Meta/Database/Schema.types.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/Meta/Zeneith/Database.schema.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/Meta/index.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/Store/ObjectStore.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/ZeneithDB.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/ZeneithDBCore.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/ZeneithUtil.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/ZeneithDB/index.js","webpack://dve-testing/../../DSLIBS/zeneithDB/dist/index.js","webpack://dve-testing/./node_modules/crystal-compressor/CrystalCompressor/CCCore.js","webpack://dve-testing/./node_modules/crystal-compressor/CrystalCompressor/CrystalCompressor.js","webpack://dve-testing/./node_modules/crystal-compressor/CrystalCompressor/index.js","webpack://dve-testing/./node_modules/crystal-compressor/index.js","webpack://dve-testing/webpack/bootstrap","webpack://dve-testing/webpack/runtime/async module","webpack://dve-testing/webpack/runtime/chunk loaded","webpack://dve-testing/webpack/runtime/define property getters","webpack://dve-testing/webpack/runtime/ensure chunk","webpack://dve-testing/webpack/runtime/get javascript chunk filename","webpack://dve-testing/webpack/runtime/global","webpack://dve-testing/webpack/runtime/hasOwnProperty shorthand","webpack://dve-testing/webpack/runtime/make namespace object","webpack://dve-testing/webpack/runtime/publicPath","webpack://dve-testing/webpack/runtime/importScripts chunk loading","webpack://dve-testing/webpack/runtime/startup chunk dependencies","webpack://dve-testing/webpack/before-startup","webpack://dve-testing/webpack/startup","webpack://dve-testing/webpack/after-startup"],"sourcesContent":["export const DVEENV = {\r\n    data: {},\r\n    async $INIT(url = \".DVE_ENV\") {\r\n        const envDataResponse = await fetch(url);\r\n        const envData = await envDataResponse.json();\r\n        this.data = envData;\r\n    },\r\n};\r\n","import { DVEDBrowser } from \"dved/Broswer\";\r\nimport { ZeneithDB } from \"zeneithdb\";\r\nimport { DVEENV } from \"../../core/data/ENV/DVEENV\";\r\nimport { StringToNumber } from \"divine-rng/util\";\r\nexport const AppDataBase = {\r\n    db: {},\r\n    async $INIT() {\r\n        await ZeneithDB.$INIT();\r\n        const dbName = \"ECD_APP\";\r\n        let db;\r\n        const existanceCheck = await ZeneithDB.databaseExists(dbName);\r\n        if (!existanceCheck) {\r\n            db = await ZeneithDB.createDatabase({\r\n                databaseName: dbName,\r\n                collections: [\r\n                    {\r\n                        name: \"meta-data\",\r\n                        schema: [],\r\n                    },\r\n                ],\r\n            });\r\n            this.db = db;\r\n        }\r\n        else {\r\n            db = await ZeneithDB.getDatabase(dbName);\r\n            this.db = db;\r\n        }\r\n        await this.db.open();\r\n    },\r\n    async inSaveRecord(id) {\r\n        const saveRecord = await this.db.getData(\"meta-data\", \"save-record\");\r\n        if (!saveRecord) {\r\n            this.db.setData(\"meta-data\", \"save-record\", {});\r\n            return false;\r\n        }\r\n        const save = saveRecord[id];\r\n        return save !== undefined;\r\n    },\r\n    async addToSaveRecord(id) {\r\n        let saveRecord = await this.db.getData(\"meta-data\", \"save-record\");\r\n        if (!saveRecord) {\r\n            saveRecord = {};\r\n        }\r\n        saveRecord[id] = DVEENV.data.version;\r\n        this.db.setData(\"meta-data\", \"save-record\", saveRecord);\r\n    },\r\n    async removeFromSaveRecord(id) {\r\n        let saveRecord = await this.db.getData(\"meta-data\", \"save-record\");\r\n        if (!saveRecord)\r\n            return false;\r\n        delete saveRecord[id];\r\n        this.db.setData(\"meta-data\", \"save-record\", saveRecord);\r\n    },\r\n    async getWorldSave(id) {\r\n        const worldDB = await DVEDBrowser.getWorldDataBase(id);\r\n        const inWorldSave = await this.inSaveRecord(id);\r\n        if (!inWorldSave) {\r\n            await this.addToSaveRecord(id);\r\n            worldDB.database.setData(\"world-meta\", \"version\", DVEENV.data.version);\r\n        }\r\n    },\r\n    async getAllSaves() {\r\n        const saveRecord = await this.db.getData(\"meta-data\", \"save-record\");\r\n        if (!saveRecord)\r\n            return {};\r\n        return saveRecord;\r\n    },\r\n    async removeWorldSave(id) {\r\n        await ZeneithDB.deleteDatabase(id);\r\n        await this.removeFromSaveRecord(id);\r\n    },\r\n    async getSavedata(id) {\r\n        const worldDB = await DVEDBrowser.getWorldDataBase(id);\r\n        await this.addToSaveRecord(id);\r\n        const data = await worldDB.database.getData(\"world-meta\", \"save-data\");\r\n        if (!data)\r\n            return false;\r\n        return data;\r\n    },\r\n    async createNewSave(title, seed) {\r\n        const saveData = {\r\n            title: title,\r\n            seed: StringToNumber(seed),\r\n            created: Date.now(),\r\n            lastPlayed: Date.now(),\r\n            version: DVEENV.data.version,\r\n        };\r\n        const worldDB = await DVEDBrowser.getWorldDataBase(title);\r\n        await this.addToSaveRecord(title);\r\n        worldDB.database.setData(\"world-meta\", \"save-data\", saveData);\r\n    },\r\n};\r\n","import { CrystalCompressor } from \"crystal-compressor\";\r\nimport { WorldDataBase } from \"dved/Broswer/\";\r\nimport { WorldSpaces } from \"divine-voxel-engine/Data/World/WorldSpaces\";\r\nexport const DVEDDataBase = {\r\n    async setPath(id) {\r\n        return true;\r\n    },\r\n    async columnExists(location) {\r\n        return (await this.columnTimestamp(location)) > 0;\r\n    },\r\n    async columnTimestamp(location) {\r\n        const stamp = await WorldDataBase.columnTimestamp.get(WorldSpaces.column.getKeyLocation(location), \"world-data\");\r\n        if (!stamp)\r\n            return 0;\r\n        return stamp;\r\n    },\r\n    async loadRegionHeader(location) {\r\n        const buffer = await WorldDataBase.regionHeader.get(WorldSpaces.region.getKeyLocation(location), \"world-data\");\r\n        if (!buffer)\r\n            return new ArrayBuffer(0);\r\n        return buffer;\r\n    },\r\n    async loadColumn(location) {\r\n        const buffer = await WorldDataBase.column.get(WorldSpaces.column.getKeyLocation(location), \"world-data\");\r\n        if (!buffer)\r\n            return new ArrayBuffer(0);\r\n        const d = await (await CrystalCompressor.decompressArray(buffer, \"Uint8\")).buffer;\r\n        return d;\r\n    },\r\n    async saveColumn(location, buffer) {\r\n        const compressed = await CrystalCompressor.compressArray(new Uint8Array(buffer));\r\n        await WorldDataBase.column.set(WorldSpaces.column.getKeyLocation(location), \"world-data\", compressed.buffer);\r\n        await WorldDataBase.columnTimestamp.set(WorldSpaces.column.getKeyLocation(location), \"world-data\", Date.now());\r\n        return true;\r\n    },\r\n    async loadRegion(location) {\r\n        const uncompressed = await CrystalCompressor.decompressArray(new ArrayBuffer(0), \"Uint8\");\r\n        return [uncompressed.buffer];\r\n    },\r\n    async saveRegion(buffer) {\r\n        const proms = [];\r\n        for (const column of buffer) {\r\n            proms.push(this.saveColumn(column[0], column[1]));\r\n        }\r\n        await Promise.all(proms);\r\n        return true;\r\n    },\r\n};\r\n","import { DVEDL } from \"divine-voxel-engine/DataLoader\";\r\nimport { DVEDDataHandler } from \"../../../io/client/DataHandler.js\";\r\nimport { DVEENV } from \"../../../core/data/ENV/DVEENV\";\r\nimport { RegisterIOTasks } from \"../../../io/client/Tasks/RegisterIOTasks\";\r\nimport { AppDataBase } from \"../../../databases/App/AppDataBase\";\r\nawait DVEDL.$INIT(DVEDDataHandler);\r\nawait DVEENV.$INIT(\"../.DVE_ENV\");\r\nawait AppDataBase.$INIT();\r\nRegisterIOTasks(DVEDL);\r\n","import { DVEDDataBase } from \"../../databases/World/DVEDDataBase.js\";\r\nimport { DVEDServer } from \"./Server/DVEDServer.js\";\r\nlet mode = \"indexdb\";\r\nexport const DVEDDataHandler = {\r\n    async getRegion(location) {\r\n        if (mode == \"server\")\r\n            return await DVEDServer.loadRegion(location);\r\n        return await DVEDDataBase.loadRegion(location);\r\n    },\r\n    async saveRegion(buffers) {\r\n        if (mode == \"server\")\r\n            return await DVEDServer.saveRegion(buffers);\r\n        return await DVEDDataBase.saveRegion(buffers);\r\n    },\r\n    async getRegionHeader(location) {\r\n        if (mode == \"server\")\r\n            return await DVEDServer.loadRegionHeader(location);\r\n        return await DVEDDataBase.loadRegionHeader(location);\r\n    },\r\n    async getColumn(location) {\r\n        if (mode == \"server\")\r\n            return await DVEDServer.loadColumn(location);\r\n        return await DVEDDataBase.loadColumn(location);\r\n    },\r\n    async saveColumn(location, buffer) {\r\n        if (mode == \"server\")\r\n            return await DVEDServer.saveColumn(location, buffer);\r\n        return await DVEDDataBase.saveColumn(location, buffer);\r\n    },\r\n    async setPath(id) {\r\n        if (mode == \"server\")\r\n            return DVEDServer.setPath(id);\r\n        return DVEDDataBase.setPath(id);\r\n    },\r\n    async columnExists(location) {\r\n        if (mode == \"server\")\r\n            return await DVEDServer.columnExists(location);\r\n        return await DVEDDataBase.columnExists(location);\r\n    },\r\n    async columnTimestamp(location) {\r\n        if (mode == \"server\")\r\n            return await DVEDServer.columnTimestamp(location);\r\n        return await DVEDDataBase.columnTimestamp(location);\r\n    },\r\n};\r\n","import { CrystalCompressor } from \"crystal-compressor\";\r\nexport const DVEDServer = {\r\n    url: `http://127.0.0.1:3000`,\r\n    async _compressToString(buffer) {\r\n        let dataString = \"\";\r\n        const compressed = await CrystalCompressor.compressArray(new Uint8Array(buffer));\r\n        let length = compressed.length;\r\n        for (let i = 0; i < length; i++) {\r\n            dataString += String.fromCharCode(compressed[i]);\r\n        }\r\n        return dataString;\r\n    },\r\n    async sendDVEDMessage(dveMessage, buffer) {\r\n        let dataString = \"\";\r\n        if (buffer) {\r\n            if (Array.isArray(buffer)) {\r\n            }\r\n            else {\r\n                dataString = await this._compressToString(buffer);\r\n            }\r\n        }\r\n        const message = `|${JSON.stringify(dveMessage)}|${dataString}`;\r\n        return fetch(this.url, {\r\n            method: \"POST\",\r\n            body: message,\r\n            headers: { \"Content-Type\": \"application/dved\" },\r\n        });\r\n    },\r\n    async setPath(id) {\r\n        const response = await this.sendDVEDMessage({\r\n            type: \"set-path\",\r\n            id: id,\r\n        });\r\n        const error = (await this._determineError(response)) != Infinity;\r\n        if (error) {\r\n            console.warn(`Problem setting path with id ${id}`);\r\n            return false;\r\n        }\r\n        return true;\r\n    },\r\n    async _determineError(response) {\r\n        let error = Infinity;\r\n        if (!response)\r\n            error = -1;\r\n        const responseBuffer = await response.arrayBuffer();\r\n        if (!responseBuffer)\r\n            error = -1;\r\n        const responseCode = new Uint8Array(responseBuffer)[0];\r\n        if (responseCode !== 1)\r\n            error = responseCode;\r\n        if (error !== Infinity)\r\n            return error;\r\n        return Infinity;\r\n    },\r\n    async columnExists(location) {\r\n        const response = await this.sendDVEDMessage({\r\n            type: `column-exists`,\r\n            location: location,\r\n        });\r\n        const buffer = await response.arrayBuffer();\r\n        if (!buffer)\r\n            return false;\r\n        const data = new Uint8Array(buffer);\r\n        return data[0] == 1;\r\n    },\r\n    async columnTimestamp(location) {\r\n        const response = await this.sendDVEDMessage({\r\n            type: `column-timestamp`,\r\n            location: location,\r\n        });\r\n        const buffer = await response.arrayBuffer();\r\n        if (!buffer)\r\n            return 0;\r\n        const data = new Uint32Array(buffer);\r\n        return data[0];\r\n    },\r\n    async loadColumn(location) {\r\n        try {\r\n            const response = await this.sendDVEDMessage({\r\n                type: `load-column`,\r\n                location: location,\r\n            });\r\n            const buffer = await response.arrayBuffer();\r\n            if (buffer.byteLength == 0) {\r\n                throw new Error(`Column at ${location.toString()} could not be loaded`);\r\n            }\r\n            const uncompressed = await CrystalCompressor.core.decompressArrayBuffer(buffer);\r\n            return uncompressed.buffer;\r\n        }\r\n        catch (error) {\r\n            console.log(error);\r\n            return new Uint8Array(0).buffer;\r\n        }\r\n    },\r\n    async loadRegionHeader(location) {\r\n        try {\r\n            const response = await this.sendDVEDMessage({\r\n                type: `load-region-header`,\r\n                location: location,\r\n            });\r\n            const buffer = await response.arrayBuffer();\r\n            if (buffer.byteLength == 1) {\r\n                throw new Error(`Region header at ${location.toString()} could not be loaded`);\r\n            }\r\n            return buffer;\r\n        }\r\n        catch (error) {\r\n            console.log(error);\r\n            return new Uint8Array(0).buffer;\r\n        }\r\n    },\r\n    async saveColumn(location, buffer) {\r\n        const response = await this.sendDVEDMessage({\r\n            type: `save-column`,\r\n            location: location,\r\n        }, buffer);\r\n        const error = (await this._determineError(response)) != Infinity;\r\n        if (error) {\r\n            console.warn(`Problem saving data at ${location.toString()} code : ${error}`);\r\n            return false;\r\n        }\r\n        return true;\r\n    },\r\n    async loadRegion(location) {\r\n        const response = await this.sendDVEDMessage({\r\n            type: `load-column`,\r\n            location: location,\r\n        });\r\n        const buffer = await response.arrayBuffer();\r\n        const uncompressed = await CrystalCompressor.decompressArray(buffer, \"Uint8\");\r\n        return [uncompressed.buffer];\r\n    },\r\n    async saveRegion(buffer) {\r\n        const proms = [];\r\n        for (const column of buffer) {\r\n            proms.push(this.saveColumn(column[0], column[1]));\r\n        }\r\n        await Promise.all(proms);\r\n        return true;\r\n    },\r\n};\r\n","import { AppDataBase } from \"../../../databases/App/AppDataBase\";\r\nexport async function RegisterIOTasks(DVEDL) {\r\n    await AppDataBase.$INIT();\r\n    DVEDL.TC.registerTasks(\"set-save\", async (id, onDone) => {\r\n        await AppDataBase.getWorldSave(id);\r\n        if (onDone)\r\n            onDone();\r\n    }, \"deffered\");\r\n}\r\n","//https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\r\nexport function StringToNumber(str, seed = 0) {\r\n    let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\r\n    for (let i = 0, ch; i < str.length; i++) {\r\n        ch = str.charCodeAt(i);\r\n        h1 = Math.imul(h1 ^ ch, 2654435761);\r\n        h2 = Math.imul(h2 ^ ch, 1597334677);\r\n    }\r\n    h1 =\r\n        Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^\r\n            Math.imul(h2 ^ (h2 >>> 13), 3266489909);\r\n    h2 =\r\n        Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^\r\n            Math.imul(h1 ^ (h1 >>> 13), 3266489909);\r\n    return 4294967296 * (2097151 & h2) + (h1 >>> 0);\r\n}\r\n","export const WorldDataBase = {\r\n    database: {},\r\n    dimension: \"\",\r\n    typeStores: {},\r\n    async setDimension(id) {\r\n        if (this.dimension != id) {\r\n            const worldDataId = `${id}-world-data`;\r\n            const richDataId = `${id}-rich-data`;\r\n            const entitiesId = `${id}-entities`;\r\n            const dboId = `${id}-dbo`;\r\n            await this.database.addCollection([\r\n                {\r\n                    name: worldDataId,\r\n                    schema: [],\r\n                },\r\n                {\r\n                    name: richDataId,\r\n                    schema: [],\r\n                },\r\n                {\r\n                    name: entitiesId,\r\n                    schema: [],\r\n                },\r\n                {\r\n                    name: dboId,\r\n                    schema: [],\r\n                },\r\n            ]);\r\n            this.typeStores[\"world-data\"] = await this.database.getCollection(worldDataId);\r\n            this.typeStores[\"rich-data\"] = await this.database.getCollection(richDataId);\r\n            this.typeStores[\"entities\"] = await this.database.getCollection(entitiesId);\r\n            this.typeStores[\"dbo\"] = await this.database.getCollection(dboId);\r\n        }\r\n        this.dimension = id;\r\n    },\r\n    regionHeader: {\r\n        async set(key, type, data) {\r\n            await WorldDataBase.typeStores[type].set(this._getKey(key, type), new Blob([data]));\r\n        },\r\n        async get(key, type) {\r\n            const blob = (await WorldDataBase.typeStores[type].get(this._getKey(key, type)));\r\n            if (!blob)\r\n                return false;\r\n            return await blob.arrayBuffer();\r\n        },\r\n        _getKey(key, type) {\r\n            return `${key}_${type}_region_header`;\r\n        },\r\n    },\r\n    column: {\r\n        async set(key, type, data) {\r\n            await WorldDataBase.typeStores[type].set(this._getKey(key, type), new Blob([data]));\r\n        },\r\n        async get(key, type) {\r\n            const blob = (await WorldDataBase.typeStores[type].get(this._getKey(key, type)));\r\n            if (!blob)\r\n                return false;\r\n            return await blob.arrayBuffer();\r\n        },\r\n        _getKey(key, type) {\r\n            return `${key}_${type}_column`;\r\n        },\r\n    },\r\n    columnTimestamp: {\r\n        async set(key, type, timeStamp) {\r\n            await WorldDataBase.typeStores[type].set(this._getKey(key, type), timeStamp);\r\n        },\r\n        async get(key, type) {\r\n            const timeStamp = (await WorldDataBase.typeStores[type].get(this._getKey(key, type)));\r\n            if (!timeStamp)\r\n                return false;\r\n            return Number(timeStamp);\r\n        },\r\n        _getKey(key, type) {\r\n            return `${key}_${type}_column_timestamp`;\r\n        },\r\n    },\r\n};\r\n","import { ZeneithDB } from \"zeneithdb\";\r\nimport { WorldDataBase } from \"./DataBase/WorldDataBase.js\";\r\nexport const DVEDBrowser = {\r\n    async $INIT() {\r\n        await ZeneithDB.$INIT();\r\n    },\r\n    async getWorldDataBase(dbName, dimension = \"main\") {\r\n        let db;\r\n        const existanceCheck = await ZeneithDB.databaseExists(dbName);\r\n        if (!existanceCheck) {\r\n            db = await ZeneithDB.createDatabase({\r\n                databaseName: dbName,\r\n                collections: [\r\n                    {\r\n                        name: \"world-meta\",\r\n                        schema: [],\r\n                    },\r\n                ],\r\n            });\r\n            WorldDataBase.database = db;\r\n        }\r\n        else {\r\n            db = await ZeneithDB.getDatabase(dbName);\r\n            WorldDataBase.database = db;\r\n        }\r\n        await WorldDataBase.setDimension(dimension);\r\n        return WorldDataBase;\r\n    },\r\n    async deleteWorldDataBase(dbName) {\r\n        await ZeneithDB.deleteDatabase(dbName);\r\n    },\r\n};\r\n","export * from \"./DivineVoxelEngineDataClient.js\";\r\nexport * from \"./DataBase/WorldDataBase.js\";\r\n","//objects\r\nimport { DVEDL } from \"../DivineVoxelEngineDataLoader.js\";\r\nimport { ColumnDataTool } from \"../../Tools/Data/WorldData/ColumnDataTool.js\";\r\nimport { WorldDataSerialize } from \"../Serializers/WorldDataSerializer.js\";\r\nimport { Util } from \"../../Global/Util.helper.js\";\r\nconst columnDatatool = new ColumnDataTool();\r\nexport const DataHanlderWrapper = {\r\n    handler: {},\r\n    $INIT(handler) {\r\n        this.handler = handler;\r\n    },\r\n    async loadRegionHeader(location) {\r\n        try {\r\n            const headerBuffer = await this.handler.getRegionHeader(location);\r\n            if (!headerBuffer)\r\n                return false;\r\n            const sab = Util.convertBufferToSAB(headerBuffer);\r\n            DVEDL.worldComm.runTasks(\"load-region-header\", [\r\n                location,\r\n                sab,\r\n            ]);\r\n            return true;\r\n        }\r\n        catch (error) {\r\n            console.error(`Problem getting region header at ${location.toString()}`);\r\n            console.error(error);\r\n            return false;\r\n        }\r\n    },\r\n    async saveColumn(location) {\r\n        if (columnDatatool.setLocation(location).loadIn()) {\r\n            try {\r\n                columnDatatool.markAsStored();\r\n                const column = WorldDataSerialize.serializeColumn(location);\r\n                if (!column)\r\n                    return false;\r\n                const success = await this.handler.saveColumn(location, column);\r\n                if (!success) {\r\n                    columnDatatool.markAsNotStored();\r\n                    throw new Error(`Could not store column at ${location.toString()}`);\r\n                }\r\n            }\r\n            catch (error) {\r\n                console.error(`Problem storing column at ${location.toString()}`);\r\n                console.error(error);\r\n            }\r\n        }\r\n    },\r\n    async loadColumn(location) {\r\n        try {\r\n            const column = await this.handler.getColumn(location);\r\n            const data = WorldDataSerialize.deSerializeColumn(column);\r\n            columnDatatool.setBuffer(data.column);\r\n            DVEDL.worldComm.runTasks(\"load-column\", [data.column]);\r\n            for (const chunk of data.chunks) {\r\n                DVEDL.worldComm.runTasks(\"load-chunk\", [chunk]);\r\n            }\r\n            return true;\r\n        }\r\n        catch (error) {\r\n            console.error(`Problem loading column at ${location.toString()}`);\r\n            console.error(error);\r\n            return false;\r\n        }\r\n    },\r\n    async setPath(id) {\r\n        try {\r\n            await this.handler.setPath(id);\r\n            return true;\r\n        }\r\n        catch (error) {\r\n            console.error(`Problem setting path to ${id}`);\r\n            console.error(error);\r\n            return false;\r\n        }\r\n    },\r\n    async columnExists(location) {\r\n        try {\r\n            return await this.handler.columnExists(location);\r\n        }\r\n        catch (error) {\r\n            console.error(`Problem checking if column exists at ${location.toString()}`);\r\n            console.error(error);\r\n            return false;\r\n        }\r\n    },\r\n    async columnTimestamp(location) {\r\n        try {\r\n            return await this.handler.columnTimestamp(location);\r\n        }\r\n        catch (error) {\r\n            console.error(`Problem getting column timestamp at ${location.toString()}`);\r\n            console.error(error);\r\n            return 0;\r\n        }\r\n    },\r\n    async saveRegion(location) {\r\n        /** @TO-DO*/\r\n        return true;\r\n    },\r\n    async loadRegion(location) {\r\n        /** @TO-DO*/\r\n        return true;\r\n    },\r\n};\r\n","//objects\r\nimport { EngineSettings } from \"../Data/Settings/EngineSettings.js\";\r\nimport { Util } from \"../Global/Util.helper.js\";\r\nimport { DataSyncNode } from \"../Data/DataSyncNode.js\";\r\nimport { DataManager } from \"../Data/DataManager.js\";\r\nimport { WorldDataSerialize } from \"./Serializers/WorldDataSerializer.js\";\r\n//intercomms\r\nimport { WorldComm } from \"./Threads/World/WorldComm.js\";\r\nimport { ParentComm } from \"./Threads/Parent/ParentComm.js\";\r\n//functions\r\nimport { InitWorker } from \"./Init/InitWorker.js\";\r\nimport { DataLoaderTasks } from \"./Tasks/DataLoaderTasks.js\";\r\nimport { DataHanlderWrapper } from \"./DataHandler/DataHandlerWrapper.js\";\r\nimport { ThreadComm } from \"threadcomm\";\r\nexport const DVEDL = {\r\n    environment: \"browser\",\r\n    __settingsHaveBeenSynced: false,\r\n    TC: ThreadComm,\r\n    UTIL: Util,\r\n    settings: EngineSettings,\r\n    dataSyncNode: DataSyncNode,\r\n    data: DataManager,\r\n    worldComm: WorldComm,\r\n    parentComm: ParentComm,\r\n    tasks: DataLoaderTasks,\r\n    serializer: WorldDataSerialize,\r\n    dataHandler: DataHanlderWrapper,\r\n    syncSettings(data) {\r\n        this.settings.syncSettings(data);\r\n        this.__settingsHaveBeenSynced = true;\r\n    },\r\n    reStart() { },\r\n    isReady() {\r\n        return DVEDL.worldComm.isPortSet() && DVEDL.__settingsHaveBeenSynced;\r\n    },\r\n    async $INIT(dataHanlder) {\r\n        this.dataHandler.$INIT(dataHanlder);\r\n        await InitWorker(this);\r\n    },\r\n};\r\n","import { ThreadComm } from \"threadcomm\";\r\nexport async function InitWorker(DVED) {\r\n    let parent = \"render\";\r\n    if (DVED.environment == \"node\") {\r\n        parent = \"server\";\r\n    }\r\n    await ThreadComm.$INIT(\"data-loader\", parent);\r\n    await DVED.UTIL.createPromiseCheck({\r\n        check: () => {\r\n            return DVED.isReady();\r\n        },\r\n        checkInterval: 1,\r\n    });\r\n}\r\n","//objects\r\nimport { RegionDataTool } from \"../../Tools/Data/WorldData/RegionDataTool.js\";\r\nimport { ColumnDataTool } from \"../../Tools/Data/WorldData/ColumnDataTool.js\";\r\nimport { ChunkDataTool } from \"../../Tools/Data/WorldData/ChunkDataTool.js\";\r\nimport { WorldDataHeaders, DVEMessageHeader, } from \"../../Data/Constants/DataHeaders.js\";\r\nexport const WorldDataSerialize = {\r\n    regions: new RegionDataTool(),\r\n    columns: new ColumnDataTool(),\r\n    chunks: new ChunkDataTool(),\r\n    serializeRegion(location) {\r\n        if (!this.regions\r\n            .setDimension(location[0])\r\n            .loadInAt(location[1], location[2], location[3]))\r\n            return false;\r\n        const region = this.regions.getRegion();\r\n        const columnBuffers = [];\r\n        region.columns.forEach((column) => {\r\n            this.columns.setColumn(column);\r\n            const location = this.columns.getLocationData();\r\n            const columnBuffer = this.serializeColumn(location);\r\n            if (columnBuffer)\r\n                columnBuffers.push([[...location], columnBuffer]);\r\n        });\r\n        return columnBuffers;\r\n    },\r\n    serializeColumn(location) {\r\n        if (!this.columns.setLocation(location).loadIn())\r\n            return false;\r\n        const columnSize = this.columns.getBufferSizeForWholeColumn();\r\n        const columnBuffer = new ArrayBuffer(columnSize);\r\n        const columnArray = new Uint8Array(columnBuffer);\r\n        const column = this.columns.getColumn();\r\n        let offset = this._readDataIntoBuffer(0, columnArray, column.buffer);\r\n        column.chunks.forEach((chunk) => {\r\n            offset += this._readDataIntoBuffer(offset, columnArray, chunk.buffer);\r\n        });\r\n        return columnArray;\r\n    },\r\n    deSerializeRegion(regionBuffers) {\r\n        for (const buffer of regionBuffers) {\r\n            this.deSerializeColumn(buffer);\r\n        }\r\n    },\r\n    deSerializeColumn(columnBuffer) {\r\n        const dv = new DataView(columnBuffer);\r\n        if (dv.getUint16(0) != DVEMessageHeader &&\r\n            dv.getUint16(2) != WorldDataHeaders.column) {\r\n            throw new Error(`Column at ${location} is not the correct format.`);\r\n        }\r\n        const chunks = [];\r\n        const columnSAB = new SharedArrayBuffer(this.columns.getBufferSize());\r\n        const columnArray = new Uint8Array(columnSAB);\r\n        let offset = this._readDataIntoBuffer(0, columnArray, columnBuffer, 0, this.columns.getBufferSize());\r\n        const columnBufferLength = columnBuffer.byteLength;\r\n        while (offset < columnBufferLength) {\r\n            const dataType = dv.getUint16(offset + 2);\r\n            if (dataType == WorldDataHeaders.chunk) {\r\n                const chunkSAB = new SharedArrayBuffer(this.chunks.getBufferSize());\r\n                const chunkArray = new Uint8Array(chunkSAB);\r\n                offset += this._readDataIntoBuffer(0, chunkArray, columnBuffer, offset, this.chunks.getBufferSize());\r\n                chunks.push(chunkSAB);\r\n                continue;\r\n            }\r\n            throw new Error(`Error loading column at: ${location}`);\r\n        }\r\n        return {\r\n            column: columnSAB,\r\n            chunks: chunks,\r\n        };\r\n    },\r\n    _readDataIntoBuffer(offset, target, source, sourceOffset = 0, sourceLength = -1) {\r\n        const bufferArray = new Uint8Array(source, sourceOffset, sourceLength == -1 ? source.byteLength : sourceLength);\r\n        let i = bufferArray.length;\r\n        while (i--) {\r\n            target[i + offset] = bufferArray[i];\r\n        }\r\n        return bufferArray.length;\r\n    },\r\n};\r\n","import { DVEDL } from \"../DivineVoxelEngineDataLoader.js\";\r\nimport { ThreadComm } from \"threadcomm\";\r\nimport { DataHanlderWrapper } from \"../../DataLoader/DataHandler/DataHandlerWrapper.js\";\r\nexport const DataLoaderTasks = {\r\n    saveRegion: ThreadComm.registerTasks(\"save-region\", async (data, onDone) => {\r\n        await DataHanlderWrapper.saveRegion(data);\r\n        return onDone ? onDone() : false;\r\n    }, \"deffered\"),\r\n    loadRegion: ThreadComm.registerTasks(\"load-region\", async (data, onDone) => {\r\n        await DataHanlderWrapper.loadRegion(data);\r\n        return onDone ? onDone() : false;\r\n    }, \"deffered\"),\r\n    loadRegionHeader: ThreadComm.registerTasks(\"load-region-header\", async (data, onDone) => {\r\n        const success = await DataHanlderWrapper.loadRegionHeader(data);\r\n        return onDone ? onDone(success) : false;\r\n    }, \"deffered\"),\r\n    saveColumn: ThreadComm.registerTasks(\"save-column\", async (data, onDone) => {\r\n        await DataHanlderWrapper.saveColumn(data);\r\n        return onDone ? onDone() : false;\r\n    }, \"deffered\"),\r\n    loadColumn: ThreadComm.registerTasks(\"load-column\", async (data, onDone) => {\r\n        await DataHanlderWrapper.loadColumn(data);\r\n        const inte = setInterval(() => {\r\n            if (DVEDL.data.worldRegister.column.get(data)) {\r\n                onDone ? onDone(true) : false;\r\n                clearInterval(inte);\r\n            }\r\n        }, 1);\r\n    }, \"deffered\"),\r\n    unLoadColumn: ThreadComm.registerTasks(\"unload-column\", async (data, onDone) => {\r\n        await DataHanlderWrapper.saveColumn(data);\r\n        DVEDL.worldComm.runTasks(\"unload-column\", data);\r\n        const inte = setInterval(() => {\r\n            if (!DVEDL.data.worldRegister.column.get(data)) {\r\n                onDone ? onDone() : false;\r\n                clearInterval(inte);\r\n            }\r\n        }, 1);\r\n    }, \"deffered\"),\r\n    setPath: ThreadComm.registerTasks(\"set-path\", async (data, onDone) => {\r\n        await DataHanlderWrapper.setPath(data[0]);\r\n        return onDone ? onDone() : false;\r\n    }, \"deffered\"),\r\n    columnExists: ThreadComm.registerTasks(\"column-exists\", async (data, onDone) => {\r\n        const exists = await DataHanlderWrapper.columnExists(data);\r\n        if (onDone) {\r\n            onDone(exists);\r\n        }\r\n        return false;\r\n    }, \"deffered\"),\r\n    columnTimestamp: ThreadComm.registerTasks(\"column-timestamp\", async (data, onDone) => {\r\n        const time = await DataHanlderWrapper.columnTimestamp(data);\r\n        if (onDone) {\r\n            onDone(time);\r\n        }\r\n        return 0;\r\n    }, \"deffered\"),\r\n};\r\n","import { DVEDL } from \"../../DivineVoxelEngineDataLoader.js\";\r\nimport { ThreadComm } from \"threadcomm\";\r\nconst parentComm = ThreadComm.parent;\r\nparentComm.listenForMessage(\"connect-world\", (data, event) => {\r\n    if (!event)\r\n        return;\r\n    const port = event.ports[0];\r\n    DVEDL.worldComm.setPort(port);\r\n});\r\nparentComm.listenForMessage(\"sync-settings\", (data, event) => {\r\n    const settings = data[1];\r\n    DVEDL.syncSettings(settings);\r\n});\r\nparentComm.listenForMessage(\"re-start\", (data, event) => {\r\n    DVEDL.reStart();\r\n});\r\nexport const ParentComm = parentComm;\r\n","import { ThreadComm } from \"threadcomm\";\r\nconst worldComm = ThreadComm.createComm(\"world\", {});\r\nexport const WorldComm = worldComm;\r\n","export * from \"./DivineVoxelEngineDataLoader.js\";\r\n","export const DVEMessageHeader = 0xffff;\r\nexport const WorldDataHeaders = {\r\n    region: 0,\r\n    column: 1,\r\n    chunk: 2,\r\n};\r\n","//objects\r\nimport { ThreadComm } from \"threadcomm\";\r\nimport { WorldRegister } from \"./World/WorldRegister.js\";\r\nimport { DataSyncTypes } from \"../Common/Threads/Contracts/DataSync.js\";\r\nimport { VoxelPaletteReader } from \"./Voxel/VoxelPalette.js\";\r\nimport { DimensionsRegister } from \"./World/Dimensions/DimensionsRegister.js\";\r\nimport { ChunkTags } from \"./World/Chunk/ChunkTags.js\";\r\nimport { RegionHeaderTags, RegionTags } from \"./World/Region/RegionTags.js\";\r\nimport { ColumnTags } from \"./World/Column/ColumnTags.js\";\r\nimport { VoxelTags } from \"./Voxel/VoxelTags.js\";\r\nimport { Register } from \"./Register/Register.js\";\r\nimport { RegionHeaderRegister } from \"./World/Region/RegionHeaderRegister.js\";\r\nexport const DataSyncNode = {\r\n    _states: {\r\n        voxelData: false,\r\n    },\r\n    isReady() {\r\n        let done = true;\r\n        for (const state of Object.keys(this._states)) {\r\n            if (!this._states[state]) {\r\n                done = false;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    voxelPalette: ThreadComm.onDataSync(DataSyncTypes.voxelPalette, (data) => {\r\n        VoxelPaletteReader.setVoxelPalette(data[0], data[1]);\r\n    }),\r\n    voxelData: ThreadComm.onDataSync(DataSyncTypes.voxelTags, (data) => {\r\n        VoxelTags.$INIT(data[0]);\r\n        VoxelTags.sync(new Uint16Array(data[1]));\r\n        DataSyncNode._states.voxelData = true;\r\n    }),\r\n    dimension: ThreadComm.onDataSync(DataSyncTypes.dimesnion),\r\n    chunk: ThreadComm.onDataSync(DataSyncTypes.chunk),\r\n    column: ThreadComm.onDataSync(DataSyncTypes.column),\r\n    region: ThreadComm.onDataSync(DataSyncTypes.region),\r\n    regionHeader: ThreadComm.onDataSync(DataSyncTypes.regionHeader),\r\n    chunkTags: ThreadComm.onDataSync(DataSyncTypes.chunkTags),\r\n    columnTags: ThreadComm.onDataSync(DataSyncTypes.columnTags),\r\n    regionTags: ThreadComm.onDataSync(DataSyncTypes.regionTags),\r\n    stringMap: ThreadComm.onDataSync(DataSyncTypes.registerStringMap, (data) => {\r\n        Register.stringMaps.syncStringMap(data);\r\n    }),\r\n};\r\nDataSyncNode.dimension.addOnSync((data) => {\r\n    DimensionsRegister.registerDimension(data.id, data.options);\r\n});\r\nDataSyncNode.chunk.addOnSync((data) => {\r\n    WorldRegister.chunk.add(data[0], data[1]);\r\n});\r\nDataSyncNode.chunk.addOnUnSync((data) => {\r\n    WorldRegister.chunk.remove(data);\r\n});\r\nDataSyncNode.column.addOnSync((data) => {\r\n    WorldRegister.column.add(data[0], data[1]);\r\n});\r\nDataSyncNode.column.addOnUnSync((data) => {\r\n    WorldRegister.column.remove(data);\r\n});\r\nDataSyncNode.region.addOnSync((data) => {\r\n    WorldRegister.region.add(data[0], data[1]);\r\n});\r\nDataSyncNode.region.addOnUnSync((data) => {\r\n    WorldRegister.region.remove(data);\r\n});\r\nDataSyncNode.regionHeader.addOnSync((data) => {\r\n    RegionHeaderRegister.add(data[0], data[1]);\r\n});\r\nDataSyncNode.chunkTags.addOnSync((data) => {\r\n    ChunkTags.$INIT(data);\r\n});\r\nDataSyncNode.columnTags.addOnSync((data) => {\r\n    ColumnTags.$INIT(data);\r\n});\r\nDataSyncNode.regionTags.addOnSync((data) => {\r\n    RegionTags.$INIT(data[0]);\r\n    RegionHeaderTags.$INIT(data[1]);\r\n});\r\n","import { ZeneithDBCore } from \"../ZeneithDBCore.js\";\r\nimport { ZeneithUtil } from \"../ZeneithUtil.js\";\r\nimport { ObjectStore } from \"../Store/ObjectStore.js\";\r\nexport class DataBase {\r\n    creationData;\r\n    outsideZeneith;\r\n    dataBaseName = \"\";\r\n    util = ZeneithUtil;\r\n    opened = false;\r\n    db = null;\r\n    _beingUpgrded = false;\r\n    constructor(creationData, outsideZeneith = false) {\r\n        this.creationData = creationData;\r\n        this.outsideZeneith = outsideZeneith;\r\n        this.dataBaseName = this.creationData.databaseName;\r\n    }\r\n    isOpen() {\r\n        return this.opened && this.db !== null;\r\n    }\r\n    getUUID() {\r\n        return ZeneithUtil.getUUID();\r\n    }\r\n    open() {\r\n        if (this._beingUpgrded) {\r\n            throw new Error(\"Database is being upgraded can't open\");\r\n        }\r\n        if (this.isOpen())\r\n            return true;\r\n        const self = this;\r\n        const prom = new Promise((resolve, reject) => {\r\n            const request = indexedDB.open(this.dataBaseName);\r\n            request.onerror = function (event) {\r\n                console.warn(\"Error when opening IndexDB\");\r\n                reject(false);\r\n            };\r\n            request.onsuccess = function (event) {\r\n                //@ts-ignore\r\n                self.db = request.result;\r\n                self.opened = true;\r\n                resolve(true);\r\n            };\r\n        });\r\n        return prom;\r\n    }\r\n    close() {\r\n        if (!this.db) {\r\n            return false;\r\n        }\r\n        this.opened = false;\r\n        this.db.close();\r\n        this.db = null;\r\n        return true;\r\n    }\r\n    _openAtVersion(version = 1) {\r\n        const self = this;\r\n        const prom = new Promise(async (resolve, reject) => {\r\n            const request = indexedDB.open(this.dataBaseName, version);\r\n            request.onerror = (event) => {\r\n                reject(false);\r\n                console.log(event);\r\n                throw new Error(`Error opening ${self.dataBaseName}.`);\r\n            };\r\n            request.onblocked = () => {\r\n                console.log(\"blocked at version\");\r\n                reject(false);\r\n            };\r\n            request.onsuccess = (event) => {\r\n                self.db = request.result;\r\n                self.opened = true;\r\n                resolve(true);\r\n            };\r\n        });\r\n        return prom;\r\n    }\r\n    async $create() {\r\n        return await this.forceUpdate(undefined, true);\r\n    }\r\n    async forceUpdate(removeCollections, newDB = false) {\r\n        const self = this;\r\n        let version = newDB ? 1 : await this.getDatabaeVersion();\r\n        if (this.isOpen()) {\r\n            this.close();\r\n        }\r\n        this._beingUpgrded = true;\r\n        const prom = new Promise((resolve, reject) => {\r\n            const request = indexedDB.open(this.dataBaseName, version + 1);\r\n            request.onerror = (event) => {\r\n                reject(false);\r\n                console.log(event);\r\n                throw new Error(`Error opening ${self.dataBaseName}.`);\r\n            };\r\n            request.onblocked = (event) => {\r\n                console.log(\"blocked\");\r\n                console.log(event);\r\n                this._beingUpgrded = false;\r\n                reject(false);\r\n            };\r\n            request.onupgradeneeded = (event) => {\r\n                const db = request.result;\r\n                self.db = db;\r\n                if (!self.outsideZeneith) {\r\n                    ZeneithDBCore.updateDatBaseData(self.creationData);\r\n                }\r\n                if (removeCollections) {\r\n                    for (const collectionName of removeCollections) {\r\n                        db.deleteObjectStore(collectionName);\r\n                    }\r\n                }\r\n                for (const collectionData of self.creationData.collections) {\r\n                    const checkCollection = self.doesCollectionExist(collectionData.name);\r\n                    let collection;\r\n                    if (checkCollection) {\r\n                        const transaction = request.transaction;\r\n                        const store = transaction.objectStore(collectionData.name);\r\n                        collection = store;\r\n                    }\r\n                    else {\r\n                        collection = db.createObjectStore(collectionData.name);\r\n                    }\r\n                    self._processCollectionScehma(collection, collectionData.schema);\r\n                }\r\n            };\r\n            request.onsuccess = (event) => {\r\n                self.db = request.result;\r\n                self.opened = true;\r\n                this._beingUpgrded = false;\r\n                resolve(true);\r\n            };\r\n        });\r\n        return prom;\r\n    }\r\n    _processCollectionScehma(collection, schema) {\r\n        this.__traverseColletionScehma(collection, schema);\r\n    }\r\n    __traverseColletionScehma(collection, schema) {\r\n        for (const node of schema) {\r\n            if (Array.isArray(node)) {\r\n                this.__traverseColletionScehma(collection, node);\r\n                continue;\r\n            }\r\n            if (node.index) {\r\n                collection.createIndex(node.name, node.name, { unique: node.isUnique });\r\n            }\r\n            if (node.children) {\r\n                this.__traverseColletionScehma(collection, node.children);\r\n            }\r\n        }\r\n    }\r\n    async getCollection(id) {\r\n        if (!this.isOpen())\r\n            await this.open();\r\n        if (!this.db?.objectStoreNames.contains(id)) {\r\n            throw new Error(`${id} does not exists in database ${this.creationData.databaseName}`);\r\n        }\r\n        return new ObjectStore(this, id);\r\n    }\r\n    async addCollection(data) {\r\n        try {\r\n            if (!this.isOpen())\r\n                await this.open();\r\n            let count = 0;\r\n            for (const store of data) {\r\n                if (this.db.objectStoreNames.contains(store.name))\r\n                    continue;\r\n                this.creationData.collections.push(store);\r\n                count++;\r\n            }\r\n            if (count)\r\n                await this.forceUpdate();\r\n            return true;\r\n        }\r\n        catch (error) {\r\n            console.error(error);\r\n            return false;\r\n        }\r\n    }\r\n    async removeCollection(collectionName) {\r\n        try {\r\n            let deleteCollections = [];\r\n            if (typeof collectionName == \"string\") {\r\n                deleteCollections.push(collectionName);\r\n            }\r\n            else {\r\n                deleteCollections.push(...collectionName);\r\n            }\r\n            const collections = [];\r\n            for (const collection of this.creationData.collections) {\r\n                if (!deleteCollections.includes(collection.name)) {\r\n                    collections.push(collection);\r\n                }\r\n            }\r\n            this.creationData.collections = collections;\r\n            await this.forceUpdate(deleteCollections);\r\n            return true;\r\n        }\r\n        catch (error) {\r\n            console.log(`Failed making a new collection with the name ${collectionName}`);\r\n            console.error(error);\r\n            return false;\r\n        }\r\n    }\r\n    getDatabaeVersion() {\r\n        const prom = new Promise((resolve, reject) => {\r\n            const request = indexedDB.open(this.dataBaseName);\r\n            request.onsuccess = (event) => {\r\n                const version = request.result.version;\r\n                request.result.close();\r\n                resolve(version);\r\n            };\r\n            request.onerror = (event) => {\r\n                console.warn(\"Error when opening IndexDB\");\r\n                reject(\"Error when opening IndexDB\");\r\n            };\r\n        });\r\n        return prom;\r\n    }\r\n    doesCollectionExist(collectionName) {\r\n        if (!this.db) {\r\n            throw new Error(`Database ${this.dataBaseName} is not opened.`);\r\n        }\r\n        if (this.db.objectStoreNames.contains(collectionName)) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    getData(collectionName, key) {\r\n        const prom = new Promise(async (resolve, reject) => {\r\n            if (!this.isOpen())\r\n                await this.open();\r\n            if (!this.db) {\r\n                throw new Error(`Database ${this.dataBaseName} is not opened.`);\r\n            }\r\n            const transaction = this.db.transaction([collectionName], \"readonly\");\r\n            const objectStore = transaction.objectStore(collectionName);\r\n            const request = objectStore.get(key);\r\n            request.onerror = (event) => {\r\n                reject(false);\r\n                transaction.commit();\r\n            };\r\n            request.onsuccess = (event) => {\r\n                if (!request.result) {\r\n                    resolve(false);\r\n                }\r\n                else {\r\n                    resolve(request.result);\r\n                }\r\n                transaction.commit();\r\n            };\r\n        });\r\n        return prom;\r\n    }\r\n    getAllData(collectionName) {\r\n        const prom = new Promise(async (resolve, reject) => {\r\n            if (!this.isOpen())\r\n                await this.open();\r\n            if (!this.db) {\r\n                throw new Error(`Database ${this.dataBaseName} is not opened.`);\r\n            }\r\n            const transaction = this.db.transaction([collectionName], \"readonly\");\r\n            const request = transaction\r\n                .objectStore(collectionName)\r\n                .getAll();\r\n            request.onerror = (event) => {\r\n                reject(false);\r\n                transaction.commit();\r\n            };\r\n            request.onsuccess = (event) => {\r\n                if (!request.result) {\r\n                    resolve(false);\r\n                }\r\n                else {\r\n                    resolve(request.result);\r\n                }\r\n                transaction.commit();\r\n            };\r\n        });\r\n        return prom;\r\n    }\r\n    getAllKeys(collectionName) {\r\n        const prom = new Promise(async (resolve, reject) => {\r\n            if (!this.isOpen())\r\n                await this.open();\r\n            if (!this.db) {\r\n                throw new Error(`Database ${this.dataBaseName} is not opened.`);\r\n            }\r\n            const transaction = this.db.transaction([collectionName], \"readonly\");\r\n            const request = transaction\r\n                .objectStore(collectionName)\r\n                .getAllKeys();\r\n            request.onerror = (event) => {\r\n                reject(false);\r\n                transaction.commit();\r\n            };\r\n            request.onsuccess = (event) => {\r\n                if (!request.result) {\r\n                    resolve(false);\r\n                }\r\n                else {\r\n                    resolve(request.result);\r\n                }\r\n                transaction.commit();\r\n            };\r\n        });\r\n        return prom;\r\n    }\r\n    removeData(collectionName, key) {\r\n        const prom = new Promise(async (resolve, reject) => {\r\n            if (!this.isOpen())\r\n                await this.open();\r\n            if (!this.db) {\r\n                throw new Error(`Database ${this.dataBaseName} is not opened.`);\r\n            }\r\n            const transaction = this.db.transaction([collectionName], \"readwrite\");\r\n            const request = transaction.objectStore(collectionName).delete(key);\r\n            request.onerror = (event) => {\r\n                reject(false);\r\n                transaction.commit();\r\n            };\r\n            request.onsuccess = (event) => {\r\n                resolve(true);\r\n                transaction.commit();\r\n            };\r\n        });\r\n        return prom;\r\n    }\r\n    removeAllData(collectionName) {\r\n        const prom = new Promise(async (resolve, reject) => {\r\n            if (!this.isOpen())\r\n                await this.open();\r\n            if (!this.db) {\r\n                throw new Error(`Database ${this.dataBaseName} is not opened.`);\r\n            }\r\n            const transaction = this.db.transaction([collectionName], \"readwrite\");\r\n            const request = transaction.objectStore(collectionName).clear();\r\n            request.onerror = (event) => {\r\n                reject(false);\r\n                transaction.commit();\r\n            };\r\n            request.onsuccess = (event) => {\r\n                resolve(true);\r\n                transaction.commit();\r\n            };\r\n        });\r\n        return prom;\r\n    }\r\n    setData(collectionName, key, setData) {\r\n        const prom = new Promise(async (resolve, reject) => {\r\n            if (!this.isOpen())\r\n                await this.open();\r\n            if (!this.db) {\r\n                throw new Error(`Database ${this.dataBaseName} is not opened.`);\r\n            }\r\n            const transaction = this.db.transaction([collectionName], \"readwrite\");\r\n            const request = transaction.objectStore(collectionName).put(setData, key);\r\n            request.onerror = (event) => {\r\n                reject(false);\r\n                transaction.commit();\r\n            };\r\n            request.onsuccess = (event) => {\r\n                resolve(true);\r\n                transaction.commit();\r\n            };\r\n        });\r\n        return prom;\r\n    }\r\n    updateData(collectionName, key, updateFunction) {\r\n        const prom = new Promise(async (resolve, reject) => {\r\n            if (!this.isOpen())\r\n                await this.open();\r\n            if (!this.db) {\r\n                throw new Error(`Database ${this.dataBaseName} is not opened.`);\r\n            }\r\n            const transaction = this.db.transaction([collectionName], \"readwrite\");\r\n            const objectStore = transaction.objectStore(collectionName);\r\n            const request = objectStore.get(key);\r\n            request.onerror = (event) => {\r\n                reject(false);\r\n            };\r\n            request.onsuccess = (event) => {\r\n                //@ts-ignore\r\n                const data = event.target.result;\r\n                if (!data) {\r\n                    resolve(false);\r\n                    transaction.commit();\r\n                    return;\r\n                }\r\n                const newData = updateFunction(data);\r\n                const requestUpdate = objectStore.put(newData);\r\n                requestUpdate.onerror = (event) => {\r\n                    reject(false);\r\n                    transaction.commit();\r\n                };\r\n                requestUpdate.onsuccess = (event) => {\r\n                    resolve(true);\r\n                    transaction.commit();\r\n                };\r\n            };\r\n        });\r\n        return prom;\r\n    }\r\n}\r\n","export {};\r\n","export {};\r\n","export {};\r\n","export * from \"./Database/Database.types.js\";\r\nexport * from \"./Database/Schema.types.js\";\r\nexport * from \"./Zeneith/Database.schema.js\";\r\n","export class ObjectStore {\r\n    db;\r\n    id;\r\n    constructor(db, id) {\r\n        this.db = db;\r\n        this.id = id;\r\n    }\r\n    async get(id) {\r\n        return await this.db.getData(this.id, id);\r\n    }\r\n    async set(id, data) {\r\n        return await this.db.setData(this.id, id, data);\r\n    }\r\n    async delete(id) {\r\n        return await this.db.removeData(this.id, id);\r\n    }\r\n}\r\n","import { ZeneithDBCore } from \"./ZeneithDBCore.js\";\r\nexport const ZeneithDB = {\r\n    __initalized: false,\r\n    core: ZeneithDBCore,\r\n    async $INIT() {\r\n        if (this.__initalized)\r\n            return;\r\n        await this.core.initialize();\r\n        this.__initalized = true;\r\n    },\r\n    async databaseExists(dataBaseName) {\r\n        return await this.core.dataBaseExist(dataBaseName);\r\n    },\r\n    async createDatabase(data) {\r\n        return await this.core.createDataBase(data);\r\n    },\r\n    async updateDatabase(data) {\r\n        return await this.core.createDataBase(data);\r\n    },\r\n    async getDatabase(name) {\r\n        return await this.core.getDataBase(name);\r\n    },\r\n    async deleteDatabase(name) {\r\n        return await this.core.deleteDataBase(name);\r\n    },\r\n};\r\n","import { DataBase } from \"./Database/Database.js\";\r\nimport { ZeneithUtil } from \"./ZeneithUtil.js\";\r\nexport const ZeneithDBCore = {\r\n    dataBase: {},\r\n    __version: 1,\r\n    loadedDatabases: {},\r\n    util: ZeneithUtil,\r\n    async initialize() {\r\n        this.dataBase = new DataBase({\r\n            databaseName: \"ZeneithDB\",\r\n            collections: [\r\n                {\r\n                    name: \"meta\",\r\n                    schema: [],\r\n                },\r\n                {\r\n                    name: \"collections\",\r\n                    schema: [],\r\n                },\r\n                {\r\n                    name: \"databases\",\r\n                    schema: [],\r\n                },\r\n            ],\r\n        }, true);\r\n        const version = await this.dataBase.getDatabaeVersion();\r\n        if (version != this.__version + 1) {\r\n            console.warn(\"ZeneithDB is being created.\");\r\n            await this.dataBase.$create();\r\n        }\r\n        await this.dataBase.open();\r\n    },\r\n    async createDataBase(data) {\r\n        const databaseCheck = await this.dataBase.getData(\"databases\", data.databaseName);\r\n        if (databaseCheck) {\r\n            throw new Error(`The database ${data.databaseName} already exists. Use 'updateDatabase' to update the database instead.`);\r\n        }\r\n        await this.dataBase.setData(\"databases\", data.databaseName, {\r\n            collectionCount: data.collections.length,\r\n            creationData: data,\r\n        });\r\n        const database = new DataBase(data);\r\n        await database.$create();\r\n        return database;\r\n    },\r\n    async updateDatBaseData(data) {\r\n        await this.dataBase.setData(\"databases\", data.databaseName, {\r\n            collectionCount: data.collections.length,\r\n            creationData: data,\r\n        });\r\n    },\r\n    async getDataBase(dataBasename) {\r\n        if (this.loadedDatabases[dataBasename]) {\r\n            return this.loadedDatabases[dataBasename];\r\n        }\r\n        await this.dataBase.open();\r\n        const dataBaseCheck = await this.dataBase.getData(\"databases\", dataBasename);\r\n        if (!dataBaseCheck) {\r\n            throw new Error(`The database ${dataBasename} does not exists inside of ZeneithDB.`);\r\n        }\r\n        const database = new DataBase(dataBaseCheck.creationData);\r\n        this.loadedDatabases[dataBasename] = database;\r\n        return database;\r\n    },\r\n    async dataBaseExist(dataBasename) {\r\n        const check = await this.dataBase.getData(\"databases\", dataBasename);\r\n        if (!check) {\r\n            return false;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    },\r\n    async deleteDataBase(dataBasename) {\r\n        await this.dataBase.open();\r\n        const check = await this.dataBase.getData(\"databases\", dataBasename);\r\n        if (!check) {\r\n            return false;\r\n        }\r\n        this.dataBase.removeData(\"databases\", dataBasename);\r\n        for (const collection of check.creationData.collections) {\r\n            await this.dataBase.removeData(\"collections\", `${dataBasename}-${collection.name}`);\r\n        }\r\n        indexedDB.deleteDatabase(dataBasename);\r\n    },\r\n};\r\n","export const ZeneithUtil = {\r\n    getUUID: function () {\r\n        let d = new Date().getTime();\r\n        let d2 = (performance && performance.now && performance.now() * 1000) || 0;\r\n        return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\r\n            let r = Math.random() * 16;\r\n            if (d > 0) {\r\n                r = (d + r) % 16 | 0;\r\n                d = Math.floor(d / 16);\r\n            }\r\n            else {\r\n                r = (d2 + r) % 16 | 0;\r\n                d2 = Math.floor(d2 / 16);\r\n            }\r\n            return (c === \"x\" ? r : (r & 0x3) | 0x8).toString(16);\r\n        });\r\n    },\r\n};\r\n","export * from \"./ZeneithDB.js\";\r\nexport * from \"./Database/Database.js\";\r\nexport * from \"./Store/ObjectStore.js\";\r\n","export * from \"./ZeneithDB/index.js\";\r\nexport * from \"./ZeneithDB/Meta/index.js\";\r\n","export const CCCore = {\r\n    async compressArrayBuffer(input) {\r\n        //@ts-ignore\r\n        const cs = new CompressionStream(\"gzip\");\r\n        const writer = cs.writable.getWriter();\r\n        writer.write(input);\r\n        writer.close();\r\n        const output = [];\r\n        const reader = cs.readable.getReader();\r\n        let totalSize = 0;\r\n        while (true) {\r\n            const { value, done } = await reader.read();\r\n            if (done)\r\n                break;\r\n            output.push(value);\r\n            totalSize += value.byteLength;\r\n        }\r\n        const concatenated = new Uint8Array(totalSize);\r\n        let offset = 0;\r\n        for (const array of output) {\r\n            concatenated.set(array, offset);\r\n            offset += array.byteLength;\r\n        }\r\n        return concatenated;\r\n    },\r\n    async decompressArrayBuffer(input) {\r\n        //@ts-ignore\r\n        const ds = new DecompressionStream(\"gzip\");\r\n        const writer = ds.writable.getWriter();\r\n        writer.write(input);\r\n        writer.close();\r\n        const output = [];\r\n        const reader = ds.readable.getReader();\r\n        let totalSize = 0;\r\n        while (true) {\r\n            const { value, done } = await reader.read();\r\n            if (done)\r\n                break;\r\n            output.push(value);\r\n            totalSize += value.byteLength;\r\n        }\r\n        const concatenated = new Uint8Array(totalSize);\r\n        let offset = 0;\r\n        for (const array of output) {\r\n            concatenated.set(array, offset);\r\n            offset += array.byteLength;\r\n        }\r\n        return concatenated;\r\n    },\r\n    processArray(type, array) {\r\n        const returnArray = this.getArray[type](array.buffer);\r\n        return returnArray;\r\n    },\r\n    getArray: {\r\n        Int8: (buffer) => {\r\n            return new Int8Array(buffer);\r\n        },\r\n        Uint8: (buffer) => {\r\n            return new Uint8Array(buffer);\r\n        },\r\n        Uint8Clamped: (buffer) => {\r\n            return new Uint8ClampedArray(buffer);\r\n        },\r\n        Int16: (buffer) => {\r\n            return new Int16Array(buffer);\r\n        },\r\n        Uint16: (buffer) => {\r\n            return new Uint16Array(buffer);\r\n        },\r\n        Int32: (buffer) => {\r\n            return new Int32Array(buffer);\r\n        },\r\n        Uint32: (buffer) => {\r\n            return new Uint32Array(buffer);\r\n        },\r\n        Float32: (buffer) => {\r\n            return new Float32Array(buffer);\r\n        },\r\n        Float64: (buffer) => {\r\n            return new Float64Array(buffer);\r\n        },\r\n        BigInt64: (buffer) => {\r\n            return new BigInt64Array(buffer);\r\n        },\r\n        BigUint64: (buffer) => {\r\n            return new BigUint64Array(buffer);\r\n        },\r\n    },\r\n};\r\n","import { CCCore } from \"./CCCore.js\";\r\nexport const CrystalCompressor = {\r\n    core: CCCore,\r\n    version: 0.0,\r\n    async compressArray(array) {\r\n        const returnArray = await this.core.compressArrayBuffer(array.buffer);\r\n        return returnArray;\r\n    },\r\n    async decompressArray(buffer, type) {\r\n        const returnData = await this.core.decompressArrayBuffer(buffer);\r\n        return this.core.processArray(type, returnData);\r\n    },\r\n};\r\n","export * from \"./CrystalCompressor.js\";\r\n","export * from \"./CrystalCompressor/index.js\";\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [\"DSLIBS_divineVoxelEngine_dist_Data_Settings_EngineSettings_js-DSLIBS_threadComm_dist_index_js\",\"DSLIBS_divineVoxelEngine_dist_Common_Threads_Contracts_DataSync_js-DSLIBS_divineVoxelEngine_d-d7fdd9\"], () => (__webpack_require__(\"./compiled/environments/electron/client/dataloader.js\")))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var webpackQueues = typeof Symbol === \"function\" ? Symbol(\"webpack queues\") : \"__webpack_queues__\";\nvar webpackExports = typeof Symbol === \"function\" ? Symbol(\"webpack exports\") : \"__webpack_exports__\";\nvar webpackError = typeof Symbol === \"function\" ? Symbol(\"webpack error\") : \"__webpack_error__\";\nvar resolveQueue = (queue) => {\n\tif(queue && !queue.d) {\n\t\tqueue.d = 1;\n\t\tqueue.forEach((fn) => (fn.r--));\n\t\tqueue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));\n\t}\n}\nvar wrapDeps = (deps) => (deps.map((dep) => {\n\tif(dep !== null && typeof dep === \"object\") {\n\t\tif(dep[webpackQueues]) return dep;\n\t\tif(dep.then) {\n\t\t\tvar queue = [];\n\t\t\tqueue.d = 0;\n\t\t\tdep.then((r) => {\n\t\t\t\tobj[webpackExports] = r;\n\t\t\t\tresolveQueue(queue);\n\t\t\t}, (e) => {\n\t\t\t\tobj[webpackError] = e;\n\t\t\t\tresolveQueue(queue);\n\t\t\t});\n\t\t\tvar obj = {};\n\t\t\tobj[webpackQueues] = (fn) => (fn(queue));\n\t\t\treturn obj;\n\t\t}\n\t}\n\tvar ret = {};\n\tret[webpackQueues] = x => {};\n\tret[webpackExports] = dep;\n\treturn ret;\n}));\n__webpack_require__.a = (module, body, hasAwait) => {\n\tvar queue;\n\thasAwait && ((queue = []).d = 1);\n\tvar depQueues = new Set();\n\tvar exports = module.exports;\n\tvar currentDeps;\n\tvar outerResolve;\n\tvar reject;\n\tvar promise = new Promise((resolve, rej) => {\n\t\treject = rej;\n\t\touterResolve = resolve;\n\t});\n\tpromise[webpackExports] = exports;\n\tpromise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise[\"catch\"](x => {}));\n\tmodule.exports = promise;\n\tbody((deps) => {\n\t\tcurrentDeps = wrapDeps(deps);\n\t\tvar fn;\n\t\tvar getResult = () => (currentDeps.map((d) => {\n\t\t\tif(d[webpackError]) throw d[webpackError];\n\t\t\treturn d[webpackExports];\n\t\t}))\n\t\tvar promise = new Promise((resolve) => {\n\t\t\tfn = () => (resolve(getResult));\n\t\t\tfn.r = 0;\n\t\t\tvar fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));\n\t\t\tcurrentDeps.map((dep) => (dep[webpackQueues](fnQueue)));\n\t\t});\n\t\treturn fn.r ? promise : getResult();\n\t}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));\n\tqueue && (queue.d = 0);\n};","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".DVE.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t\"compiled_environments_electron_client_dataloader_js\": 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkdve_testing\"] = self[\"webpackChunkdve_testing\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn Promise.all([\n\t\t__webpack_require__.e(\"DSLIBS_divineVoxelEngine_dist_Data_Settings_EngineSettings_js-DSLIBS_threadComm_dist_index_js\"),\n\t\t__webpack_require__.e(\"DSLIBS_divineVoxelEngine_dist_Common_Threads_Contracts_DataSync_js-DSLIBS_divineVoxelEngine_d-d7fdd9\")\n\t]).then(next);\n};","","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n",""],"names":[],"sourceRoot":""}