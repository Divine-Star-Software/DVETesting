{"version":3,"file":"compiled_client_RichWorld_richworld_js.DVE.js","mappings":";;;;;;;;;;;;;AAAsD;AACtD,MAAM,sEAAW;;;;;;;;;;;;;;;;;;ACD0C;AACpD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC9BO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACO;AACA;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvCgF;AAC5B;AACT;AAC4B;AAChE;AACP;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uEAAmB;AAC5C,YAAY,uEAAmB;AAC/B;AACA,4BAA4B,YAAY;AACxC;AACA,6BAA6B,sEAAkB;AAC/C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uEAAmB;AAC5C,4BAA4B,oBAAoB;AAChD;AACA,6BAA6B,sEAAkB;AAC/C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sEAAkB;AACjD,yBAAyB,uEAAmB;AAC5C,YAAY,uEAAmB;AAC/B,yBAAyB,sEAAkB;AAC3C,4BAA4B,iBAAiB;AAC7C;AACA,gBAAgB,uEAAmB;AACnC,6BAA6B,sEAAkB;AAC/C,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mEAAa;AAC3C,+BAA+B,8DAAU;AACzC,yBAAyB,+DAAW;AACpC;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mEAAa;AAC3C,+BAA+B,8DAAU;AACzC,yBAAyB,+DAAW;AACpC,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAY,uEAAmB;AAC/B,yBAAyB,sEAAkB;AAC3C,4BAA4B,YAAY;AACxC,gBAAgB,uEAAmB;AACnC,6BAA6B,sEAAkB;AAC/C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAY,uEAAmB;AAC/B,yBAAyB,sEAAkB;AAC3C;AACA,oCAAoC,wBAAwB;AAC5D,gBAAgB,uEAAmB;AACnC;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,2BAA2B,uEAAmB;AAC9C,yBAAyB,sEAAkB;AAC3C,4BAA4B,YAAY;AACxC,8CAA8C,uEAAmB;AACjE,6BAA6B,sEAAkB;AAC/C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B,uEAAmB;AAC9C,yBAAyB,sEAAkB;AAC3C,4BAA4B,YAAY;AACxC,8CAA8C,uEAAmB;AACjE,6BAA6B,sEAAkB;AAC/C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD,8CAA8C,uEAAmB;AACjE,6BAA6B,sEAAkB;AAC/C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8DAAU;AACzC,yBAAyB,+DAAW;AACpC,gCAAgC,uEAAmB;AACnD,yBAAyB,sEAAkB;AAC3C,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,+BAA+B,sEAAkB;AACjD,yBAAyB,uEAAmB;AAC5C,gCAAgC,uEAAmB;AACnD,yBAAyB,sEAAkB;AAC3C,4BAA4B,iBAAiB;AAC7C,qCAAqC,uEAAmB;AACxD,6BAA6B,sEAAkB;AAC/C;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8DAAU;AACzC,yBAAyB,+DAAW;AACpC,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2BAA2B,uEAAmB;AAC9C,yBAAyB,sEAAkB;AAC3C,qCAAqC,4DAAS,CAAC,oEAAiB,EAAE,gEAAgB;AAClF;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,sEAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8DAAU;AAC/C;AACA;AACA,sBAAsB,8DAAU;AAChC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,gCAAgC,mEAAmB;AACnD;AACA,+CAA+C,sEAAkB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,sEAAkB,GAAG,sEAAkB;AACrF;AACA;AACA;AACA,2CAA2C,sEAAkB;AAC7D;AACA;AACA;AACA;AACA,2CAA2C,sEAAkB,GAAG,sEAAkB;AAClF;AACA;AACA;AACA,0BAA0B,sEAAkB;AAC5C;AACA,8CAA8C,sEAAkB,GAAG,sEAAkB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8DAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8DAAU;AAClC;AACA;AACA;AACA,sBAAsB,8DAAU;AAChC;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAAW;AAC3B,+BAA+B,+DAAW;AAC1C,6BAA6B,8DAAU;AACvC;AACA;AACA;AACA,KAAK;AACL,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+DAAW;AAC3B,gBAAgB,+DAAW;AAC3B,6BAA6B,8DAAU;AACvC;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC1ZiD;AACQ;AACpB;AAC9B;AACP,sBAAsB,0DAAI;AAC1B,YAAY,kEAAI;AAChB,eAAe,8CAAG;AAClB;;;;;;;;;;;;;;;;;;ACPuE;AACvE,WAAW,UAAU;AACoD;AACrB;AACO;AACpD;AACP;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4DAAS,CAAC,gEAAU,eAAe,gEAAU;AAChE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mBAAmB,qEAAS;AAC5B,SAAS;AACT;AACA,mBAAmB,qEAAS;AAC5B,SAAS;AACT;AACA;AACA,2BAA2B,sEAAkB;AAC7C,qBAAqB,qEAAS;AAC9B,gCAAgC,qBAAqB,sEAAU,EAAE;AACjE,oDAAoD,uEAAmB;AACvE;AACA,oCAAoC,sEAAU;AAC9C,SAAS;AACT,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS;AAC5B,SAAS;AACT;AACA;AACA;AACA;AACA,mBAAmB,qEAAS;AAC5B,SAAS;AACT;AACA,mBAAmB,qEAAS;AAC5B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS;AAC5B,SAAS;AACT;AACA;AACA;AACA;AACA,mBAAmB,qEAAS;AAC5B,SAAS;AACT;AACA,0BAA0B,qEAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,oEAAQ;AACvC,SAAS;AACT;AACA,0BAA0B,sEAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,qEAAS;AACxC,SAAS;AACT;AACA,0BAA0B,sEAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,qEAAS;AACxC,SAAS;AACT;AACA,0BAA0B,uEAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,sEAAU;AACzC,SAAS;AACT;AACA,0BAA0B,sEAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,qEAAS;AACxC,SAAS;AACT;AACA,0BAA0B,sEAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,qEAAS;AACxC,SAAS;AACT;AACA,0BAA0B,uEAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,qEAAS,GAAG,sEAAU;AACrD,SAAS;AACT;AACA,0BAA0B,sEAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,qEAAS;AACxC,SAAS;AACT;AACA,0BAA0B,oEAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,mEAAU;AACzC,SAAS;AACT;AACA,0BAA0B,qEAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAS,GAAG,oEAAW;AAC1C,SAAS;AACT,+CAA+C;AAC/C,0CAA0C;AAC1C;AACA,yBAAyB,uEAAmB;AAC5C,qBAAqB,sEAAU,GAAG,qEAAS;AAC3C;AACA,4BAA4B,UAAU;AACtC;AACA,mCAAmC,uEAAmB;AACtD,yBAAyB,sEAAU;AACnC,gCAAgC,gBAAgB;AAChD,kDAAkD,uEAAmB;AACrE,6BAA6B,sEAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2BAA2B,uEAAmB;AAC9C,qBAAqB,qEAAS,GAAG,qEAAS;AAC1C;AACA,gCAAgC,qBAAqB,sEAAU,EAAE;AACjE,8CAA8C,uEAAmB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sEAAU;AAC9C,SAAS;AACT;AACA,yBAAyB,mEAAa,CAAC,sEAAkB;AACzD,2BAA2B,uEAAmB;AAC9C,qBAAqB,qEAAS,OAAO,sEAAU;AAC/C;AACA;AACA;AACA;AACA;AACA,wBAAwB,mEAAe;AACvC;AACA,yBAAyB,+DAAW;AACpC,4BAA4B,YAAY;AACxC;AACA,yBAAyB,8DAAE;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2BAA2B,uEAAmB;AAC9C,qBAAqB,qEAAS,GAAG,qEAAS;AAC1C;AACA,gCAAgC,qBAAqB,sEAAU,EAAE;AACjE,kDAAkD,uEAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sEAAU;AAC9C,SAAS;AACT,+BAA+B;AAC/B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sEAAkB;AACzC,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sEAAkB;AACzC,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sEAAkB;AACzC,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;AC7UwD;AACF;AAC/C;AACP;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,QAAQ,uEAAmB,QAAQ,gEAAU;AAC7C,KAAK;AACL;AACA,QAAQ,uEAAmB;AAC3B,KAAK;AACL;;;;;;;;;;;;;;;;;AC5H0C;AACM;AACzC;AACP;AACA,eAAe,kEAAoB;AACnC,KAAK;AACL;AACA,eAAe,4DAAe;AAC9B,KAAK;AACL;AACA,eAAe,yDAAY;AAC3B,KAAK;AACL;;;;;;;;;;;;;;;;ACZiD;AAC1C;AACP,YAAY,0DAAI;AAChB;;;;;;;;;;;;;;;;;;ACHmD;AACI;AACC;AACjD;AACP;AACA,mBAAmB,4DAAS,CAAC,qEAAkB;AAC/C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,oEAAiB;AAC9C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,uEAAoB;AACjD,KAAK;AACL;AACA;AACA;AACA,mBAAmB,4DAAS,CAAC,sEAAmB;AAChD,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,sEAAgB;AAC7C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,uEAAiB;AAC9C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,uEAAiB;AAC9C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,wEAAkB;AAC/C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,wEAAkB;AAC/C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,uEAAiB;AAC9C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,uEAAiB;AAC9C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,uEAAiB;AAC9C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,qEAAkB;AAC/C,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,sEAAmB;AAChD,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,+EAAyB;AACtD;AACA,QAAQ,iEAAa,oBAAoB,gEAAU;AACnD,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,gFAA0B;AACvD,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,uEAAoB;AACjD,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,gFAA0B;AACvD,KAAK;AACL;AACA,mBAAmB,4DAAS,CAAC,qFAA+B,SAAS,gEAAU;AAC/E,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,MAAM;AAChC,wBAAwB,QAAQ;AAChC;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;ACjF+B;AACQ;AACC;AACJ;;;;;;;;;;;;;;;;;;;;;;;;ACHpC;AACoE;AACpB;AAChD,WAAW,iBAAiB;AAC5B;AACyD;AACG;AAC5D;AACkD;AACgB;AACI;AACX;AACnB;AACjC;AACP;AACA;AACA,QAAQ,kDAAU;AAClB,iBAAiB,mEAAW;AAC5B,UAAU,wDAAI;AACd,cAAc,4EAAc;AAC5B,eAAe,kEAAS;AACxB,gBAAgB,qEAAU;AAC1B,cAAc,2EAAgB;AAC9B,kBAAkB,8EAAY;AAC9B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,iBAAiB;AACjB;AACA;AACA,KAAK;AACL;AACA,cAAc,+DAAU;AACxB,KAAK;AACL;;;;;;;;;;;;;;;;ACrCwC;AACjC;AACP;AACA;AACA;AACA;AACA,UAAU,wDAAgB;AAC1B;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACb2C;AACmB;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yFAAiC;AAC3D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yCAAyC,yFAAiC;AAC1E;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,yFAAiC;AACzD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,mBAAmB,4DAAU;AAC7B,wBAAwB,4DAAU,GAAG;AACrC,sBAAsB,4DAAU,GAAG;AACnC,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yFAAiC;AAChE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,8CAA8C,yFAAiC;AAC/E;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,yFAAiC;AACzD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAU,GAAG;AACvC,gCAAgC,0FAAkC;AAClE,gBAAgB,4DAAU,GAAG;AAC7B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,8CAA8C,0FAAkC;AAChF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,0FAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;AC7HgE;AACxB;AACxC,mBAAmB,yDAAiB;AACpC;AACA;AACA,IAAI,kFAAkB;AACtB,CAAC;AACD;AACA,IAAI,6EAAa;AACjB,CAAC;AACM;;;;;;;;;;;;;;;;ACViC;AACxC,kBAAkB,6DAAqB;AAChC;;;;;;;;;;;;;;;;ACF6C;;;;;;;;;;;;;;;ACA7C;AACP;AACA;AACA;AACA;AACA,0CAA0C,IAAI;AAC9C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;UClBA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;;;;WClCA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;WACA;WACA,IAAI;WACJ;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,CAAC;WACD;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;WACA,sGAAsG;WACtG;WACA;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA,EAAE;WACF;WACA;;;;;WChEA;WACA;WACA;WACA;WACA,+BAA+B,wCAAwC;WACvE;WACA;WACA;WACA;WACA,iBAAiB,qBAAqB;WACtC;WACA;WACA,kBAAkB,qBAAqB;WACvC;WACA;WACA,KAAK;WACL;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WC3BA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;;;;;WCRA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WCfA;;WAEA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,aAAa;WACb;WACA;WACA;WACA;;WAEA;WACA;WACA;;WAEA;;WAEA;;;;;WCpCA;WACA;WACA;WACA;;;;;UEHA;UACA","sources":["webpack://dve-testing/./compiled/client/RichWorld/richworld.js","webpack://dve-testing/../../DSLIBS/divineBinaryObject/dist/Classes/TypedNode.js","webpack://dve-testing/../../DSLIBS/divineBinaryObject/dist/Constants/ByteData.js","webpack://dve-testing/../../DSLIBS/divineBinaryObject/dist/Constants/MetaValues.js","webpack://dve-testing/../../DSLIBS/divineBinaryObject/dist/DBO/DivineBinaryObjectParser.js","webpack://dve-testing/../../DSLIBS/divineBinaryObject/dist/DivineBinaryObject.js","webpack://dve-testing/../../DSLIBS/divineBinaryObject/dist/MMD/BufferToMMD.js","webpack://dve-testing/../../DSLIBS/divineBinaryObject/dist/MMD/MMDToBufferN.js","webpack://dve-testing/../../DSLIBS/divineBinaryObject/dist/MMD/MetaMarkedParser.js","webpack://dve-testing/../../DSLIBS/divineBinaryObject/dist/MetaMarkedData.js","webpack://dve-testing/../../DSLIBS/divineBinaryObject/dist/NodeMaker.js","webpack://dve-testing/../../DSLIBS/divineBinaryObject/dist/index.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/RichWorld/DivineStarVoxelEngineRichWorld.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/RichWorld/Init/InitWorker.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/RichWorld/Register/RichDataRegister.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/RichWorld/Threads/Parent/ParentComm.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/RichWorld/Threads/World/WorldComm.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/RichWorld/index.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/World/Data/Managers/VoxelManager.js","webpack://dve-testing/webpack/bootstrap","webpack://dve-testing/webpack/runtime/async module","webpack://dve-testing/webpack/runtime/chunk loaded","webpack://dve-testing/webpack/runtime/define property getters","webpack://dve-testing/webpack/runtime/ensure chunk","webpack://dve-testing/webpack/runtime/get javascript chunk filename","webpack://dve-testing/webpack/runtime/global","webpack://dve-testing/webpack/runtime/hasOwnProperty shorthand","webpack://dve-testing/webpack/runtime/make namespace object","webpack://dve-testing/webpack/runtime/publicPath","webpack://dve-testing/webpack/runtime/importScripts chunk loading","webpack://dve-testing/webpack/runtime/startup chunk dependencies","webpack://dve-testing/webpack/before-startup","webpack://dve-testing/webpack/startup","webpack://dve-testing/webpack/after-startup"],"sourcesContent":["import { DVERW } from \"divine-voxel-engine/RichWorld\";\r\nawait DVERW.$INIT();\r\n","import { MetaMapValues } from \"../Constants/MetaValues.js\";\r\nexport class TypedNode {\r\n    data;\r\n    get length() {\r\n        return this.data[2];\r\n    }\r\n    get type() {\r\n        return this.data[0];\r\n    }\r\n    get typeName() {\r\n        return MetaMapValues[this.type];\r\n    }\r\n    get primiteName() {\r\n        return MetaMapValues[this.type];\r\n    }\r\n    get listType() {\r\n        return this.data[1];\r\n    }\r\n    get listTypeName() {\r\n        return MetaMapValues[this.listType];\r\n    }\r\n    get value() {\r\n        return this.data[3];\r\n    }\r\n    set value(data) {\r\n        this.data[3] = data;\r\n    }\r\n    constructor(type, value, listType = 0, length = 0) {\r\n        this.data = [type, listType, length, value];\r\n    }\r\n}\r\n","export const ByteCounts = {\r\n    \"8i\": 1,\r\n    \"8ui\": 1,\r\n    \"8uic\": 1,\r\n    \"16i\": 2,\r\n    \"16ui\": 2,\r\n    \"32i\": 4,\r\n    \"32ui\": 4,\r\n    \"32f\": 4,\r\n    \"64f\": 8,\r\n    bigi: 8,\r\n    bigui: 8,\r\n};\r\nexport const ByteDataGet = {\r\n    \"8i\": (dv, index) => dv.getInt8(index),\r\n    \"8ui\": (dv, index) => dv.getUint8(index),\r\n    \"8uic\": (dv, index) => dv.getUint8(index),\r\n    \"16i\": (dv, index) => dv.getInt16(index),\r\n    \"16ui\": (dv, index) => dv.getUint16(index),\r\n    \"32i\": (dv, index) => dv.getInt32(index),\r\n    \"32ui\": (dv, index) => dv.getUint32(index),\r\n    \"32f\": (dv, index) => dv.getFloat32(index),\r\n    \"64f\": (dv, index) => dv.getFloat64(index),\r\n    //@ts-ignore\r\n    bigi: (dv, index) => dv.getBigInt64(index),\r\n    //@ts-ignore\r\n    bigui: (dv, index) => dv.getBigUint64(index),\r\n};\r\nexport const ByteDataSet = {\r\n    \"8i\": (dv, index, value) => dv.setInt8(index, value),\r\n    \"8ui\": (dv, index, value) => dv.setUint8(index, value),\r\n    \"8uic\": (dv, index, value) => dv.setUint8(index, value),\r\n    \"16i\": (dv, index, value) => dv.setInt16(index, value),\r\n    \"16ui\": (dv, index, value) => dv.setUint16(index, value),\r\n    \"32i\": (dv, index, value) => dv.setInt32(index, value),\r\n    \"32ui\": (dv, index, value) => dv.setUint32(index, value),\r\n    \"32f\": (dv, index, value) => dv.setFloat32(index, value),\r\n    \"64f\": (dv, index, value) => dv.setFloat64(index, value),\r\n    bigi: (dv, index, value) => dv.setBigInt64(index, BigInt(value)),\r\n    bigui: (dv, index, value) => dv.setBigUint64(index, BigInt(value)),\r\n};\r\nexport const TypedArrayCrete = {\r\n    \"8i\": (length) => new Int8Array(length),\r\n    \"8ui\": (length) => new Uint8Array(length),\r\n    \"8uic\": (length) => new Uint8ClampedArray(length),\r\n    \"16i\": (length) => new Int16Array(length),\r\n    \"16ui\": (length) => new Uint16Array(length),\r\n    \"32i\": (length) => new Int32Array(length),\r\n    \"32ui\": (length) => new Uint32Array(length),\r\n    \"32f\": (length) => new Float32Array(length),\r\n    \"64f\": (length) => new Float64Array(length),\r\n    bigi: (length) => new BigInt64Array(length),\r\n    bigui: (length) => new BigUint64Array(length),\r\n};\r\nexport const TypedArrayMap = {\r\n    \"8i\": Int8Array,\r\n    \"8ui\": Uint8Array,\r\n    \"8uic\": Uint8ClampedArray,\r\n    \"16i\": Int16Array,\r\n    \"16ui\": Uint16Array,\r\n    \"32i\": Int32Array,\r\n    \"32ui\": Uint32Array,\r\n    \"32f\": Float32Array,\r\n    \"64f\": Float64Array,\r\n    bigi: BigInt64Array,\r\n    bigui: BigUint64Array,\r\n};\r\nexport const ByteParser = {\r\n    view: new DataView(new ArrayBuffer(8)),\r\n    count: 0,\r\n    value: 0,\r\n    setValue(type, value) {\r\n        this.value = value;\r\n        ByteDataSet[type](this.view, 0, value);\r\n        this.count = ByteCounts[type];\r\n        return this;\r\n    },\r\n    addBytes(data) {\r\n        for (let i = 0; i < this.count; i++) {\r\n            data.push(this.view.getUint8(i));\r\n        }\r\n    }\r\n};\r\n","const markers = [\r\n    \"start\",\r\n    \"end\",\r\n    \"object\",\r\n    \"object-start\",\r\n    \"object-end\",\r\n    \"array\",\r\n    \"array-start\",\r\n    \"array-end\",\r\n    \"name\",\r\n    \"8i\",\r\n    \"8ui\",\r\n    \"8uic\",\r\n    \"16i\",\r\n    \"16ui\",\r\n    \"32f\",\r\n    \"32i\",\r\n    \"32ui\",\r\n    \"64f\",\r\n    \"bigi\",\r\n    \"bigui\",\r\n    \"fixed-typed-array\",\r\n    \"fixed-string\",\r\n    \"string\",\r\n    \"fixed-string-array\",\r\n    \"string-array\",\r\n    \"typed-array\",\r\n    \"json\",\r\n    \"mmd\",\r\n];\r\nconst metaValues = {};\r\nfor (let i = 0; i < markers.length; i++) {\r\n    metaValues[markers[i]] = i;\r\n}\r\nexport const MetaValues = metaValues;\r\nexport const MetaMapValues = {};\r\nfor (const key of Object.keys(MetaValues)) {\r\n    //@ts-ignore\r\n    MetaMapValues[Number(MetaValues[key])] = key;\r\n}\r\n","import { ByteCounts, ByteDataGet, ByteDataSet } from \"../Constants/ByteData.js\";\r\nimport { TypedNode } from \"../Classes/TypedNode.js\";\r\nimport { MMD } from \"../MetaMarkedData.js\";\r\nimport { MetaMapValues, MetaValues } from \"../Constants/MetaValues.js\";\r\nexport const DBOP = {\r\n    mmdTokens: [],\r\n    jsonStrings: [],\r\n    schemas: {},\r\n    advancedElementSetFunctions: {\r\n        string: (dv, byteCount, element) => {\r\n            if (typeof element.value != \"string\") {\r\n                throw new Error(\"Value must a string for 'fixed-length-string'\");\r\n            }\r\n            const length = element.value.length;\r\n            const string = element.value;\r\n            const func = ByteDataSet[\"16ui\"];\r\n            ByteDataSet[\"32ui\"](dv, byteCount, length);\r\n            byteCount += 4;\r\n            for (let i = 0; i < length; i++) {\r\n                func(dv, byteCount, string.charCodeAt(i));\r\n                byteCount += ByteCounts[\"16ui\"];\r\n            }\r\n            return byteCount;\r\n        },\r\n        \"fixed-string\": (dv, byteCount, element) => {\r\n            if (typeof element.value != \"string\") {\r\n                throw new Error(\"Value must a string for 'fixed-length-string'\");\r\n            }\r\n            if (!element.length) {\r\n                throw new Error(\"Length must be set for 'fixed-length-string'\");\r\n            }\r\n            const string = element.value;\r\n            const func = ByteDataSet[\"16ui\"];\r\n            for (let i = 0; i < element.length; i++) {\r\n                func(dv, byteCount, string.charCodeAt(i));\r\n                byteCount += ByteCounts[\"16ui\"];\r\n            }\r\n            return byteCount;\r\n        },\r\n        \"string-array\": (dv, byteCount, element) => {\r\n            if (!Array.isArray(element.value)) {\r\n                throw new Error(\"String array must be an array.\");\r\n            }\r\n            let value = element.value;\r\n            const arrayLength = element.value.length;\r\n            const byteLength = ByteCounts[\"16ui\"];\r\n            const func = ByteDataSet[\"16ui\"];\r\n            ByteDataSet[\"32ui\"](dv, byteCount, arrayLength);\r\n            byteCount += ByteCounts[\"32ui\"];\r\n            for (let i = 0; i < arrayLength; i++) {\r\n                let string = value[i];\r\n                ByteDataSet[\"32ui\"](dv, byteCount, string.length);\r\n                byteCount += ByteCounts[\"32ui\"];\r\n                for (let k = 0; k < string.length; k++) {\r\n                    func(dv, byteCount, string.charCodeAt(k));\r\n                    byteCount += byteLength;\r\n                }\r\n            }\r\n            return byteCount;\r\n        },\r\n        \"typed-array\": (dv, byteCount, element) => {\r\n            if (!element.listType || !Array.isArray(element.value)) {\r\n                throw new Error(\"Fixed length type list must have list type set\");\r\n            }\r\n            const value = element.value;\r\n            const arrayLength = element.value.length;\r\n            const arrayType = MetaMapValues[element.listType];\r\n            const byteLength = ByteCounts[arrayType];\r\n            const func = ByteDataSet[arrayType];\r\n            dv.setUint32(byteCount, arrayLength);\r\n            byteCount += 4;\r\n            for (let i = 0; i < arrayLength; i++) {\r\n                func(dv, byteCount, value[i]);\r\n                byteCount += byteLength;\r\n            }\r\n            return byteCount;\r\n        },\r\n        \"fixed-typed-array\": (dv, byteCount, element) => {\r\n            if (!element.listType ||\r\n                !Array.isArray(element.value) ||\r\n                !element.length) {\r\n                throw new Error(\"Fixed length type list must have list type set\");\r\n            }\r\n            const value = element.value;\r\n            const arrayLength = element.length;\r\n            const arrayType = MetaMapValues[element.listType];\r\n            const byteLength = ByteCounts[arrayType];\r\n            const func = ByteDataSet[arrayType];\r\n            for (let i = 0; i < arrayLength; i++) {\r\n                func(dv, byteCount, value[i]);\r\n                byteCount += byteLength;\r\n            }\r\n            return byteCount;\r\n        },\r\n        json: (dv, byteCount, element) => {\r\n            const jsonString = DBOP.jsonStrings.shift();\r\n            if (!jsonString)\r\n                return;\r\n            const length = jsonString.length;\r\n            ByteDataSet[\"32ui\"](dv, byteCount, length);\r\n            byteCount += ByteCounts[\"32ui\"];\r\n            for (let i = 0; i < length; i++) {\r\n                ByteDataSet[\"16ui\"](dv, byteCount, jsonString.charCodeAt(i));\r\n                byteCount += ByteCounts[\"16ui\"];\r\n            }\r\n            return byteCount;\r\n        },\r\n        mmd: (dv, byteCount, element) => {\r\n            const mmdData = DBOP.mmdTokens.shift();\r\n            if (!mmdData)\r\n                return;\r\n            const length = mmdData.byteLength;\r\n            ByteDataSet[\"32ui\"](dv, byteCount, length);\r\n            byteCount += ByteCounts[\"32ui\"];\r\n            const array = new Uint8Array(mmdData);\r\n            for (let i = byteCount; i < byteCount + length; i++) {\r\n                ByteDataSet[\"16ui\"](dv, byteCount, array[i]);\r\n            }\r\n            byteCount += length;\r\n            return byteCount;\r\n        },\r\n    },\r\n    advancedElementGetFunctions: {\r\n        string: (dv, byteCount, element, targetObject, name) => {\r\n            let string = \"\";\r\n            const length = ByteDataGet[\"32ui\"](dv, byteCount);\r\n            byteCount += ByteCounts[\"32ui\"];\r\n            for (let i = 0; i < length; i++) {\r\n                string += String.fromCharCode(ByteDataGet[\"16ui\"](dv, byteCount));\r\n                byteCount += ByteCounts[\"16ui\"];\r\n            }\r\n            targetObject[name] = string;\r\n            return byteCount;\r\n        },\r\n        json: (dv, byteCount, element, targetObject, name) => {\r\n            let string = \"\";\r\n            const length = ByteDataGet[\"32ui\"](dv, byteCount);\r\n            byteCount += ByteCounts[\"32ui\"];\r\n            for (let i = 0; i < length; i++) {\r\n                string += String.fromCharCode(ByteDataGet[\"16ui\"](dv, byteCount));\r\n                byteCount += ByteCounts[\"16ui\"];\r\n            }\r\n            const json = JSON.parse(string);\r\n            targetObject[name] = json;\r\n            return byteCount;\r\n        },\r\n        \"fixed-string\": (dv, byteCount, element, targetObject, name) => {\r\n            if (typeof element.value != \"string\") {\r\n                throw new Error(\"Value must a string for 'fixed-length-string'\");\r\n            }\r\n            if (!element.length) {\r\n                throw new Error(\"Length must be set for 'fixed-length-string'\");\r\n            }\r\n            let string = \"\";\r\n            for (let i = 0; i < element.length; i++) {\r\n                string += String.fromCharCode(ByteDataGet[\"16ui\"](dv, byteCount));\r\n                byteCount += ByteCounts[\"16ui\"];\r\n            }\r\n            targetObject[name] = string;\r\n            return byteCount;\r\n        },\r\n        \"typed-array\": (dv, byteCount, element, targetObject, name) => {\r\n            if (!element.listType || !Array.isArray(element.value)) {\r\n                throw new Error(\"Fixed length type list must have list type set\");\r\n            }\r\n            const payloadArray = [];\r\n            const arrayType = element.listTypeName;\r\n            const byteLength = ByteCounts[arrayType];\r\n            const func = ByteDataGet[arrayType];\r\n            const arrayLength = ByteDataGet[\"32ui\"](dv, byteCount);\r\n            byteCount += ByteCounts[\"32ui\"];\r\n            for (let i = 0; i < arrayLength; i++) {\r\n                payloadArray[i] = func(dv, byteCount);\r\n                byteCount += byteLength;\r\n            }\r\n            targetObject[name] = payloadArray;\r\n            return byteCount;\r\n        },\r\n        \"string-array\": (dv, byteCount, element, targetObject, name) => {\r\n            if (!Array.isArray(element.value)) {\r\n                throw new Error(\"Fixed length type list must have list type set\");\r\n            }\r\n            const payloadArray = [];\r\n            const byteLength = ByteCounts[\"16ui\"];\r\n            const func = ByteDataGet[\"16ui\"];\r\n            const arrayLength = ByteDataGet[\"32ui\"](dv, byteCount);\r\n            byteCount += ByteCounts[\"32ui\"];\r\n            for (let i = 0; i < arrayLength; i++) {\r\n                const stringLength = ByteDataGet[\"32ui\"](dv, byteCount);\r\n                byteCount += ByteCounts[\"32ui\"];\r\n                let string = \"\";\r\n                for (let k = 0; k < stringLength; k++) {\r\n                    string += String.fromCharCode(func(dv, byteCount));\r\n                    byteCount += byteLength;\r\n                }\r\n                payloadArray.push(string);\r\n            }\r\n            targetObject[name] = payloadArray;\r\n            return byteCount;\r\n        },\r\n        \"fixed-typed-array\": (dv, byteCount, element, targetObject, name) => {\r\n            if (!element.listType ||\r\n                !Array.isArray(element.value) ||\r\n                !element.length) {\r\n                throw new Error(\"Fixed length type list must have list type set\");\r\n            }\r\n            const payloadArray = [];\r\n            const arrayLength = element.length;\r\n            const arrayType = element.listTypeName;\r\n            const byteLength = ByteCounts[arrayType];\r\n            const func = ByteDataGet[arrayType];\r\n            for (let i = 0; i < arrayLength; i++) {\r\n                payloadArray[i] = func(dv, byteCount);\r\n                byteCount += byteLength;\r\n            }\r\n            targetObject[name] = payloadArray;\r\n            return byteCount;\r\n        },\r\n        mmd: (dv, byteCount, element, targetObject, name) => {\r\n            const length = ByteDataGet[\"32ui\"](dv, byteCount);\r\n            byteCount += ByteCounts[\"32ui\"];\r\n            targetObject[name] = new TypedNode(MetaValues[\"mmd\"], MMD.parser.toMMD(dv.buffer, byteCount, byteCount + length));\r\n            return byteCount + length;\r\n        },\r\n    },\r\n    getBuffer(length, SAB) {\r\n        if (SAB) {\r\n            return new SharedArrayBuffer(length);\r\n        }\r\n        return new ArrayBuffer(length);\r\n    },\r\n    syncSABWtihBuffer(sab, buffer) {\r\n        const temp1 = new Uint8Array(sab);\r\n        const temp2 = new Uint8Array(buffer);\r\n        temp1.set(temp2, 0);\r\n    },\r\n    sharedBufferToBuffer(sab) {\r\n        const temp1 = new Uint8Array(sab);\r\n        const temp2 = new Uint8Array(sab.byteLength);\r\n        temp2.set(temp1, 0);\r\n        return temp2.buffer;\r\n    },\r\n    registerSchema(id, schema) {\r\n        const legnth = this._calculateSchemaLength(schema);\r\n        this.schemas[id] = {\r\n            length: legnth,\r\n            schema: schema,\r\n        };\r\n    },\r\n    _calculateSchemaLength(schema) {\r\n        let length = 0;\r\n        for (const key of Object.keys(schema)) {\r\n            const element = schema[key];\r\n            if (element.typeName == \"mmd\") {\r\n                length = -1;\r\n                break;\r\n            }\r\n            if (element.typeName == \"typed-array\") {\r\n                length = -1;\r\n                break;\r\n            }\r\n            if (element.typeName == \"string\") {\r\n                length = -1;\r\n                break;\r\n            }\r\n            if (element.typeName == \"string-array\") {\r\n                length = -1;\r\n                break;\r\n            }\r\n            if (element.typeName == \"json\") {\r\n                length = -1;\r\n                break;\r\n            }\r\n            if (element.typeName == \"fixed-string\" && element.length) {\r\n                length += element.length * ByteCounts[\"16ui\"];\r\n                continue;\r\n            }\r\n            if (element.typeName == \"fixed-typed-array\" &&\r\n                element.length &&\r\n                element.listType) {\r\n                length +=\r\n                    element.length * ByteCounts[element.listTypeName];\r\n                continue;\r\n            }\r\n            length += ByteCounts[element.typeName];\r\n        }\r\n        return length;\r\n    },\r\n    _calculateVariableSizeBuffer(schema) {\r\n        let length = 0;\r\n        for (const key of Object.keys(schema)) {\r\n            const element = schema[key];\r\n            if (element.typeName == \"mmd\") {\r\n                const mmdData = MMD.parser.toBuffer(element.value);\r\n                this.mmdTokens.push(mmdData);\r\n                length += mmdData.byteLength + ByteCounts[\"32ui\"];\r\n                continue;\r\n            }\r\n            if (element.typeName == \"json\") {\r\n                let jsonString;\r\n                if (typeof element.value == \"string\") {\r\n                    jsonString = element.value;\r\n                }\r\n                else {\r\n                    jsonString = JSON.stringify(element.value);\r\n                }\r\n                this.jsonStrings.push(jsonString);\r\n                length += jsonString.length * ByteCounts[\"16ui\"] + ByteCounts[\"32ui\"];\r\n                continue;\r\n            }\r\n            if (element.typeName == \"fixed-string\" && element.length) {\r\n                length += element.length * ByteCounts[\"16ui\"];\r\n                continue;\r\n            }\r\n            if (element.typeName == \"string\" && typeof element.value == \"string\") {\r\n                length +=\r\n                    element.value.length * ByteCounts[\"16ui\"] + ByteCounts[\"32ui\"];\r\n                continue;\r\n            }\r\n            if (element.typeName == \"string-array\") {\r\n                length += ByteCounts[\"32ui\"];\r\n                for (const string of element.value) {\r\n                    length += string.length * ByteCounts[\"16ui\"] + ByteCounts[\"32ui\"];\r\n                }\r\n                continue;\r\n            }\r\n            if (element.typeName == \"fixed-typed-array\" &&\r\n                element.length &&\r\n                element.listType) {\r\n                length +=\r\n                    element.length * ByteCounts[element.listTypeName];\r\n                continue;\r\n            }\r\n            if (element.typeName == \"typed-array\" &&\r\n                Array.isArray(element.value) &&\r\n                element.listType) {\r\n                length +=\r\n                    element.value.length *\r\n                        ByteCounts[element.listTypeName] +\r\n                        4;\r\n                continue;\r\n            }\r\n            length += ByteCounts[element.typeName];\r\n        }\r\n        return length;\r\n    },\r\n    getSchema(id) {\r\n        return this.schemas[id];\r\n    },\r\n    createObject(schemaId, buffer) {\r\n        let dv;\r\n        //@ts-ignore\r\n        if (Buffer && !(buffer instanceof DataView)) {\r\n            //@ts-ignore\r\n            dv = new DataView(new Uint8Array(buffer).buffer);\r\n        }\r\n        else {\r\n            if (buffer instanceof DataView) {\r\n                dv = buffer;\r\n            }\r\n            else {\r\n                dv = new DataView(buffer);\r\n            }\r\n        }\r\n        const schemaData = this.getSchema(schemaId);\r\n        const object = new Object();\r\n        const schema = schemaData.schema;\r\n        let byteCount = 0;\r\n        for (const name of Object.keys(schema)) {\r\n            const element = schema[name];\r\n            if (this.advancedElementGetFunctions[element.typeName]) {\r\n                byteCount = this.advancedElementGetFunctions[element.typeName](dv, byteCount, element, object, name);\r\n                continue;\r\n            }\r\n            if (ByteDataGet[element.typeName]) {\r\n                object[name] = ByteDataGet[element.typeName](dv, byteCount);\r\n                byteCount += ByteCounts[element.typeName];\r\n            }\r\n        }\r\n        return object;\r\n    },\r\n    createBuffer(schemaId, updatedValues = {}) {\r\n        const schemaData = this.getSchema(schemaId);\r\n        const schema = schemaData.schema;\r\n        for (const key of Object.keys(updatedValues)) {\r\n            const val = updatedValues[key];\r\n            if (schema[key]) {\r\n                schema[key].value = val;\r\n            }\r\n        }\r\n        let length = schemaData.length;\r\n        if (length < 0) {\r\n            length = this._calculateVariableSizeBuffer(schema);\r\n        }\r\n        const buffer = new ArrayBuffer(length);\r\n        const dv = new DataView(buffer);\r\n        let byteCount = 0;\r\n        for (const key of Object.keys(schema)) {\r\n            const element = schema[key];\r\n            if (this.advancedElementSetFunctions[element.typeName]) {\r\n                byteCount = this.advancedElementSetFunctions[element.typeName](dv, byteCount, element);\r\n                continue;\r\n            }\r\n            if (ByteDataSet[element.typeName]) {\r\n                ByteDataSet[element.typeName](dv, byteCount, Number(element.value));\r\n                byteCount += ByteCounts[element.typeName];\r\n            }\r\n        }\r\n        return buffer;\r\n    },\r\n};\r\n","import { MMDP } from \"./MMD/MetaMarkedParser.js\";\r\nimport { DBOP } from \"./DBO/DivineBinaryObjectParser.js\";\r\nimport { TNM } from \"./NodeMaker.js\";\r\nexport const DBO = {\r\n    metaMarkedParser: MMDP,\r\n    parser: DBOP,\r\n    nodeMaker: TNM,\r\n};\r\n","import { MetaValues, MetaMapValues } from \"../Constants/MetaValues.js\";\r\n//import { MMDNode } from \"../Classes/MMDNode.js\";\r\nimport { ByteCounts as BC, ByteDataGet } from \"../Constants/ByteData.js\";\r\nimport { TypedNode } from \"../Classes/TypedNode.js\";\r\nimport { TypedArrayCrete } from \"../Constants/ByteData.js\";\r\nexport const BToMMD = {\r\n    _mode: \"object\",\r\n    _cobj: {},\r\n    _parents: [],\r\n    _objArray: [],\r\n    _name: \"\",\r\n    _length: 0,\r\n    _objCount: 0,\r\n    _inOject: false,\r\n    _newMMDNode(type, value, listType = \"start\") {\r\n        //@ts-ignore\r\n        return new TypedNode(MetaValues[type], value, MetaValues[listType]);\r\n    },\r\n    _assign(value) {\r\n        if (BToMMD._mode == \"object\" || BToMMD._mode == \"json\") {\r\n            if (Array.isArray(this._cobj)) {\r\n                this._cobj.push(value);\r\n            }\r\n            else {\r\n                this._cobj[this._name] = value;\r\n            }\r\n        }\r\n        else {\r\n            if (Array.isArray(this._cobj.value)) {\r\n                this._cobj.value.push(value);\r\n            }\r\n            else {\r\n                this._cobj.value[this._name] = value;\r\n            }\r\n        }\r\n    },\r\n    markFunctions: {\r\n        start: (dv, index) => {\r\n            return BC[\"8ui\"] + index;\r\n        },\r\n        end: (dv, index) => {\r\n            return BC[\"8ui\"] + index;\r\n        },\r\n        name: (dv, index) => {\r\n            BToMMD._name = \"\";\r\n            const length = ByteDataGet[\"8ui\"](dv, index + 1);\r\n            index += BC[\"8ui\"] * 2;\r\n            for (let i = index; i < index + length * BC[\"16ui\"]; i += 2) {\r\n                BToMMD._name += String.fromCharCode(ByteDataGet[\"16ui\"](dv, i));\r\n            }\r\n            return index + length * BC[\"16ui\"];\r\n        },\r\n        object: (dv, index) => { },\r\n        \"object-start\": (dv, index) => {\r\n            let newObj;\r\n            if (BToMMD._mode == \"object\") {\r\n                newObj = {};\r\n            }\r\n            else {\r\n                newObj = BToMMD._newMMDNode(\"object\", {});\r\n            }\r\n            if (BToMMD._objCount != 0) {\r\n                BToMMD._assign(newObj);\r\n                BToMMD._parents.push(BToMMD._cobj);\r\n            }\r\n            BToMMD._objCount++;\r\n            BToMMD._cobj = newObj;\r\n            return BC[\"8ui\"] + index;\r\n        },\r\n        \"object-end\": (dv, index) => {\r\n            if (BToMMD._parents.length > 0) {\r\n                BToMMD._cobj = BToMMD._parents.pop();\r\n            }\r\n            return BC[\"8ui\"] + index;\r\n        },\r\n        array: (dv, index) => {\r\n            return BC[\"8ui\"] + index;\r\n        },\r\n        \"array-start\": (dv, index) => {\r\n            let newObj;\r\n            if (BToMMD._mode == \"object\") {\r\n                newObj = [];\r\n            }\r\n            else {\r\n                newObj = BToMMD._newMMDNode(\"array\", []);\r\n            }\r\n            if (BToMMD._objCount != 0) {\r\n                BToMMD._assign(newObj);\r\n                BToMMD._parents.push(BToMMD._cobj);\r\n            }\r\n            BToMMD._objCount++;\r\n            BToMMD._cobj = newObj;\r\n            return BC[\"8ui\"] + index;\r\n        },\r\n        \"array-end\": (dv, index) => {\r\n            if (BToMMD._parents.length > 0) {\r\n                BToMMD._cobj = BToMMD._parents.pop();\r\n            }\r\n            return BC[\"8ui\"] + index;\r\n        },\r\n        \"8i\": (dv, index) => {\r\n            const value = ByteDataGet[\"8i\"](dv, index + 1);\r\n            if (BToMMD._mode != \"mmd\") {\r\n                BToMMD._assign(value);\r\n            }\r\n            else {\r\n                BToMMD._assign(BToMMD._newMMDNode(\"8i\", value));\r\n            }\r\n            return BC[\"8ui\"] + BC[\"8i\"] + index;\r\n        },\r\n        \"8ui\": (dv, index) => {\r\n            const value = ByteDataGet[\"8ui\"](dv, index + 1);\r\n            if (BToMMD._mode != \"mmd\") {\r\n                BToMMD._assign(value);\r\n            }\r\n            else {\r\n                BToMMD._assign(BToMMD._newMMDNode(\"8ui\", value));\r\n            }\r\n            return BC[\"8ui\"] + BC[\"8ui\"] + index;\r\n        },\r\n        \"16i\": (dv, index) => {\r\n            const value = ByteDataGet[\"16i\"](dv, index + 1);\r\n            if (BToMMD._mode != \"mmd\") {\r\n                BToMMD._assign(value);\r\n            }\r\n            else {\r\n                BToMMD._assign(BToMMD._newMMDNode(\"16i\", value));\r\n            }\r\n            return BC[\"8ui\"] + BC[\"16i\"] + index;\r\n        },\r\n        \"16ui\": (dv, index) => {\r\n            const value = ByteDataGet[\"16ui\"](dv, index + 1);\r\n            if (BToMMD._mode != \"mmd\") {\r\n                BToMMD._assign(value);\r\n            }\r\n            else {\r\n                BToMMD._assign(BToMMD._newMMDNode(\"16ui\", value));\r\n            }\r\n            return BC[\"8ui\"] + BC[\"16ui\"] + index;\r\n        },\r\n        \"32f\": (dv, index) => {\r\n            const value = ByteDataGet[\"32f\"](dv, index + 1);\r\n            if (BToMMD._mode != \"mmd\") {\r\n                BToMMD._assign(value);\r\n            }\r\n            else {\r\n                BToMMD._assign(BToMMD._newMMDNode(\"32f\", value));\r\n            }\r\n            return BC[\"8ui\"] + BC[\"32f\"] + index;\r\n        },\r\n        \"32i\": (dv, index) => {\r\n            const value = ByteDataGet[\"32i\"](dv, index + 1);\r\n            if (BToMMD._mode != \"mmd\") {\r\n                BToMMD._assign(value);\r\n            }\r\n            else {\r\n                BToMMD._assign(BToMMD._newMMDNode(\"32i\", value));\r\n            }\r\n            return BC[\"8ui\"] + BC[\"32i\"] + index;\r\n        },\r\n        \"32ui\": (dv, index) => {\r\n            const value = ByteDataGet[\"32ui\"](dv, index + 1);\r\n            if (BToMMD._mode != \"mmd\") {\r\n                BToMMD._assign(value);\r\n            }\r\n            else {\r\n                BToMMD._assign(BToMMD._newMMDNode(\"32ui\", value));\r\n            }\r\n            return BC[\"8ui\"] + BC[\"8ui\"] + BC[\"32ui\"] + index + 1;\r\n        },\r\n        \"64f\": (dv, index) => {\r\n            const value = ByteDataGet[\"64f\"](dv, index + 1);\r\n            if (BToMMD._mode != \"mmd\") {\r\n                BToMMD._assign(value);\r\n            }\r\n            else {\r\n                BToMMD._assign(BToMMD._newMMDNode(\"64f\", value));\r\n            }\r\n            return BC[\"8ui\"] + BC[\"64f\"] + index;\r\n        },\r\n        bigi: (dv, index) => {\r\n            const value = ByteDataGet[\"bigi\"](dv, index + 1);\r\n            if (BToMMD._mode != \"mmd\") {\r\n                BToMMD._assign(value);\r\n            }\r\n            else {\r\n                BToMMD._assign(BToMMD._newMMDNode(\"bigi\", value));\r\n            }\r\n            return BC[\"8ui\"] + BC[\"bigi\"] + index;\r\n        },\r\n        bigui: (dv, index) => {\r\n            const value = ByteDataGet[\"bigui\"](dv, index + 1);\r\n            if (BToMMD._mode != \"mmd\") {\r\n                BToMMD._assign(value);\r\n            }\r\n            else {\r\n                BToMMD._assign(BToMMD._newMMDNode(\"bigui\", value));\r\n            }\r\n            return BC[\"8ui\"] + BC[\"bigui\"] + index;\r\n        },\r\n        \"fixed-typed-array\": (dv, index) => { },\r\n        \"fixed-string\": (dv, index) => { },\r\n        \"string-array\": (dv, index) => {\r\n            const size = ByteDataGet[\"32ui\"](dv, index + 1);\r\n            index += BC[\"32ui\"] + BC[\"8ui\"];\r\n            const array = [];\r\n            for (let i = 0; i < size; i++) {\r\n                let string = \"\";\r\n                const stringSize = ByteDataGet[\"32ui\"](dv, index);\r\n                index += BC[\"32ui\"];\r\n                for (let k = 0; k < stringSize; k++) {\r\n                    string += String.fromCharCode(ByteDataGet[\"16ui\"](dv, index));\r\n                    index += BC[\"16ui\"];\r\n                }\r\n                array.push(string);\r\n            }\r\n            if (BToMMD._mode != \"mmd\") {\r\n                BToMMD._assign(array);\r\n            }\r\n            else {\r\n                BToMMD._assign(BToMMD._newMMDNode(\"string-array\", array));\r\n            }\r\n            return index;\r\n        },\r\n        string: (dv, index) => {\r\n            const length = ByteDataGet[\"32ui\"](dv, index + 1);\r\n            index += BC[\"32f\"] + BC[\"8ui\"];\r\n            let string = \"\";\r\n            for (let i = index; i < index + length * BC[\"16ui\"]; i += 2) {\r\n                string += String.fromCharCode(ByteDataGet[\"16ui\"](dv, i));\r\n            }\r\n            if (BToMMD._mode != \"mmd\") {\r\n                BToMMD._assign(string);\r\n            }\r\n            else {\r\n                BToMMD._assign(BToMMD._newMMDNode(\"string\", string));\r\n            }\r\n            return index + length * BC[\"16ui\"];\r\n        },\r\n        \"typed-array\": (dv, index) => {\r\n            const type = MetaMapValues[ByteDataGet[\"8ui\"](dv, index + 1)];\r\n            const length = ByteDataGet[\"32ui\"](dv, index + 2);\r\n            index += BC[\"8ui\"] * 2 + BC[\"32ui\"];\r\n            let array;\r\n            if (BToMMD._mode == \"json\") {\r\n                array = [];\r\n            }\r\n            else {\r\n                array = TypedArrayCrete[type](length);\r\n            }\r\n            const func = ByteDataGet[type];\r\n            for (let i = 0; i < length; i++) {\r\n                array[i] = func(dv, index);\r\n                index += BC[type];\r\n            }\r\n            if (BToMMD._mode != \"mmd\") {\r\n                BToMMD._assign(array);\r\n            }\r\n            else {\r\n                BToMMD._assign(BToMMD._newMMDNode(\"typed-array\", array, type));\r\n            }\r\n            return index;\r\n        },\r\n        json: (dv, index) => {\r\n            const length = ByteDataGet[\"32ui\"](dv, index + 1);\r\n            index += BC[\"32f\"] + BC[\"8ui\"];\r\n            let jsonString = \"\";\r\n            for (let i = index; i < index + length * BC[\"16ui\"]; i += 2) {\r\n                jsonString += String.fromCharCode(ByteDataGet[\"16ui\"](dv, i));\r\n            }\r\n            const result = JSON.parse(jsonString);\r\n            if (BToMMD._mode != \"mmd\") {\r\n                BToMMD._assign(result);\r\n            }\r\n            else {\r\n                BToMMD._assign(BToMMD._newMMDNode(\"string\", result));\r\n            }\r\n            return index + length * BC[\"16ui\"];\r\n        },\r\n        mmd: (dv, index) => { },\r\n    },\r\n    toObject(buffer, byteOffSet = 0) {\r\n        this._mode = \"object\";\r\n        let legnth = buffer.byteLength;\r\n        const dv = new DataView(buffer);\r\n        this._objCount = 0;\r\n        let index = byteOffSet;\r\n        let mark = \"16i\";\r\n        let markType = 0;\r\n        while (index < legnth) {\r\n            markType = ByteDataGet[\"8ui\"](dv, index);\r\n            mark = MetaMapValues[markType];\r\n            index = this.markFunctions[mark](dv, index);\r\n        }\r\n        return this._cobj;\r\n    },\r\n    toJSON(buffer, byteOffSet = 0) {\r\n        this._mode = \"json\";\r\n        let legnth = buffer.byteLength;\r\n        const dv = new DataView(buffer);\r\n        this._objCount = 0;\r\n        let index = byteOffSet;\r\n        let mark = \"16i\";\r\n        let markType = 0;\r\n        while (index < legnth) {\r\n            markType = ByteDataGet[\"8ui\"](dv, index);\r\n            mark = MetaMapValues[markType];\r\n            index = this.markFunctions[mark](dv, index);\r\n        }\r\n        return this._cobj;\r\n    },\r\n    toMMD(buffer, byteOffSet = 0, byteOffSetEnd = 0) {\r\n        this._mode = \"mmd\";\r\n        let legnth;\r\n        if (byteOffSetEnd == 0) {\r\n            legnth = buffer.byteLength;\r\n        }\r\n        else {\r\n            legnth = byteOffSetEnd;\r\n        }\r\n        const dv = new DataView(buffer);\r\n        this._objCount = 0;\r\n        let index = byteOffSet;\r\n        let mark = \"16i\";\r\n        let markType = 0;\r\n        while (index < legnth) {\r\n            markType = ByteDataGet[\"8ui\"](dv, index);\r\n            mark = MetaMapValues[markType];\r\n            index = this.markFunctions[mark](dv, index);\r\n        }\r\n        this._parents = [];\r\n        return this._cobj;\r\n    },\r\n};\r\n","import { MetaValues } from \"../Constants/MetaValues.js\";\r\nimport { ByteParser } from \"../Constants/ByteData.js\";\r\nexport const MMDToBuffer = {\r\n    _proto: [],\r\n    _tokenizeString(string) {\r\n        for (let i = 0; i < string.length; i++) {\r\n            this._addToken(\"16ui\", string.charCodeAt(i));\r\n        }\r\n    },\r\n    _traverseObj(data) {\r\n        this._addMarker(\"object-start\");\r\n        //for the object start and end marks\r\n        for (const key of Object.keys(data.value)) {\r\n            let length = key.length;\r\n            if (length > 255) {\r\n                throw new Error(\"An object key cannot be longer then 255 chars.\");\r\n            }\r\n            this._addMarker(\"name\");\r\n            this._addToken(\"8ui\", key.length);\r\n            this._tokenizeString(key);\r\n            const node = data.value[key];\r\n            if (node.typeName == \"object\") {\r\n                this._traverseObj(node);\r\n                continue;\r\n            }\r\n            if (node.typeName == \"array\") {\r\n                this._traverseArray(node);\r\n                continue;\r\n            }\r\n            this._tokenizePrimiives(node);\r\n        }\r\n        this._addMarker(\"object-end\");\r\n    },\r\n    _traverseArray(data) {\r\n        this._addMarker(\"array-start\");\r\n        //for object array start and end marks\r\n        const array = data.value;\r\n        for (const node of array) {\r\n            if (typeof node.value == \"object\" && !Array.isArray(node.value)) {\r\n                this._traverseObj(node);\r\n                continue;\r\n            }\r\n            if (typeof node.value == \"object\" && Array.isArray(node.value)) {\r\n                this._traverseArray(node);\r\n                continue;\r\n            }\r\n            this._tokenizePrimiives(node);\r\n        }\r\n        this._addMarker(\"array-end\");\r\n    },\r\n    _tokenizePrimiives(node) {\r\n        if (node.typeName == \"string\") {\r\n            this._addMarker(\"string\");\r\n            this._addToken(\"32ui\", node.value.length);\r\n            for (let i = 0; i < node.value.length; i++) {\r\n                this._addToken(\"16ui\", node.value.charCodeAt(i));\r\n            }\r\n            return;\r\n        }\r\n        if (typeof node.value == \"number\") {\r\n            this._addMarker(node.typeName);\r\n            this._addToken(node.primiteName, node.value);\r\n            return;\r\n        }\r\n        if (node.typeName == \"typed-array\") {\r\n            this._addMarker(\"typed-array\");\r\n            this._addToken(\"8ui\", node.listType);\r\n            this._addToken(\"32ui\", node.value.length);\r\n            let array = node.value;\r\n            for (let i = 0; i < array.length; i++) {\r\n                this._addToken(node.listTypeName, node.value[i]);\r\n            }\r\n        }\r\n        if (node.typeName == \"string-array\") {\r\n            this._addMarker(\"string-array\");\r\n            this._addToken(\"32ui\", node.value.length);\r\n            let array = node.value;\r\n            for (let i = 0; i < array.length; i++) {\r\n                const value = array[i];\r\n                this._addToken(\"32ui\", value.length);\r\n                for (let k = 0; k < value.length; k++) {\r\n                    this._addToken(\"16ui\", value.charCodeAt(k));\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        if (node.typeName == \"json\") {\r\n            let json = \"\";\r\n            if (typeof node.value == \"object\") {\r\n                json = JSON.stringify(node.value);\r\n            }\r\n            else {\r\n                json = node.value;\r\n            }\r\n            this._addMarker(\"json\");\r\n            this._addToken(\"32ui\", json.length);\r\n            for (let i = 0; i < json.length; i++) {\r\n                this._addToken(\"16ui\", json.charCodeAt(i));\r\n            }\r\n            return;\r\n        }\r\n    },\r\n    _tokenize(node) {\r\n        //start as two bytes for the stand and end tags\r\n        if (node.typeName == \"object\" && !Array.isArray(node.value)) {\r\n            this._traverseObj(node);\r\n        }\r\n        if (node.typeName == \"array\" && Array.isArray(node.value)) {\r\n            this._traverseArray(node);\r\n        }\r\n    },\r\n    toBuffer(data, byteOffSet = 0) {\r\n        this._addMarker(\"start\");\r\n        this._tokenize(data);\r\n        this._addMarker(\"end\");\r\n        const array = Uint8Array.from(this._proto);\r\n        return array.buffer;\r\n    },\r\n    _addMarker(marker) {\r\n        ByteParser.setValue(\"8ui\", MetaValues[marker]).addBytes(this._proto);\r\n    },\r\n    _addToken(type, value) {\r\n        ByteParser.setValue(type, value).addBytes(this._proto);\r\n    },\r\n};\r\n","import { BToMMD } from \"./BufferToMMD.js\";\r\nimport { MMDToBuffer } from \"./MMDToBufferN.js\";\r\nexport const MMDP = {\r\n    toBuffer(data) {\r\n        return MMDToBuffer.toBuffer(data);\r\n    },\r\n    toObject(buffer, byteOffSet = 0) {\r\n        return BToMMD.toObject(buffer);\r\n    },\r\n    toMMD(buffer, byteOffSet = 0, byteOffSetEnd = 0) {\r\n        return BToMMD.toMMD(buffer, byteOffSet, byteOffSetEnd);\r\n    },\r\n};\r\n","import { MMDP } from \"./MMD/MetaMarkedParser.js\";\r\nexport const MMD = {\r\n    parser: MMDP,\r\n};\r\n","import { TypedNode } from \"./Classes/TypedNode.js\";\r\nimport { MetaValues } from \"./Constants/MetaValues.js\";\r\nimport { TypedArrayMap } from \"./Constants/ByteData.js\";\r\nexport const TNM = {\r\n    json(data) {\r\n        return new TypedNode(MetaValues[\"json\"], data);\r\n    },\r\n    mmd(data) {\r\n        return new TypedNode(MetaValues[\"mmd\"], data);\r\n    },\r\n    object(data) {\r\n        return new TypedNode(MetaValues[\"object\"], data);\r\n    },\r\n    array(data) {\r\n        if (!Array.isArray(data))\r\n            throw new Error(\"Data for array must be an array.\");\r\n        return new TypedNode(MetaValues[\"array\"], data);\r\n    },\r\n    _8i(value) {\r\n        return new TypedNode(MetaValues[\"8i\"], value);\r\n    },\r\n    _8ui(value) {\r\n        return new TypedNode(MetaValues[\"8ui\"], value);\r\n    },\r\n    _16i(value) {\r\n        return new TypedNode(MetaValues[\"16i\"], value);\r\n    },\r\n    _16ui(value) {\r\n        return new TypedNode(MetaValues[\"16ui\"], value);\r\n    },\r\n    _32ui(value) {\r\n        return new TypedNode(MetaValues[\"32ui\"], value);\r\n    },\r\n    _32i(value) {\r\n        return new TypedNode(MetaValues[\"32i\"], value);\r\n    },\r\n    _32f(value) {\r\n        return new TypedNode(MetaValues[\"32f\"], value);\r\n    },\r\n    _64f(value) {\r\n        return new TypedNode(MetaValues[\"64f\"], value);\r\n    },\r\n    bigi(value) {\r\n        return new TypedNode(MetaValues[\"bigi\"], value);\r\n    },\r\n    bigui(value) {\r\n        return new TypedNode(MetaValues[\"bigui\"], value);\r\n    },\r\n    typedArray(type, value) {\r\n        return new TypedNode(MetaValues[\"typed-array\"], \r\n        //@ts-ignore\r\n        TypedArrayMap[type].from(value), MetaValues[type]);\r\n    },\r\n    stringArray(value) {\r\n        return new TypedNode(MetaValues[\"string-array\"], value);\r\n    },\r\n    string(value) {\r\n        return new TypedNode(MetaValues[\"string\"], value);\r\n    },\r\n    fixedString(value, length) {\r\n        return new TypedNode(MetaValues[\"fixed-string\"], value, 0, length);\r\n    },\r\n    fixedTypedArray(type, value, length) {\r\n        return new TypedNode(MetaValues[\"fixed-typed-array\"], value, MetaValues[type], length);\r\n    },\r\n    toJSONString(json) {\r\n        if (typeof json === \"string\") {\r\n            json = JSON.parse(json);\r\n        }\r\n        let output = JSON.stringify(json, function (k, v) {\r\n            if (v instanceof Array)\r\n                return JSON.stringify(v);\r\n            return v;\r\n        }, 2)\r\n            .replace(/\\\\/g, \"\")\r\n            .replace(/\\\"\\[/g, \"[\")\r\n            .replace(/\\]\\\"/g, \"]\")\r\n            .replace(/\\\"\\{/g, \"{\")\r\n            .replace(/\\}\\\"/g, \"}\");\r\n        return output;\r\n    },\r\n};\r\n","export * from \"./NodeMaker.js\";\r\nexport * from \"./Classes/TypedNode.js\";\r\nexport * from \"./DivineBinaryObject.js\";\r\nexport * from \"./MetaMarkedData.js\";\r\n","//objects\r\nimport { EngineSettings } from \"../Data/Settings/EngineSettings.js\";\r\nimport { Util } from \"../Global/Util.helper.js\";\r\n//import { RichWorldTasks } from \"./Tasks/Tasks.js\";\r\n//threads\r\nimport { WorldComm } from \"./Threads/World/WorldComm.js\";\r\nimport { ParentComm } from \"./Threads/Parent/ParentComm.js\";\r\n//functions\r\nimport { InitWorker } from \"./Init/InitWorker.js\";\r\nimport { RichDataRegister } from \"./Register/RichDataRegister.js\";\r\nimport { VoxelManager } from \"../World/Data/Managers/VoxelManager.js\";\r\nimport { WorldBounds } from \"../Data/World/WorldBounds.js\";\r\nimport { ThreadComm } from \"threadcomm\";\r\nexport const DVERW = {\r\n    environment: \"browser\",\r\n    __settingsHaveBeenSynced: false,\r\n    TC: ThreadComm,\r\n    worldBounds: WorldBounds,\r\n    UTIL: Util,\r\n    settings: EngineSettings,\r\n    worldComm: WorldComm,\r\n    parentComm: ParentComm,\r\n    richData: RichDataRegister,\r\n    voxelManager: VoxelManager,\r\n    //takss: RichWorldTasks,\r\n    syncSettings(data) {\r\n        this.settings.syncSettings(data);\r\n        this.settings.syncWithWorldBounds(this.worldBounds);\r\n        this.__settingsHaveBeenSynced = true;\r\n    },\r\n    reStart() { },\r\n    isReady() {\r\n        return DVERW.worldComm.isReady() && DVERW.__settingsHaveBeenSynced;\r\n    },\r\n    async $INIT() {\r\n        await InitWorker(this);\r\n    },\r\n};\r\n","import { ThreadComm } from \"threadcomm\";\r\nexport async function InitWorker(DVERW) {\r\n    let parent = \"render\";\r\n    if (DVERW.environment == \"node\") {\r\n        parent = \"server\";\r\n    }\r\n    await ThreadComm.$INIT(\"rich-world\", parent);\r\n    await DVERW.UTIL.createPromiseCheck({\r\n        check: () => {\r\n            return DVERW.isReady();\r\n        },\r\n        checkInterval: 1,\r\n    });\r\n}\r\n","import { TNM } from \"divine-binary-object\";\r\nimport { WorldSpaces } from \"../../Data/World/WorldSpaces.js\";\r\nexport const RichDataRegister = {\r\n    _dimensions: new Map(),\r\n    dimensions: {\r\n        get(dimensionId) {\r\n            const dimension = RichDataRegister._dimensions.get(dimensionId);\r\n            if (!dimension)\r\n                return false;\r\n            return dimension;\r\n        },\r\n        add(dimensionId) {\r\n            const newdimension = new Map();\r\n            RichDataRegister._dimensions.set(dimensionId, newdimension);\r\n            return newdimension;\r\n        },\r\n    },\r\n    region: {\r\n        _getRegionData() {\r\n            return {\r\n                columns: new Map(),\r\n            };\r\n        },\r\n        add(location) {\r\n            let dimension = RichDataRegister.dimensions.get(location[0]);\r\n            if (!dimension) {\r\n                dimension = RichDataRegister.dimensions.add(location[0]);\r\n            }\r\n            const region = this._getRegionData();\r\n            dimension.set(WorldSpaces.region.getKeyLocation(location), region);\r\n            return region;\r\n        },\r\n        get(location) {\r\n            const dimension = RichDataRegister.dimensions.get(location[0]);\r\n            if (!dimension)\r\n                return false;\r\n            const region = dimension.get(WorldSpaces.region.getKeyLocation(location));\r\n            if (!region)\r\n                return false;\r\n            return region;\r\n        },\r\n        remove(location) {\r\n            const dimension = RichDataRegister.dimensions.get(location[0]);\r\n            if (!dimension)\r\n                return false;\r\n            const key = WorldSpaces.region.getKeyLocation(location);\r\n            const region = dimension.get(key);\r\n            if (!region)\r\n                return false;\r\n            dimension.delete(key);\r\n            return region;\r\n        },\r\n    },\r\n    column: {\r\n        _getColumnData() {\r\n            return TNM.object({\r\n                chunks: TNM.object({}),\r\n                data: TNM.object({}),\r\n            });\r\n        },\r\n        add(location) {\r\n            let region = RichDataRegister.region.get(location);\r\n            if (!region) {\r\n                region = RichDataRegister.region.add(location);\r\n            }\r\n            const column = this._getColumnData();\r\n            region.columns.set(WorldSpaces.column.getKeyLocation(location), column);\r\n            return column;\r\n        },\r\n        get(location) {\r\n            const region = RichDataRegister.region.get(location);\r\n            if (!region)\r\n                return false;\r\n            const column = region.columns.get(WorldSpaces.column.getKeyLocation(location));\r\n            if (!column)\r\n                return false;\r\n            return column;\r\n        },\r\n        remove(location) {\r\n            const region = RichDataRegister.region.get(location);\r\n            if (!region)\r\n                return false;\r\n            const key = WorldSpaces.column.getKeyLocation(location);\r\n            const column = region.columns.get(key);\r\n            if (!column)\r\n                return false;\r\n            region.columns.delete(key);\r\n            return column;\r\n        },\r\n    },\r\n    chunk: {\r\n        _getChunkData() {\r\n            return {};\r\n        },\r\n        add(location) {\r\n            let column = RichDataRegister.column.get(location);\r\n            if (!column) {\r\n                column = RichDataRegister.column.add(location);\r\n            }\r\n            const chunk = TNM.object({});\r\n            column.value.chunks[WorldSpaces.chunk.getIndexLocation(location)] =\r\n                TNM.object({});\r\n            return chunk;\r\n        },\r\n        get(location) {\r\n            let column = RichDataRegister.column.get(location);\r\n            if (!column)\r\n                return false;\r\n            const chunk = column.value.chunks[WorldSpaces.chunk.getIndexLocation(location)];\r\n            if (!chunk)\r\n                return false;\r\n            return chunk;\r\n        },\r\n        remove(location) {\r\n            let column = RichDataRegister.column.get(location);\r\n            if (!column)\r\n                return false;\r\n            const index = WorldSpaces.chunk.getIndexLocation(location);\r\n            const chunk = column.value.chunks[index];\r\n            if (!chunk)\r\n                return false;\r\n            delete column.value.chunks[index];\r\n            return chunk;\r\n        },\r\n    },\r\n};\r\n","import { DVERW } from \"../../DivineStarVoxelEngineRichWorld.js\";\r\nimport { ThreadComm } from \"threadcomm\";\r\nconst parentComm = ThreadComm.parent;\r\nparentComm.listenForMessage(\"sync-settings\", (data, event) => {\r\n    const settings = data[1];\r\n    DVERW.syncSettings(settings);\r\n});\r\nparentComm.listenForMessage(\"re-start\", (data, event) => {\r\n    DVERW.reStart();\r\n});\r\nexport const ParentComm = parentComm;\r\n","import { ThreadComm } from \"threadcomm\";\r\nconst worldComm = ThreadComm.createComm(\"world\");\r\nexport const WorldComm = worldComm;\r\n","export * from \"./DivineStarVoxelEngineRichWorld.js\";\r\n","export const VoxelManager = {\r\n    voxelData: new Map(),\r\n    getVoxelData(id) {\r\n        const voxelData = this.voxelData.get(id);\r\n        if (!voxelData) {\r\n            throw new Error(`Voxel with ${id} does not exists.`);\r\n        }\r\n        return voxelData;\r\n    },\r\n    registerVoxelData(data) {\r\n        if (Array.isArray(data)) {\r\n            for (const voxel of data) {\r\n                this.voxelData.set(voxel.id, voxel);\r\n            }\r\n            return;\r\n        }\r\n        this.voxelData.set(data.id, data);\r\n    },\r\n};\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [\"DSLIBS_divineVoxelEngine_dist_Data_Settings_EngineSettings_js-DSLIBS_threadComm_dist_index_js\"], () => (__webpack_require__(\"./compiled/client/RichWorld/richworld.js\")))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var webpackQueues = typeof Symbol === \"function\" ? Symbol(\"webpack queues\") : \"__webpack_queues__\";\nvar webpackExports = typeof Symbol === \"function\" ? Symbol(\"webpack exports\") : \"__webpack_exports__\";\nvar webpackError = typeof Symbol === \"function\" ? Symbol(\"webpack error\") : \"__webpack_error__\";\nvar resolveQueue = (queue) => {\n\tif(queue && !queue.d) {\n\t\tqueue.d = 1;\n\t\tqueue.forEach((fn) => (fn.r--));\n\t\tqueue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));\n\t}\n}\nvar wrapDeps = (deps) => (deps.map((dep) => {\n\tif(dep !== null && typeof dep === \"object\") {\n\t\tif(dep[webpackQueues]) return dep;\n\t\tif(dep.then) {\n\t\t\tvar queue = [];\n\t\t\tqueue.d = 0;\n\t\t\tdep.then((r) => {\n\t\t\t\tobj[webpackExports] = r;\n\t\t\t\tresolveQueue(queue);\n\t\t\t}, (e) => {\n\t\t\t\tobj[webpackError] = e;\n\t\t\t\tresolveQueue(queue);\n\t\t\t});\n\t\t\tvar obj = {};\n\t\t\tobj[webpackQueues] = (fn) => (fn(queue));\n\t\t\treturn obj;\n\t\t}\n\t}\n\tvar ret = {};\n\tret[webpackQueues] = x => {};\n\tret[webpackExports] = dep;\n\treturn ret;\n}));\n__webpack_require__.a = (module, body, hasAwait) => {\n\tvar queue;\n\thasAwait && ((queue = []).d = 1);\n\tvar depQueues = new Set();\n\tvar exports = module.exports;\n\tvar currentDeps;\n\tvar outerResolve;\n\tvar reject;\n\tvar promise = new Promise((resolve, rej) => {\n\t\treject = rej;\n\t\touterResolve = resolve;\n\t});\n\tpromise[webpackExports] = exports;\n\tpromise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise[\"catch\"](x => {}));\n\tmodule.exports = promise;\n\tbody((deps) => {\n\t\tcurrentDeps = wrapDeps(deps);\n\t\tvar fn;\n\t\tvar getResult = () => (currentDeps.map((d) => {\n\t\t\tif(d[webpackError]) throw d[webpackError];\n\t\t\treturn d[webpackExports];\n\t\t}))\n\t\tvar promise = new Promise((resolve) => {\n\t\t\tfn = () => (resolve(getResult));\n\t\t\tfn.r = 0;\n\t\t\tvar fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));\n\t\t\tcurrentDeps.map((dep) => (dep[webpackQueues](fnQueue)));\n\t\t});\n\t\treturn fn.r ? promise : getResult();\n\t}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));\n\tqueue && (queue.d = 0);\n};","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".DVE.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t\"compiled_client_RichWorld_richworld_js\": 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkdve_testing\"] = self[\"webpackChunkdve_testing\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(\"DSLIBS_divineVoxelEngine_dist_Data_Settings_EngineSettings_js-DSLIBS_threadComm_dist_index_js\").then(next);\n};","","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n",""],"names":[],"sourceRoot":""}