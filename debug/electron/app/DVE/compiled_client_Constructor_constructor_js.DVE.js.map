{"version":3,"file":"compiled_client_Constructor_constructor_js.DVE.js","mappings":";;;;;;;;;;;;;;;AAA2G;AACpD;AACQ;AAC/D,oHAA0B,CAAC,iEAAI;AAC/B,sFAAyB,CAAC,oEAAc;AACxC,MAAM,uEAAU;;;;;;;;;;;;;;;;;ACLhB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA,+BAA+B,EAAE;AACjC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;AChHO;AACP;AACA;AACA,wBAAwB,QAAQ;AAChC,wGAAwG,EAAE;AAC1G;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;;AChCA;AACA;AAC2D;AACR;AACQ;AACpD;AACP,IAAI,uEAAgB;AACpB,IAAI,+DAAY;AAChB,IAAI,uEAAa;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACpGuD;AACF;AACV;AACH;AAC8C;AAC/B;AACvD,mBAAmB,qDAAa;AAChC,oBAAoB,qDAAa;AACjC,uBAAuB,qDAAa;AACpC;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mFAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0EAAoB;AACxC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0BAA0B;AACxD,kCAAkC,0BAA0B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+FAAuB;AACnD;AACA;AACA;AACA;AACA;AACA,gCAAgC,gEAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC7JsD;AAC/C;AACP;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvB6E;AACtE;AACP;AACA;AACA;AACA,uBAAuB,0GAA8B;AACrD;AACA;AACA,uBAAuB,0GAA8B;AACrD;AACA;AACA,uBAAuB,2GAA+B;AACtD;AACA;AACA,uBAAuB,2GAA+B;AACtD;AACA;AACA,uBAAuB,kHAAsC;AAC7D;AACA;AACA,uBAAuB,kHAAsC;AAC7D;AACA;AACA,uBAAuB,kHAAsC;AAC7D;AACA;AACA,uBAAuB,kHAAsC;AAC7D;AACA;AACA,uBAAuB,uGAA2B;AAClD;AACA;AACA,uBAAuB,uGAA2B;AAClD;AACA;AACA,uBAAuB,wGAA4B;AACnD;AACA;AACA,uBAAuB,wGAA4B;AACnD;AACA;AACA,uBAAuB,+GAAmC;AAC1D;AACA;AACA,uBAAuB,+GAAmC;AAC1D;AACA;AACA,uBAAuB,+GAAmC;AAC1D;AACA;AACA,uBAAuB,+GAAmC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3D0E;AACnE;AACP;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA,6BAA6B,UAAU;AACvC,iCAAiC,UAAU;AAC3C;AACA;AACA,wCAAwC,+GAAsC;AAC9E;AACA;AACA;AACA,wCAAwC,+GAAsC;AAC9E;AACA;AACA;AACA,wCAAwC,+GAAsC;AAC9E;AACA;AACA;AACA,wCAAwC,+GAAsC;AAC9E;AACA;AACA;AACA,wCAAwC,uGAA8B;AACtE;AACA;AACA;AACA,wCAAwC,uGAA8B;AACtE;AACA;AACA;AACA,wCAAwC,wGAA+B;AACvE;AACA;AACA;AACA,wCAAwC,wGAA+B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjDoD;AACP;AAC7C,gBAAgB;AAChB,cAAc;AACP;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAc;AACtB;AACA;AACA;;;;;;;;;;;;;;;;;AC9CqE;AACJ;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC,yBAAyB,gBAAgB;AACzC,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC,yBAAyB,gBAAgB;AACzC,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,8EAAmB;AACvB,IAAI,8EAAmB;AACvB,IAAI,8EAAmB;AACvB,IAAI,8EAAmB;AACvB,IAAI,0EAAiB;AACrB;;;;;;;;;;;;;;;;AC9EiE;AAC1D;AACP;AACA;AACA;AACA,YAAY,mFAAqB;AACjC;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChDsC;AACJ;AACA;;;;;;;;;;;;;;;ACFlC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;AC1BS;AAC7B;AACA;AACA;AACA;AACA,yBAAyB,gDAAI;AAC7B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,UAAU,EAAC;;;;;;;;;;;;;;;;ACjCG;AAC7B;AACA;AACA;AACA;AACA,oBAAoB,gDAAI;AACxB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;;ACjDQ;AAC7B;AACA;AACA;AACA;AACA,2BAA2B,gDAAI;AAC/B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,YAAY,EAAC;;;;;;;;;;;;;;;;;;;;AC/CwB;AACV;AACc;AACP;AACjD;AACA;AACA;AACA,SAAS;AACT;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,oBAAoB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,YAAY,8DAAiB;AAC7B;AACA;AACA;AACA,2BAA2B,4DAAK;AAChC;AACA,2BAA2B,iEAAU;AACrC;AACA,2BAA2B,mEAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;;ACnGpB;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;;;;;;;;;;;;;;;;;ACtBuC;AACvC,iEAAe,gDAAI,EAAC;AACJ;;;;;;;;;;;;;;;ACFT;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACNO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACvBA;AACyE;AACb;AAC5D;AACuE;AACE;AACd;AACJ;AACC;AACxD;AAC8E;AAC9E,eAAe,0FAAsB;AACrC,oBAAoB,0FAAsB;AACnC;AACP,aAAa,gEAAe;AAC5B,eAAe,oEAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oFAAsB;AACzC,kBAAkB,mFAAqB;AACvC;AACA;AACA;AACA,sBAAsB,uFAAmC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ,+EAAsB;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAkB,qFAAU,CAAC,qFAAiC;AAC9D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8EAAI;AAC/C,SAAS;AACT;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACtF8D;AACgB;AACF;AACA;AACV;AAClE,uBAAuB,mFAAc;AACrC,0BAA0B,iFAAa;AACvC,sBAAsB,iFAAa;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ,oFAA0B;AAClC;AACA,mBAAmB,mFAA2B;AAC9C,mBAAmB,mFAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,UAAU;AACvC,iCAAiC,UAAU;AAC3C,uCAAuC,UAAU;AACjD;AACA;AACA;AACA;AACA;AACA,QAAQ,qFAA2B;AACnC,KAAK;AACL;;;;;;;;;;;;;;;ACnCO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;ACXA;AAC0D;AACF;AACM;AACT;AACC;AACK;AAC3D;AACoD;AACoB;AACjE;AACP,oBAAoB,uEAAc;AAClC,kBAAkB,iEAAY;AAC9B,iBAAiB,+DAAW;AAC5B,eAAe,8DAAS;AACxB,oBAAoB,oEAAc;AAClC,eAAe,iFAAe;AAC9B;AACA;AACA,QAAQ,iEAAW;AACnB,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,oBAAoB,+FAAiC;AACrD;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA,QAAQ,kGAAoC;AAC5C;AACA;AACA;AACA,QAAQ,mGAAqC;AAC7C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,KAAK;AACL;;;;;;;;;;;;;;;;;;AChD+F;AACtB;AACF;AAChE;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,2BAA2B,4EAAmB;AAC9C,aAAa;AACb;AACA,2BAA2B,kFAAyB;AACpD,aAAa;AACb,SAAS;AACT;AACA;AACA,2BAA2B,gFAAqB;AAChD,aAAa;AACb,SAAS;AACT;AACA;AACA,2BAA2B,kFAAsB;AACjD,aAAa;AACb,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;ACrCyE;AAClE;AACP;AACA;AACA;AACA;AACA,QAAQ,oGAA4C;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,QAAQ,oGAA4C;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvGyE;AAClE;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ,oGAA4C;AACpD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpCyE;AAClE;AACP;AACA;AACA;AACA;AACA,QAAQ,oGAA4C;AACpD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjBoD;AACR;AACrC;AACP,YAAY;AACZ;AACA,iBAAiB,6DAAW;AAC5B,aAAa,qDAAO;AACpB,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,QAAQ,oEAAkB;AAC1B,KAAK;AACL;;;;;;;;;;;;;;;ACjBA;AACA,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC1RmF;AAC5E;AACP;AACA;AACA,IAAI,+FAAqB;AACzB;;;;;;;;;;;;;;;;;ACLA;AACA;AAC6D;AACP;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yEAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sFAAwB;AAChC,KAAK;AACL;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC1H4C;AACgD;AACzB;AACH;AACY;AAC5E,WAAW,+DAAS;AACpB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAA4B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0EAA+B;AACnC,IAAI,gFAAkC;AACtC;AACA,YAAY,6FAA2B,wDAAwD,qEAA0B;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB;AACjB;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,oBAAoB;AACpB,oBAAoB;AACpB,mBAAmB;AACnB,mBAAmB;AACZ;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kGAA2B;AAC3C,4BAA4B,iBAAiB;AAC7C,sBAAsB,2FAAoB;AAC1C,YAAY,iEAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kEAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,2EAAgC;AACzC;AACA,mCAAmC,2EAAgC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4EAAiC;AAC/D;AACA;AACA;AACA,IAAI,0EAA+B;AACnC,IAAI,gFAAkC;AACtC,kBAAkB,6FAA2B,yCAAyC,+EAAoC,OAAO,qEAA0B;AAC3J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnbA;AAC6F;AAChC;AAC7D;AACA;AAC6D;AACA;AAC7D;AACyF;AACb;AAC5E;AACgG;AACjB;AACN;AACR;AACL;AACA;AAC5D,YAAY,sGAAsB;AAClC,YAAY,sGAAsB;AAClC,0BAA0B,iFAAa;AACvC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,cAAc,+DAAQ;AACtB,eAAe,+DAAS;AACxB,kBAAkB,sEAAa;AAC/B,uBAAuB,gFAAiB;AACxC,kBAAkB,kFAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,QAAQ,2EAAoB;AAC5B,QAAQ,kFAA2B;AACnC,QAAQ,kFAA2B;AACnC,KAAK;AACL;AACA;AACA;AACA;AACA,sCAAsC,kFAA2B;AACjE;AACA;AACA;AACA;AACA,0BAA0B,6FAA2B;AACrD;AACA,0BAA0B,6FAA2B;AACrD;AACA,0BAA0B,6FAA2B;AACrD;AACA;AACA;AACA;AACA,0BAA0B,qEAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,0BAA0B,qEAAU;AACpC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kGAA2B;AAC3C;AACA,0BAA0B,2FAAoB;AAC9C;AACA,qCAAqC,kEAAO;AAC5C;AACA;AACA;AACA,yCAAyC,wFAAiC;AAC1E;AACA;AACA,0BAA0B,wFAAiC;AAC3D;AACA;AACA,QAAQ,+EAAwB;AAChC,4BAA4B,qEAAc;AAC1C,yBAAyB,6FAAqC;AAC9D;AACA,YAAY,yEAAc;AAC1B;AACA,0CAA0C,kEAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mFAA2B;AAC9C,mBAAmB,mFAA2B;AAC9C;AACA;AACA;AACA,yBAAyB,UAAU;AACnC,6BAA6B,UAAU;AACvC,mCAAmC,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACnMO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;AC9BA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACvCO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;ACb+E;AACxE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kGAAgC;AAChC;AACA,CAAC;AACD,kGAAgC;AAChC;AACA,CAAC;AACD,kGAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kGAAgC;AAChC;AACA;AACA,CAAC;AACD;AACA,kGAAgC;AAChC;AACA,CAAC;AACD,kGAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AClL+E;AACxE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kGAAgC;AAChC;AACA,CAAC;AACD,kGAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kGAAgC;AAChC;AACA,CAAC;AACD;AACA,kGAAgC;AAChC;AACA,CAAC;AACD,kGAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;ACjGD;AAC+E;AACxE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kGAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnOA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC9D+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kGAAgC;AAChC;AACA;AACA;AACA;AACA,CAAC;AACD,kGAAgC;AAChC;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;AC/GD;AACqE;AACZ;AACS;AACD;AACF;AACA;AACxD;AACP,uCAAuC,kEAAa;AACpD,uCAAuC,0EAAiB;AACxD,uCAAuC,wEAAe;AACtD,uCAAuC,wEAAe;AACtD,uCAAuC,2EAAgB;AACvD,uCAAuC,8EAAa;AACpD;;;;;;;;;;;;;;;;;;;ACd+E;AACP;AACC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wFAA+B;AAC1C;AACA;AACA,SAAS,wFAA+B;AACxC,SAAS,wFAA+B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qEAAU;AACjC;AACA,wBAAwB,qEAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qEAAU;AACjC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,kGAAgC;AACpC;AACA,KAAK;AACL,IAAI,kGAAgC;AACpC;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACzEA;AAC2D;AAC3D;AACkD;AACoB;AAC/D;AACP;AACA;AACA,qBAAqB,2DAAgB;AACrC;AACA;AACA;AACA,2BAA2B,kEAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wEAAmB;;;;;;;;;;;;;;;;AC1CqD;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,iBAAiB,wFAA+B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wFAA+B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uFAA8B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uFAA8B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qFAA4B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qFAA4B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oFAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oFAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+FAAsC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+FAAsC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+FAAsC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+FAAsC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4FAAmC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4FAAmC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4FAAmC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4FAAmC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3YO;AACP;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,oBAAoB,UAAU,GAAG,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,IAAI,6BAA6B,QAAQ;AACzF;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;AChCA;AAC8E;AACjB;AACA;AACoB;AAChB;AACjE,iBAAiB,0FAAsB;AACvC;AACA;AACA;AACA;AACO;AACP,aAAa;AACb,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA,QAAQ,iFAAuB;AAC/B;AACA;AACA;AACA,oCAAoC,kDAAkD;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mFAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C,sBAAsB,qBAAqB;AAC3C;AACA,iBAAiB,kBAAkB;AACnC,iBAAiB,kBAAkB;AACnC,iBAAiB,kBAAkB;AACnC,iBAAiB,kBAAkB;AACnC,SAAS;AACT;AACA;AACA,gCAAgC,2BAA2B;AAC3D,wCAAwC,iGAAiC;AACzE;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD,oCAAoC,iGAAiC;AACrE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,YAAY,oFAA0B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kGAAwC;AACxD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0FAAgC;AAChD;AACA;AACA,6BAA6B,sDAAsD;AACnF,8BAA8B,wDAAwD;AACtF;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C,uCAAuC,8EAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8EAAwB;AAC3D;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,8EAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8EAAwB;AAC3D;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,4BAA4B,kFAA2B;AACvD;AACA,4BAA4B,6EAAsB;AAClD;AACA,4CAA4C,mFAA4B;AACxE;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;AC/iBA;AACsD;AACa;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8EAAyB,CAAC,qEAAU;AAC5C;AACA;AACA;AACA,eAAe,2EAAsB,CAAC,qEAAU;AAChD;AACA;AACA,QAAQ,2EAAsB,0FAA0F,kEAAa;AACrI;AACA;AACA;AACO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzDP;AACoE;AACpB;AACD;AACY;AACY;AACpB;AACD;AAClD;AACqD;AACE;AAC+B;AACtF;AACwC;AACoB;AACH;AAChB;AACzC;AACkD;AAC2B;AACd;AACxD;AACP;AACA;AACA,UAAU,wDAAI;AACd,cAAc,4EAAc;AAC5B,iBAAiB,oEAAW;AAC5B,cAAc,gFAAe;AAC7B,aAAa,wDAAO;AACpB,cAAc,2DAAQ;AACtB,kBAAkB,+DAAY;AAC9B,UAAU,6DAAW;AACrB,kBAAkB,+FAAiB;AACnC,QAAQ,mDAAU;AAClB,gBAAgB,sEAAU;AAC1B,eAAe,mEAAS;AACxB,WAAW,mDAAK;AAChB,gBAAgB,4DAAU;AAC1B,WAAW,yEAAgB;AAC3B;AACA;AACA,QAAQ,qEAAoB;AAC5B;AACA,KAAK;AACL,iBAAiB;AACjB;AACA;AACA;AACA;AACA,gBAAgB,uEAAoB;AACpC;AACA;AACA;AACA;AACA,gBAAgB,+EAA8B;AAC9C,gBAAgB,uEAAoB;AACpC;AACA,KAAK;AACL;AACA,cAAc,gEAAU;AACxB,KAAK;AACL;AACA,eAAe,2FAAsB;AACrC,KAAK;AACL;AACA,mBAAmB,sEAAkB;;;;;;;;;;;;;;;;ACjEA;AAC9B;AACP,wBAAwB,2DAAiB;AACzC;;;;;;;;;;;;;;;;ACHwC;AACjC;AACP;AACA;AACA;AACA;AACA,UAAU,wDAAgB;AAC1B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,qBAAqB;AACrB;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;AChBA;AACyF;AACzF;AAC2D;AACE;AAC7D;AACmE;AACW;AACA;AACzB;AACrD,qBAAqB,6DAAQ;AAC7B,sBAAsB,6DAAQ;AACvB;AACP;AACA;AACA;AACA,QAAQ,0EAAwB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2FAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oEAAc;AAClD;AACA;AACA,oCAAoC,2EAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+EAAS;AACjB,QAAQ,+EAAS;AACjB,QAAQ,+EAAS;AACjB,QAAQ,+EAAS;AACjB;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;ACzHyF;AAC5B;AACF;AACD;AACoB;AACX;AACU;AACtE;AACP,eAAe,+DAAS;AACxB,gBAAgB,4DAAS;AACzB,oBAAoB,6DAAQ;AAC5B,oBAAoB,6DAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,QAAQ,kGAAgC;AACxC,KAAK;AACL;AACA,wBAAwB,2FAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+EAAS;AACjB,QAAQ,+EAAS;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB,2FAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+EAAS;AACrB;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACxIsD;AACT;AAC7C;AACA;AACA;AACA,eAAe,iEAAW;AAC1B;AACA,eAAe,iEAAW;AAC1B,gBAAgB,sEAAgB;AAChC;AACA;AACA;AACA,eAAe,iEAAW;AAC1B,gBAAgB,sEAAgB;AAChC;AACA;AACA;AACA,eAAe,iEAAW;AAC1B,gBAAgB,sEAAgB;AAChC;AACA;AACA;AACA,eAAe,iEAAW;AAC1B,gBAAgB,sEAAgB;AAChC;AACA;AACA;AACA;AACO;AACP;AACA,gBAAgB,iEAAW;AAC3B;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAe;AACvB;AACA;AACA,cAAc,0DAAU;AACxB;AACA;AACA,cAAc,6DAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA,kBAAkB,iEAAW;AAC7B,kBAAkB,sEAAgB;AAClC;AACA;AACA;AACA;AACA,uBAAuB,iEAAW;AAClC,wBAAwB,sEAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iEAAW;AAClC,wBAAwB,sEAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iEAAW;AAClC,wBAAwB,sEAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iEAAW;AAClC,wBAAwB,sEAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iEAAW;AAClC;AACA;AACA,wBAAwB,sEAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iEAAW;AAC7B,sBAAsB,sEAAgB;AACtC;AACA;AACA,YAAY,oEAAc;AAC1B;AACA;AACA;AACA;AACA,YAAY,iEAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChKsD;AAC/C;AACP;AACA,UAAU,iEAAW;AACrB;AACA;AACA,kBAAkB,iEAAW;AAC7B;AACA;AACA,uBAAuB,sEAAgB;AACvC;AACA;AACA,QAAQ,qEAAe;AACvB;AACA;AACA;AACA;AACA,kBAAkB,6DAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA,kBAAkB,iEAAW;AAC7B,kBAAkB,sEAAgB;AAClC;AACA,YAAY,2EAAqB;AACjC,uBAAuB,iEAAW;AAClC;AACA;AACA;AACA;AACA,uBAAuB,iEAAW;AAClC;AACA;AACA;AACA;AACA,uBAAuB,iEAAW;AAClC;AACA;AACA;AACA;AACA,uBAAuB,iEAAW;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,iEAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iEAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5FsE;AAC/D;AACP,IAAI,qFAAe;AACnB;AACA;AACA;AACA;AACA;AACA,aAAa,4FAAsB;AACnC;AACA,YAAY,6FAAuB;AACnC;AACA,mBAAmB,4FAAsB;AACzC;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,qFAAe;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4FAAsB;AACnC;AACA,mBAAmB,4FAAsB;AACzC;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,6BAA6B,8FAAwB;AACrD,4BAA4B,yGAAmC;AAC/D;AACA,oBAAoB,iGAA2B;AAC/C;AACA;AACA;AACA;AACA,gCAAgC,mHAA6C;AAC7E;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,6BAA6B,8FAAwB;AACrD,4BAA4B,yGAAmC;AAC/D;AACA,oBAAoB,iGAA2B;AAC/C;AACA;AACA;AACA;AACA,gCAAgC,mHAA6C;AAC7E;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,6BAA6B,8FAAwB;AACrD,4BAA4B,yGAAmC;AAC/D;AACA;AACA;AACA,gCAAgC,mHAA6C;AAC7E;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,6BAA6B,8FAAwB;AACrD,4BAA4B,yGAAmC;AAC/D;AACA,oBAAoB,iGAA2B;AAC/C;AACA;AACA;AACA;AACA,gCAAgC,mHAA6C;AAC7E;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,6BAA6B,8FAAwB;AACrD,4BAA4B,yGAAmC;AAC/D;AACA,oBAAoB,iGAA2B;AAC/C;AACA;AACA;AACA;AACA,gCAAgC,mHAA6C;AAC7E;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,6BAA6B,8FAAwB;AACrD,4BAA4B,yGAAmC;AAC/D;AACA,oBAAoB,iGAA2B;AAC/C;AACA;AACA;AACA;AACA,gCAAgC,mHAA6C;AAC7E;AACA;AACA;AACA;AACA;AACA,QAAQ,4FAAsB,CAAC,iGAA2B;AAC1D;AACA;AACA;;;;;;;;;;;;;;;;;ACxKsE;AAC/D;AACP;AACA;AACA;AACA;AACA;AACA,aAAa,4FAAsB;AACnC;AACA,mBAAmB,4FAAsB;AACzC;AACA;AACA,aAAa,uFAAiB;AAC9B;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,0GAAoC;AAC/D,oBAAoB,yFAAmB;AACvC;AACA,oBAAoB,4FACa,CAAC,2GAAqC;AACvE;AACA;AACA;AACA,sCAAsC,gGAA0B;AAChE;AACA;AACA,wBAAwB,4FAAsB,CAAC,oGAA8B;AAC7E;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4FAAsB;AACnC;AACA,mBAAmB,4FAAsB;AACzC;AACA;AACA,aAAa,uFAAiB;AAC9B;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C;AACA,oBAAoB,yGAAmC;AACvD;AACA;AACA;AACA,wBAAwB,mHAA6C;AACrE;AACA;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C;AACA,oBAAoB,yGAAmC;AACvD;AACA;AACA;AACA,wBAAwB,mHAA6C;AACrE;AACA;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C;AACA,oBAAoB,yGAAmC;AACvD;AACA;AACA;AACA,wBAAwB,mHAA6C;AACrE;AACA;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C;AACA,oBAAoB,yGAAmC;AACvD;AACA;AACA;AACA,wBAAwB,mHAA6C;AACrE;AACA;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C;AACA,oBAAoB,kHAA4C;AAChE;AACA;AACA;AACA,wBAAwB,mHAA6C;AACrE;AACA;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C;AACA,oBAAoB,yGAAmC;AACvD;AACA;AACA;AACA,wBAAwB,mHAA6C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4FAAsB,CAAC,iGAA2B;AAC1D;AACA;;;;;;;;;;;;;;;;;;;;ACrKA;AACoE;AACI;AACoB;AACxB;AACE;AACtE;AACA;AACA,kBAAkB,mFAA2B;AAC7C;AACA,kBAAkB,mFAA2B;AAC7C;AACA;AACA;AACO;AACP,IAAI,qFAAe;AACnB;AACA,SAAS,kFAAwB;AACjC;AACA;AACA;AACA,IAAI,gGAA0B;AAC9B,kBAAkB,iGAAuC;AACzD,kBAAkB,iGAAuC;AACzD;AACA,sBAAsB,UAAU,mFAA2B,EAAE;AAC7D,0BAA0B,UAAU,mFAA2B,EAAE;AACjE,iCAAiC,KAAK,+EAAuB,EAAE;AAC/D,qBAAqB,4FAAsB;AAC3C;AACA,0BAA0B,4FAAsB;AAChD;AACA;AACA,gBAAgB,4FAAsB,CAAC,uFAAiB;AACxD;AACA;AACA;AACA;AACA,sBAAsB,UAAU,mFAA2B,EAAE;AAC7D,0BAA0B,UAAU,mFAA2B,EAAE;AACjE,iCAAiC,aAAa;AAC9C,qBAAqB,4FAAsB;AAC3C;AACA,0BAA0B,4FAAsB;AAChD,6BAA6B,uFAAiB;AAC9C;AACA;AACA,gCAAgC,2FAAoB;AACpD;AACA;AACA;AACA,wBAAwB,4FAAsB;AAC9C,mCAAmC,4FAAsB;AACzD,uCAAuC,uFAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4FAAsB;AACnC;AACA,mBAAmB,4FAAsB;AACzC;AACA;AACA,qBAAqB,uFAAiB;AACtC;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,0GAAoC;AAC/D,oBAAoB,yFAAmB;AACvC;AACA,oBAAoB,4FACa,CAAC,2GAAqC;AACvE;AACA;AACA;AACA,sCAAsC,gGAA0B;AAChE;AACA;AACA,wBAAwB,4FAAsB,CAAC,oGAA8B;AAC7E;AACA;AACA;AACA;AACA,YAAY,4FAAsB;AAClC,uBAAuB,4FAAsB;AAC7C,2BAA2B,sGAAgC;AAC3D;AACA,gBAAgB,4FAAsB,CAAC,oGAA8B;AACrE;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrIA;AAC2D;AACE;AACtD;AACP,eAAe,+DAAS;AACxB;AACA,oBAAoB,6DAAQ;AAC5B,oBAAoB,6DAAQ;AAC5B;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;ACZ6E;AACA;AACV;AACP;AACA;AACO;AAC5D;AACP;AACA;AACA,YAAY,yFAA6B;AACzC,SAAS;AACT,KAAK;AACL;AACA;AACA,kBAAkB,yEAAU;AAC5B,SAAS;AACT;AACA,kBAAkB,yEAAU;AAC5B,SAAS;AACT,KAAK;AACL;AACA;AACA,YAAY,gFAAW;AACvB,SAAS;AACT,KAAK;AACL;AACA;AACA,YAAY,+EAAS;AACrB,SAAS;AACT;AACA,YAAY,+EAAS;AACrB,SAAS;AACT,KAAK;AACL;AACA;AACA,YAAY,+EAAS;AACrB,SAAS;AACT;AACA,YAAY,+EAAS;AACrB,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;ACzC+D;AACiB;AACrB;AAC8B;AAC/B;AACR;AACiC;AACnF,qBAAqB,6DAAQ;AAC7B,sBAAsB,6DAAQ;AAC9B,sBAAsB,4DAAS;AAC/B;AACA;AACA,gBAAgB,6FAAmB;AACnC,gBAAgB,6FAAmB;AACnC;AACA;AACA,oBAAoB,2FAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kBAAkB,iFAAmC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mFAAS;AACjB;AACA;AACA,kBAAkB,gFAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oFAAU;AAClB,YAAY,6FAAmB;AAC/B;AACA,YAAY,+EAAsB;AAClC;AACA;AACA,YAAY,6FAAmB;AAC/B,YAAY,+EAAsB;AAClC;AACA,YAAY,6FAAmB;AAC/B,YAAY,+EAAsB;AAClC;AACA;AACA,IAAI,yFAAwB;AAC5B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,kBAAkB,iFAAmC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6FAAmB;AACnC,gBAAgB,6FAAmB;AACnC,mBAAmB,oFAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+EAAsB;AACtC;AACA;AACA;AACA;AACA;AACA,gBAAgB,+EAAsB;AACtC;AACA;AACA;AACA;AACA,QAAQ,oFAAU;AAClB;AACA;AACA;AACA,YAAY,+EAAsB;AAClC;AACA;AACA,YAAY,+EAAsB;AAClC;AACA;AACA,QAAQ,mFAAS;AACjB;AACA;AACA,YAAY,gFAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACnIsF;AAC5B;AAClB;AACqC;AACX;AACU;AAC3B;AACjD,sBAAsB,iFAAa;AAC5B;AACP;AACA,sBAAsB,gEAAwB;AAC9C,YAAY,yGAA2C;AACvD,YAAY,+FAAiC,CAAC,yFAA2B;AACzE,SAAS;AACT,KAAK;AACL;AACA;AACA,mBAAmB,gEAAwB,CAAC,sGAA2B;AACvE;AACA;AACA;AACA;AACA,gBAAgB,sFAAwB;AACxC,aAAa;AACb;AACA;AACA,sBAAsB,qFAAuB;AAC7C,aAAa;AACb,SAAS;AACT,gBAAgB,gEAAwB,CAAC,uGAA4B;AACrE,2BAA2B,kFAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sFAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT,KAAK;AACL;AACA,eAAe,gEAAwB,CAAC,uGAA4B;AACpE,kBAAkB,0EAAe;AACjC;AACA;AACA,SAAS;AACT,eAAe,gEAAwB,CAAC,sGAA2B;AACnE,kBAAkB,yEAAc;AAChC;AACA;AACA,SAAS;AACT,KAAK;AACL,eAAe,gEAAwB,CAAC,qGAA0B;AAClE,cAAc,6FAA+B,CAAC,+EAAiC;AAC/E,KAAK;AACL,cAAc,gEAAwB,CAAC,oGAAyB;AAChE,QAAQ,sFAAwB;AAChC,YAAY,2FAA6B,CAAC,8EAAgC;AAC1E;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,kBAAkB,gEAAwB,CAAC,oGAAyB;AACpE;AACA;AACA,YAAY,sFAAwB;AACpC,gBAAgB,oFAAsB;AACtC,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA,qBAAqB,gEAAwB,CAAC,+GAAoC;AAClF,kBAAkB,0FAA4B;AAC9C;AACA;AACA,SAAS;AACT,gBAAgB,gEAAwB,CAAC,0GAA+B;AACxE,kBAAkB,qFAAuB;AACzC;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,gBAAgB,gEAAwB,CAAC,sGAA2B;AACpE,0BAA0B,+EAAiC;AAC3D;AACA,kBAAkB,0FAA4B;AAC9C;AACA,SAAS;AACT,gBAAgB,gEAAwB,CAAC,sGAA2B;AACpE,0BAA0B,+EAAiC;AAC3D;AACA,kBAAkB,0FAA4B;AAC9C;AACA,SAAS;AACT,KAAK;AACL;AACA,gBAAgB,gEAAwB,CAAC,0GAA+B;AACxE,0BAA0B,gFAAkC;AAC5D;AACA;AACA;AACA,YAAY,yFAA2B;AACvC;AACA,SAAS;AACT,gBAAgB,gEAAwB,CAAC,0GAA+B;AACxE,0BAA0B,gFAAkC;AAC5D;AACA;AACA;AACA,YAAY,yFAA2B;AACvC;AACA,SAAS;AACT,KAAK;AACL;AACA,gBAAgB,gEAAwB,CAAC,0GAA+B;AACxE,0BAA0B,gFAAkC;AAC5D;AACA;AACA;AACA,YAAY,yFAA2B;AACvC;AACA,SAAS;AACT,gBAAgB,gEAAwB,CAAC,0GAA+B;AACxE,0BAA0B,gFAAkC;AAC5D;AACA;AACA;AACA,YAAY,yFAA2B;AACvC;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;ACpJO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;ACzB8G;AACvC;AAC/B;AAC8C;AACxB;AACI;AACH;AACa;AACd;AAC9D,sBAAsB,iFAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA,QAAQ,oFAA0B;AAClC;AACA;AACA;AACA,QAAQ,qFAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qFAAuB;AACnC;AACA;AACA;AACA;AACA;AACA,yBAAyB,wFAAgC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wFAAgC;AACzD;AACA,0BAA0B,mFAA2B;AACrD;AACA,0BAA0B,mFAA2B;AACrD;AACA,0BAA0B,mFAA2B;AACrD,oBAAoB,kGAA2B;AAC/C;AACA,2CAA2C,2FAAoB,YAAY,2FAAoB,YAAY,2FAAoB;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8HAAuC;AACtE;AACA;AACA;AACA;AACA;AACA,YAAY,+EAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mEAAU;AAC/B,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mEAAU;AAC/B,SAAS;AACT;AACA;AACA,qBAAqB,mEAAU;AAC/B,6BAA6B,mEAAU;AACvC,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB,mEAAU;AAC3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;AC3LwC;AACqB;AAC7D,mBAAmB,yDAAiB;AACpC;AACA;AACA;AACA;AACA,IAAI,oFAAsB;AAC1B,CAAC;AACD;AACA;AACA,IAAI,+EAAiB;AACrB,CAAC;AACD;AACA,IAAI,0EAAY;AAChB,CAAC;AACD;AACA,CAAC;AACM;;;;;;;;;;;;;;;;AClBiC;AACxC,kBAAkB,6DAAqB,YAAY;AAC5C;;;;;;;;;;;;;;;;;;;ACF+E;AAChC;AACI;AACS;AAC5D;AACP,qBAAqB,8DAAU,KAAK,4DAAS;AAC7C;AACA;AACA;AACA,gBAAgB,wGAA6B;AAC7C;AACA;AACA;AACA;AACA,YAAY,iFAAwB;AACpC;AACA,SAAS;AACT,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;ACnB2D;AACS;AACsB;AACpC;AAC/C;AACP,yBAAyB,6DAAQ;AACjC;AACA;AACA,mBAAmB,kFAAqB;AACxC,SAAS;AACT;AACA,mBAAmB,wGAA0B;AAC7C,SAAS;AACT;AACA,WAAW,8DAAU;AACrB;;;;;;;;;;;;;;;;;;;ACf0D;AAClB;AACyB;AACc;AAC/E,kBAAkB,4DAAS;AAC3B;AACA,sBAAsB,iFAAa;AAC5B;AACP;AACA;AACA;AACA,sBAAsB,UAAU,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE;AAC/C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,yBAAyB,6FAAqC;AAC9D,yBAAyB,wFAAgC;AACzD;AACA;AACA,8BAA8B,0DAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC5EA;AAC8D;AAC0B;AACtB;AAC3D;AACP;AACA,cAAc,2EAAgB;AAC9B,iBAAiB,mEAAW;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2FAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA,gBAAgB,kGAAuC;AACvD;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,sBAAsB,iGAAmB;AACzC;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;ACnCkD;AACX;AACc;AACH;AACE;AACF;;;;;;;;;;;;;;;;ACL3C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACfA;AACwC;AACiB;AACe;AACX;AACiB;AACvB;AACqB;AAClB;AACT;AACC;AAC4B;AACvE;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kBAAkB,6DAAqB,CAAC,6FAA0B;AAClE,QAAQ,sFAAkC;AAC1C,KAAK;AACL,eAAe,6DAAqB,CAAC,0FAAuB;AAC5D,QAAQ,gEAAe;AACvB,QAAQ,+DAAc;AACtB;AACA,KAAK;AACL,eAAe,6DAAqB,CAAC,0FAAuB;AAC5D,WAAW,6DAAqB,CAAC,sFAAmB;AACpD,YAAY,6DAAqB,CAAC,uFAAoB;AACtD,YAAY,6DAAqB,CAAC,uFAAoB;AACtD,kBAAkB,6DAAqB,CAAC,6FAA0B;AAClE,eAAe,6DAAqB,CAAC,0FAAuB;AAC5D,gBAAgB,6DAAqB,CAAC,2FAAwB;AAC9D,gBAAgB,6DAAqB,CAAC,2FAAwB;AAC9D,eAAe,6DAAqB,CAAC,kGAA+B;AACpE,QAAQ,oFAAiC;AACzC,KAAK;AACL;AACA;AACA,IAAI,yGAAoC;AACxC,CAAC;AACD;AACA,IAAI,4EAAuB;AAC3B,CAAC;AACD;AACA,IAAI,+EAA0B;AAC9B,CAAC;AACD;AACA,IAAI,6EAAwB;AAC5B,CAAC;AACD;AACA,IAAI,gFAA2B;AAC/B,CAAC;AACD;AACA,IAAI,6EAAwB;AAC5B,CAAC;AACD;AACA,IAAI,gFAA2B;AAC/B,CAAC;AACD;AACA,IAAI,4FAAwB;AAC5B,CAAC;AACD;AACA,IAAI,sEAAe;AACnB,CAAC;AACD;AACA,IAAI,yEAAgB;AACpB,CAAC;AACD;AACA,IAAI,yEAAgB;AACpB,IAAI,+EAAsB;AAC1B,CAAC;;;;;;;;;;;;;;;AC9ED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;AC1LO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACPO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;AC7BO;AACP;AACA;AACA;AACA;AACA;AACA,kBAAkB,EAAE,GAAG,EAAE,GAAG,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5BwD;AACQ;AACE;AACI;AACF;AAC7D,wBAAwB,4EAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6DAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2FAAkC;AACzD;AACA;AACA,mBAAmB,2FAAkC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iFAAwB;AAChC;AACA;AACA;AACA,QAAQ,iFAAwB;AAChC;AACA;AACA;AACA,QAAQ,oFAA0B;AAClC;AACA;AACA;AACA,QAAQ,qFAA2B;AACnC;AACA;AACA;;;;;;;UC/FA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;;;;WClCA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;WACA;WACA,IAAI;WACJ;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,CAAC;WACD;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;WACA,sGAAsG;WACtG;WACA;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA,EAAE;WACF;WACA;;;;;WChEA;WACA;WACA;WACA;WACA,+BAA+B,wCAAwC;WACvE;WACA;WACA;WACA;WACA,iBAAiB,qBAAqB;WACtC;WACA;WACA,kBAAkB,qBAAqB;WACvC;WACA;WACA,KAAK;WACL;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WC3BA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;;;;;WCRA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WCfA;;WAEA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,aAAa;WACb;WACA;WACA;WACA;;WAEA;WACA;WACA;;WAEA;;WAEA;;;;;WCpCA;WACA;WACA;WACA;;;;;UEHA;UACA","sources":["webpack://dve-testing/./compiled/client/Constructor/constructor.js","webpack://dve-testing/./compiled/core/data/client/Voxels/LightDebugBox.js","webpack://dve-testing/./compiled/core/data/client/Voxels/LiquidDreamEther.js","webpack://dve-testing/./compiled/core/data/client/Voxels/MarkerBox.js","webpack://dve-testing/./compiled/core/data/client/functions/RegisterVoxelConstructors.js","webpack://dve-testing/./compiled/core/gen/Dimensions/Main/MainWorldGen.js","webpack://dve-testing/./compiled/core/gen/Functions/Circle.js","webpack://dve-testing/./compiled/core/gen/Functions/StairPillar.js","webpack://dve-testing/./compiled/core/gen/Functions/StairRoof.js","webpack://dve-testing/./compiled/core/gen/Functions/Tree.js","webpack://dve-testing/./compiled/core/gen/Structures/Temples/DimensoinTemple.js","webpack://dve-testing/./compiled/core/gen/WorldGenerator.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/IndexedRNG/index.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/index.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/perlin/index.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/random/Algorithms/Base.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/random/Algorithms/Mulberry32.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/random/Algorithms/Sfc32.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/random/Algorithms/Xoshiro128ss.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/random/Rand.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/random/helpers.js","webpack://dve-testing/../../DSLIBS/divineRNG/dist/random/index.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Common/Threads/Contracts/ConstructorRemoteThreadTasks.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Common/Threads/Contracts/ConstructorTasks.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Analyzer/Analyzer.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Analyzer/AnalyzerProcessor.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Analyzer/AnalyzerUpdater.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Builder.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Constructors/Voxel/VoxelConstructors.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Constructors/Voxel/classes/Box.constructor.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Constructors/Voxel/classes/Liquid.constructor.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Constructors/Voxel/classes/Panel.constructor.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Geometry/GeometryBuilder.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Geometry/Quad/QuadBuilder.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Geometry/Quad/QuadUVs.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Init/InitBuilder.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Mesher/ChunkMesher.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Processor/Functions/CalculateFlow.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Processor/Functions/CalculateVoxelLight.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Processor/Processor.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Rules/Overrides/OverridesManager.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Rules/SubstanceRules.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Shapes/ShapeManager.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Shapes/default/Box/Box.voxel.shape.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Shapes/default/Box/HalfBox.voxel.shape.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Shapes/default/Liquid/Liquid.voxel.shape.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Shapes/default/Panel/CrossedPanels.voxel.shape.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Shapes/default/Panel/Panel.voxel.shape.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Shapes/default/RegisterDefaultShapes.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Shapes/default/Stair/Stair.overrides.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Shapes/default/Stair/Stair.voxel.shape.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Shapes/default/Stair/StairData.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Textures/TextureManager.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Tools/VoxelMesher.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Builder/Tools/VoxelTemplater.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/DivineVoxelEngineConstructor.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Hooks/ConstructorHooks.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Init/InitWorker.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Propagation/Explosion/ExplosionManager.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Propagation/Flow/FlowManager.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Propagation/Flow/Functions/FlowRemove.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Propagation/Flow/Functions/FlowUpdate.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Propagation/Illumanation/Functions/RGBUpdate.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Propagation/Illumanation/Functions/SunUpdate.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Propagation/Illumanation/Functions/WorldSun.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Propagation/Illumanation/IlluminationManager.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Propagation/Propagation.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Tasks/Functions/VoxelUpdate.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Tasks/Tasks.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Tasks/TasksQueue.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Tasks/TasksRequest.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Threads/Parent/ParentComm.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Threads/World/WorldComm.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Tools/Brush/ConstructorBrush.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/Tools/Data/ConstructorDataTool.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/WorldGeneration/Register/WorldGenRegister.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/WorldGeneration/WorldGeneration.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Constructor/index.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Constants/Util/Faces.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/DataSyncNode.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Meshing/FaceByte.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Meshing/MeshFaceDataBytes.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Data/Shapes/StairStates.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Global/Util/VisistedMap.js","webpack://dve-testing/../../DSLIBS/divineVoxelEngine/dist/Tools/Brush/Brush.js","webpack://dve-testing/webpack/bootstrap","webpack://dve-testing/webpack/runtime/async module","webpack://dve-testing/webpack/runtime/chunk loaded","webpack://dve-testing/webpack/runtime/define property getters","webpack://dve-testing/webpack/runtime/ensure chunk","webpack://dve-testing/webpack/runtime/get javascript chunk filename","webpack://dve-testing/webpack/runtime/global","webpack://dve-testing/webpack/runtime/hasOwnProperty shorthand","webpack://dve-testing/webpack/runtime/make namespace object","webpack://dve-testing/webpack/runtime/publicPath","webpack://dve-testing/webpack/runtime/importScripts chunk loading","webpack://dve-testing/webpack/runtime/startup chunk dependencies","webpack://dve-testing/webpack/before-startup","webpack://dve-testing/webpack/startup","webpack://dve-testing/webpack/after-startup"],"sourcesContent":["import { $RegisterVoxelConstructors } from \"../../core/data/client/functions/RegisterVoxelConstructors.js\";\r\nimport { DVEC } from \"divine-voxel-engine/Constructor\";\r\nimport { WorldGenerator } from \"../../core/gen/WorldGenerator\";\r\n$RegisterVoxelConstructors(DVEC);\r\nDVEC.worldGen.setWorldGen(WorldGenerator);\r\nawait DVEC.$INIT();\r\n","const getData = (dataTool, x, y, z) => {\r\n    let data = 0;\r\n    if (dataTool.loadInAt(x, y, z)) {\r\n        data = dataTool.getLight();\r\n    }\r\n    return data;\r\n};\r\nexport function GetLightDebugBox(DVEC) {\r\n    const textures = [];\r\n    DVEC.hooks.texturesRegistered.addToRun((textureMangager) => {\r\n        for (let i = 0; i < 16; i++) {\r\n            textures.push(textureMangager.getTextureUV([\r\n                \"#dve_solid\",\r\n                \"dve_light_debug\",\r\n                `light-level-${i}`,\r\n            ]));\r\n        }\r\n    });\r\n    return DVEC.voxelManager.registerVoxel({\r\n        id: \"dve_light_debug\",\r\n        process(templater) {\r\n            const [dimension, x, y, z] = templater.currentVoxel.getLocation();\r\n            const dt = templater.utilDataTool;\r\n            if (templater.isFaceExpposed(\"top\")) {\r\n                templater\r\n                    .addUV(textures[getData(dt, x, y + 1, z) || 0])\r\n                    .addOverlayUVs([0]);\r\n            }\r\n            if (templater.isFaceExpposed(\"bottom\")) {\r\n                templater\r\n                    .addUV(textures[getData(dt, x, y - 1, z) || 0])\r\n                    .addOverlayUVs([0]);\r\n            }\r\n            if (templater.isFaceExpposed(\"east\")) {\r\n                templater\r\n                    .addUV(textures[getData(dt, x + 1, y, z) || 0])\r\n                    .addOverlayUVs([0]);\r\n            }\r\n            if (templater.isFaceExpposed(\"west\")) {\r\n                templater\r\n                    .addUV(textures[getData(dt, x - 1, y, z) || 0])\r\n                    .addOverlayUVs([0]);\r\n            }\r\n            if (templater.isFaceExpposed(\"south\")) {\r\n                templater\r\n                    .addUV(textures[getData(dt, x, y, z - 1) || 0])\r\n                    .addOverlayUVs([0]);\r\n            }\r\n            if (templater.isFaceExpposed(\"north\")) {\r\n                templater\r\n                    .addUV(textures[getData(dt, x, y, z + 1) || 0])\r\n                    .addOverlayUVs([0]);\r\n            }\r\n            templater.processVoxelLight();\r\n        },\r\n    });\r\n}\r\n","const checkSets = {\r\n    north: [\r\n        [0, 1],\r\n        [1, 1],\r\n        [-1, 1],\r\n    ],\r\n    south: [\r\n        [0, -1],\r\n        [1, -1],\r\n        [-1, -1],\r\n    ],\r\n    east: [\r\n        [1, 0],\r\n        [1, -1],\r\n        [1, 1],\r\n    ],\r\n    west: [\r\n        [-1, 0],\r\n        [-1, -1],\r\n        [-1, 1],\r\n    ],\r\n};\r\nconst overlayTextures = [];\r\nconst uvsSets = {\r\n    north: {\r\n        \"0|\": 0,\r\n        \"1|0|1|\": 1,\r\n        \"1|1|0|\": 2,\r\n        \"1|0|0|\": 3,\r\n    },\r\n    south: {\r\n        \"0|\": 4,\r\n        \"1|0|1|\": 5,\r\n        \"1|1|0|\": 6,\r\n        \"1|0|0|\": 7,\r\n    },\r\n    east: {\r\n        \"0|\": 8,\r\n    },\r\n    west: {\r\n        \"0|\": 9,\r\n    },\r\n};\r\nconst getUV = (direction, x, y, z, data) => {\r\n    let key = \"\";\r\n    const sets = checkSets[direction];\r\n    for (let i = 0; i < sets.length; i++) {\r\n        if (i > 0 && (direction == \"west\" || direction == \"east\"))\r\n            break;\r\n        const set = sets[i];\r\n        const cx = x + set[0];\r\n        const cz = z + set[1];\r\n        const check = data.isSameVoxel(cx, y, cz);\r\n        if (check) {\r\n            key += \"1|\";\r\n        }\r\n        else {\r\n            key += \"0|\";\r\n            if (i == 0)\r\n                break;\r\n        }\r\n    }\r\n    if (uvsSets[direction][key] == undefined)\r\n        return 0;\r\n    const index = uvsSets[direction][key];\r\n    return overlayTextures[index];\r\n};\r\nlet uv = 0;\r\nexport function GetDreamEther(DVEC) {\r\n    DVEC.hooks.texturesRegistered.addToRun((textureManager) => {\r\n        uv = textureManager.getTextureUV([\"#dve_liquid\", \"dve_liquid_dream_ether\", \"still-1\"]);\r\n        overlayTextures.push(textureManager.getTextureUV([\"#dve_liquid\", \"foam\", \"top\"], true), textureManager.getTextureUV([\"#dve_liquid\", \"foam\", \"ctr\"], true), textureManager.getTextureUV([\"#dve_liquid\", \"foam\", \"ctl\"], true), textureManager.getTextureUV([\"#dve_liquid\", \"foam\", \"ctltr\"], true), textureManager.getTextureUV([\"#dve_liquid\", \"foam\", \"bottom\"], true), textureManager.getTextureUV([\"#dve_liquid\", \"foam\", \"cbr\"], true), textureManager.getTextureUV([\"#dve_liquid\", \"foam\", \"cbl\"], true), textureManager.getTextureUV([\"#dve_liquid\", \"foam\", \"cblbr\"], true), textureManager.getTextureUV([\"#dve_liquid\", \"foam\", \"right\"], true), textureManager.getTextureUV([\"#dve_liquid\", \"foam\", \"left\"], true));\r\n    });\r\n    DVEC.voxelManager.registerVoxel({\r\n        id: \"dve_liquid_dream_ether\",\r\n        process(templater) {\r\n            if (templater.isFaceExpposed(\"top\")) {\r\n                templater.addUV(uv);\r\n                if (templater.currentVoxel.getLevel() == 15 &&\r\n                    templater.currentVoxel.getLevelState() != 1) {\r\n                    const x = templater.currentVoxel.x;\r\n                    const y = templater.currentVoxel.y;\r\n                    const z = templater.currentVoxel.z;\r\n                    templater.addOverlayUVs([\r\n                        getUV(\"north\", x, y, z, templater.currentVoxel),\r\n                        getUV(\"south\", x, y, z, templater.currentVoxel),\r\n                        getUV(\"east\", x, y, z, templater.currentVoxel),\r\n                        getUV(\"west\", x, y, z, templater.currentVoxel),\r\n                    ]);\r\n                }\r\n                else {\r\n                    templater.addOverlayUVs([0]);\r\n                }\r\n            }\r\n            if (templater.isFaceExpposed(\"bottom\")) {\r\n                templater.addUV(uv).addOverlayUVs([0]);\r\n            }\r\n            if (templater.isFaceExpposed(\"east\")) {\r\n                templater.addUV(uv).addOverlayUVs([0]);\r\n            }\r\n            if (templater.isFaceExpposed(\"west\")) {\r\n                templater.addUV(uv).addOverlayUVs([0]);\r\n            }\r\n            if (templater.isFaceExpposed(\"south\")) {\r\n                templater.addUV(uv).addOverlayUVs([0]);\r\n            }\r\n            if (templater.isFaceExpposed(\"north\")) {\r\n                templater.addUV(uv).addOverlayUVs([0]);\r\n            }\r\n            templater.processVoxelLight(true);\r\n        },\r\n    });\r\n}\r\n","export function GetMarkerBox(DVEC) {\r\n    const textures = [];\r\n    DVEC.hooks.texturesRegistered.addToRun((textureMangager) => {\r\n        for (let i = 0; i < 16; i++) {\r\n            textures.push(textureMangager.getTextureUV([\"#dve_solid\", \"dve_light_debug\", `light-level-${i}`]));\r\n        }\r\n    });\r\n    return DVEC.voxelManager.registerVoxel({\r\n        id: \"dve_marker_box\",\r\n        process(templater) {\r\n            const uv = textures[templater.currentVoxel.getState()];\r\n            if (templater.isFaceExpposed(\"top\")) {\r\n                templater.addUV(textures[uv]).addOverlayUVs([0]);\r\n            }\r\n            if (templater.isFaceExpposed(\"bottom\")) {\r\n                templater.addUV(textures[uv]).addOverlayUVs([0]);\r\n            }\r\n            if (templater.isFaceExpposed(\"east\")) {\r\n                templater.addUV(textures[uv]).addOverlayUVs([0]);\r\n            }\r\n            if (templater.isFaceExpposed(\"west\")) {\r\n                templater.addUV(textures[uv]).addOverlayUVs([0]);\r\n            }\r\n            if (templater.isFaceExpposed(\"south\")) {\r\n                templater.addUV(textures[uv]).addOverlayUVs([0]);\r\n            }\r\n            if (templater.isFaceExpposed(\"north\")) {\r\n                templater.addUV(textures[uv]).addOverlayUVs([0]);\r\n            }\r\n            templater.processVoxelLight();\r\n        },\r\n    });\r\n}\r\n","//types\r\n//voxels\r\nimport { GetLightDebugBox } from \"../Voxels/LightDebugBox\";\r\nimport { GetMarkerBox } from \"../Voxels/MarkerBox\";\r\nimport { GetDreamEther } from \"../Voxels/LiquidDreamEther\";\r\nexport function $RegisterVoxelConstructors(DVEC, voxels = []) {\r\n    GetLightDebugBox(DVEC);\r\n    GetMarkerBox(DVEC);\r\n    GetDreamEther(DVEC);\r\n    const vm = DVEC.voxelManager;\r\n    vm.registerVoxel([\r\n        //debug\r\n        vm.defaults.box.simple(\"dve_debug_box\", {\r\n            top: [\"#dve_solid\", \"dve_debug_box\", \"top\"],\r\n            bottom: [\"#dve_solid\", \"dve_debug_box\", \"bottom\"],\r\n            north: [\"#dve_solid\", \"dve_debug_box\", \"north\"],\r\n            south: [\"#dve_solid\", \"dve_debug_box\", \"south\"],\r\n            east: [\"#dve_solid\", \"dve_debug_box\", \"east\"],\r\n            west: [\"#dve_solid\", \"dve_debug_box\", \"west\"],\r\n        }),\r\n        vm.defaults.box.simple(\"dve_data_holder\", [\r\n            \"#dve_solid\",\r\n            \"dve_data_holder\",\r\n            \"front\",\r\n        ]),\r\n        //dream\r\n        vm.defaults.box.simple(\"dve_dream_grass_block\", [\r\n            \"#dve_flora\",\r\n            \"dve_dream_grass_block\",\r\n            \"grassy-top\",\r\n        ]),\r\n        vm.defaults.box.pillar(\"dve_dream_stone_pillar\", {\r\n            top: [\"#dve_solid\", \"dve_dream_stone_pillar\", \"top\"],\r\n            bottom: [\"#dve_solid\", \"dve_dream_stone_pillar\", \"top\"],\r\n            sideBottom: [\"#dve_solid\", \"dve_dream_stone_pillar\", \"side-bottom\"],\r\n            sideMiddle: [\"#dve_solid\", \"dve_dream_stone_pillar\"],\r\n            sideTop: [\"#dve_solid\", \"dve_dream_stone_pillar\", \"side-top\"],\r\n            sideFloat: [\"#dve_solid\", \"dve_dream_stone_pillar\", \"top\"],\r\n        }),\r\n        vm.defaults.box.pillar(\"dve_dream_stone\", {\r\n            top: [\"#dve_solid\", \"dve_dream_stone\", \"grassy-top\"],\r\n            bottom: [\"#dve_solid\", \"dve_dream_stone\"],\r\n            sideBottom: [\"#dve_solid\", \"dve_dream_stone\"],\r\n            sideMiddle: [\"#dve_solid\", \"dve_dream_stone\"],\r\n            sideTop: [\"#dve_solid\", \"dve_dream_stone\", \"grassy-side\"],\r\n            sideFloat: [\"#dve_solid\", \"dve_dream_stone\", \"grassy-side\"],\r\n        }),\r\n        vm.defaults.box.simple(\"dve_dream_lamp\", [\"#dve_solid\", \"dve_dream_lamp\"]),\r\n        vm.defaults.box.pillar(\"dve_dream_stone_slab\", {\r\n            top: [\"#dve_solid\", \"dve_dream_stone\", \"grassy-top\"],\r\n            bottom: [\"#dve_solid\", \"dve_dream_stone\"],\r\n            sideBottom: [\"#dve_solid\", \"dve_dream_stone\"],\r\n            sideMiddle: [\"#dve_solid\", \"dve_dream_stone\"],\r\n            sideTop: [\"#dve_solid\", \"dve_dream_stone\", \"grassy-side\"],\r\n            sideFloat: [\"#dve_solid\", \"dve_dream_stone\", \"grassy-side\"],\r\n        }),\r\n        vm.defaults.box.simple(\"dve_dream_log\", [\"#dve_solid\", \"dve_dream_log\"]),\r\n        vm.defaults.box.simple(\"dve_dream_stone_stair\", [\r\n            \"#dve_solid\",\r\n            \"dve_dream_stone\",\r\n        ]),\r\n        vm.defaults.panel.simple(\"dve_dream_grass\", [\r\n            \"#dve_flora\",\r\n            \"dve_dream_grass\",\r\n        ]),\r\n        vm.defaults.panel.simple(\"dve_dream_vine\", [\r\n            \"#dve_flora\",\r\n            \"dve_dream_vine\",\r\n        ]),\r\n        vm.defaults.box.simple(\"dve_dream_leaves\", [\r\n            \"#dve_flora\",\r\n            \"dve_dream_leaves\",\r\n        ]),\r\n        //dread\r\n        vm.defaults.box.pillar(\"dve_dread_stone_pillar\", {\r\n            top: [\"#dve_solid\", \"dve_dread_stone_pillar\", \"top\"],\r\n            bottom: [\"#dve_solid\", \"dve_dread_stone_pillar\", \"top\"],\r\n            sideBottom: [\"#dve_solid\", \"dve_dread_stone_pillar\", \"side-bottom\"],\r\n            sideMiddle: [\"#dve_solid\", \"dve_dread_stone_pillar\"],\r\n            sideTop: [\"#dve_solid\", \"dve_dread_stone_pillar\", \"side-top\"],\r\n            sideFloat: [\"#dve_solid\", \"dve_dread_stone_pillar\", \"top\"],\r\n        }),\r\n        vm.defaults.box.pillar(\"dve_dread_stone\", {\r\n            top: [\"#dve_solid\", \"dve_dread_stone\", \"grassy-top\"],\r\n            bottom: [\"#dve_solid\", \"dve_dread_stone\"],\r\n            sideBottom: [\"#dve_solid\", \"dve_dread_stone\"],\r\n            sideMiddle: [\"#dve_solid\", \"dve_dread_stone\"],\r\n            sideTop: [\"#dve_solid\", \"dve_dread_stone\", \"grassy-side\"],\r\n            sideFloat: [\"#dve_solid\", \"dve_dread_stone\", \"grassy-side\"],\r\n        }),\r\n        vm.defaults.box.simple(\"dve_dread_lamp\", [\"#dve_solid\", \"dve_dread_lamp\"]),\r\n        vm.defaults.liquid.simple(\"dve_liquid_dread_ether\", [\r\n            [\"#dve_liquid\", \"dve_liquid_dread_ether\", \"still-1\"],\r\n            [\"#dve_liquid\", \"dve_liquid_dread_ether\", \"still-1\"],\r\n        ]),\r\n        vm.defaults.panel.simple(\"dve_dread_grass\", [\r\n            \"#dve_flora\",\r\n            \"dve_dread_grass\",\r\n        ]),\r\n    ]);\r\n}\r\n","import { DVEC } from \"divine-voxel-engine/Constructor\";\r\nimport { VoxelMath } from \"divine-voxel-engine/Math\";\r\nimport { PerlinNoise3d } from \"divine-rng\";\r\nimport { IndexedRNG } from \"divine-rng\";\r\nimport { GenerateDimensionTemple } from \"../../Structures/Temples/DimensoinTemple.js\";\r\nimport { GenerateTree } from \"../../Functions/Tree.js\";\r\nconst perlin = new PerlinNoise3d();\r\nconst perlin2 = new PerlinNoise3d();\r\nconst bioneNoise = new PerlinNoise3d();\r\n/*\r\nperlin.noiseSeed(12341234);\r\nperlin2.noiseSeed(989989989);\r\nbioneNoise.noiseSeed(59695022384);\r\n*/\r\nconst indexRNG = new IndexedRNG(2934782394782372);\r\nperlin.noiseSeed(2934782394782372);\r\nperlin2.noiseSeed(89898778990878798);\r\nbioneNoise.noiseSeed(7890878787788789987);\r\nconst waveLength = 100;\r\nconst xOffSet = 1_000;\r\nconst zOffSet = 1_000;\r\nconst brush = DVEC.worldGen.getBrush();\r\nconst dataTool = brush._dt;\r\nconst elysianDimensionVoxels = {\r\n    stone: \"ecd_elysian_stone\",\r\n    grass: \"ecd_elysian_grass\",\r\n    water: \"ecd_elysian_ether\",\r\n    vine: \"ecd_elysian_hangingvine\",\r\n};\r\nconst inNoiseRange = (x, y, z) => {\r\n    if (y > 128)\r\n        return false;\r\n    const r = perlin2.get((x + xOffSet) / 14, y / 20, (z + zOffSet) / 14) * 0.2;\r\n    if (y > 30) {\r\n        const n = perlin2.get((x + xOffSet) / 100, y / 100, (z + zOffSet) / 100) *\r\n            (MainWorldGen.height + 50);\r\n        return r > 0.1 && r < 0.8 && y <= n;\r\n    }\r\n    const n = perlin2.get((x + xOffSet) / 50, y / 100, (z + zOffSet) / 200) * 50;\r\n    return y <= n || (r > 0.1 && r < 0.8);\r\n};\r\nexport const MainWorldGen = {\r\n    depth: 16,\r\n    width: 16,\r\n    height: 128,\r\n    generateCircle(vox, x, y, z, radius, skipCenter = false, noDestory = false) {\r\n        let rx = x - radius;\r\n        let rz = z - radius;\r\n        brush.setId(vox);\r\n        for (let ix = rx; ix <= x + radius; ix++) {\r\n            for (let iz = rz; iz <= z + radius; iz++) {\r\n                if (skipCenter) {\r\n                    if (ix == x && iz == z)\r\n                        continue;\r\n                }\r\n                if (noDestory) {\r\n                    if (dataTool.loadInAt(ix, y, iz)) {\r\n                        if (dataTool.isRenderable())\r\n                            continue;\r\n                    }\r\n                }\r\n                if (VoxelMath.distance2D(ix, x, iz, z) < radius) {\r\n                    brush.setXYZ(ix, y, iz).paint();\r\n                }\r\n            }\r\n        }\r\n    },\r\n    generate(dimension, columnX, columnY, columnZ, data) {\r\n        brush.setDimension(dimension).start();\r\n        let makeTeple = false;\r\n        let madeTemple = false;\r\n        let makeVine = false;\r\n        let makeWaterFall = false;\r\n        let templeFlip = indexRNG.get(columnX * (columnY + 3) * columnZ);\r\n        if (templeFlip > 0.98 && !madeTemple) {\r\n            makeTeple = true;\r\n            madeTemple = true;\r\n        }\r\n        const dataTool = brush._dt;\r\n        let totalTrees = 0;\r\n        for (let x = columnX; x < this.width + columnX; x++) {\r\n            for (let z = columnZ; z < this.depth + columnZ; z++) {\r\n                let voxels = elysianDimensionVoxels;\r\n                let flip = indexRNG.get(x * (columnY + 1) * z);\r\n                let vineHeight = 0;\r\n                makeVine = false;\r\n                makeWaterFall = false;\r\n                if (flip > 0.97 && inNoiseRange(x, this.height - 10, z)) {\r\n                    vineHeight = (50 * Math.random()) >> 0;\r\n                    makeVine = true;\r\n                }\r\n                flip = indexRNG.get(x * (columnY + 2) * z);\r\n                if (flip > 0.99 && !makeVine && inNoiseRange(x, this.height - 10, z)) {\r\n                    makeWaterFall = true;\r\n                }\r\n                for (let y = 0; y < this.height + 10; y++) {\r\n                    if (dataTool.loadInAt(x, y, z)) {\r\n                        if (dataTool.isRenderable())\r\n                            continue;\r\n                    }\r\n                    if (y == 0) {\r\n                        brush.setId(\"ecd_immutable\").setXYZ(x, y, z).paint();\r\n                        continue;\r\n                    }\r\n                    if (inNoiseRange(x, y, z)) {\r\n                        if (y > 50 + vineHeight)\r\n                            makeVine = false;\r\n                        brush.setId(voxels.stone);\r\n                        brush.setXYZ(x, y, z).paint();\r\n                    }\r\n                    else {\r\n                        if (makeTeple &&\r\n                            y > 40 &&\r\n                            inNoiseRange(x, y - 1, z) &&\r\n                            !inNoiseRange(x + 7, y + 1, z + 7)) {\r\n                            GenerateDimensionTemple(brush, x, y, z, \"crimson\");\r\n                            makeTeple = false;\r\n                            continue;\r\n                        }\r\n                        if (y > 70 && inNoiseRange(x, y - 1, z) && totalTrees < 3) {\r\n                            if (indexRNG.get(x * y * z) > 0.98) {\r\n                                GenerateTree(brush, x, y, z, \"ecd_elysian_log\", \"ecd_elysian_leafs\");\r\n                                totalTrees++;\r\n                                continue;\r\n                            }\r\n                        }\r\n                        if (y > 40 && inNoiseRange(x, y - 1, z)) {\r\n                            if (indexRNG.get(x * y * z) > 0.93) {\r\n                                brush.setId(voxels.grass).setXYZ(x, y, z).paint();\r\n                                continue;\r\n                            }\r\n                        }\r\n                        if (makeWaterFall) {\r\n                            if (y > 40 && y < this.height - 10) {\r\n                                if (inNoiseRange(x, y + 1, z)) {\r\n                                    brush.setId(voxels.water).setXYZ(x, y, z).paint();\r\n                                    makeWaterFall = false;\r\n                                    continue;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (makeVine) {\r\n                            if (y > 50 + vineHeight) {\r\n                                brush.setId(voxels.vine).setXYZ(x, y, z).paint();\r\n                                continue;\r\n                            }\r\n                        }\r\n                        if (y <= 40) {\r\n                            brush.setId(voxels.water).setXYZ(x, y, z).paint();\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        brush.stop();\r\n    },\r\n};\r\n","import { Distance2D } from \"divine-voxel-engine/Math\";\r\nexport function GenerateCircle(brush, voxel, sx, sy, sz, radius, skipCenter = false, noDestory = false) {\r\n    let rx = sx - radius;\r\n    let rz = sz - radius;\r\n    brush.setId(voxel);\r\n    const dataTool = brush._dt;\r\n    for (let ix = rx; ix <= sx + radius; ix++) {\r\n        for (let iz = rz; iz <= sz + radius; iz++) {\r\n            if (skipCenter) {\r\n                if (ix == sx && iz == sz)\r\n                    continue;\r\n            }\r\n            if (noDestory) {\r\n                if (dataTool.loadInAt(ix, sy, iz)) {\r\n                    if (dataTool.isRenderable())\r\n                        continue;\r\n                }\r\n            }\r\n            if (Distance2D(ix, sx, iz, sz) < radius) {\r\n                brush.setXYZ(ix, sy, iz).paint();\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { StairStates } from \"divine-voxel-engine/Data/Shapes/StairStates.js\";\r\nexport function GenerateStairPillar(brush, sx, sy, sz, height, stairId, pillarId) {\r\n    brush\r\n        .setId(stairId)\r\n        .setXYZ(sx - 1, sy, sz)\r\n        .setShapeState(StairStates.normal.bottom.east)\r\n        .paint()\r\n        .setXYZ(sx + 1, sy, sz)\r\n        .setShapeState(StairStates.normal.bottom.west)\r\n        .paint()\r\n        .setXYZ(sx, sy, sz - 1)\r\n        .setShapeState(StairStates.normal.bottom.north)\r\n        .paint()\r\n        .setXYZ(sx, sy, sz + 1)\r\n        .setShapeState(StairStates.normal.bottom.south)\r\n        .paint()\r\n        .setXYZ(sx - 1, sy, sz - 1)\r\n        .setShapeState(StairStates.connected.bottom.northEast)\r\n        .paint()\r\n        .setXYZ(sx - 1, sy, sz + 1)\r\n        .setShapeState(StairStates.connected.bottom.southEast)\r\n        .paint()\r\n        .setXYZ(sx + 1, sy, sz - 1)\r\n        .setShapeState(StairStates.connected.bottom.northWest)\r\n        .paint()\r\n        .setXYZ(sx + 1, sy, sz + 1)\r\n        .setShapeState(StairStates.connected.bottom.southWest)\r\n        .paint()\r\n        .setXYZ(sx - 1, sy + height, sz)\r\n        .setShapeState(StairStates.normal.top.east)\r\n        .paint()\r\n        .setXYZ(sx + 1, sy + height, sz)\r\n        .setShapeState(StairStates.normal.top.west)\r\n        .paint()\r\n        .setXYZ(sx, sy + height, sz - 1)\r\n        .setShapeState(StairStates.normal.top.north)\r\n        .paint()\r\n        .setXYZ(sx, sy + height, sz + 1)\r\n        .setShapeState(StairStates.normal.top.south)\r\n        .paint()\r\n        .setXYZ(sx - 1, sy + height, sz - 1)\r\n        .setShapeState(StairStates.connected.top.northEast)\r\n        .paint()\r\n        .setXYZ(sx - 1, sy + height, sz + 1)\r\n        .setShapeState(StairStates.connected.top.southEast)\r\n        .paint()\r\n        .setXYZ(sx + 1, sy + height, sz - 1)\r\n        .setShapeState(StairStates.connected.top.northWest)\r\n        .paint()\r\n        .setXYZ(sx + 1, sy + height, sz + 1)\r\n        .setShapeState(StairStates.connected.top.southWest)\r\n        .paint();\r\n    brush.setId(pillarId).setShapeState(0);\r\n    let i = sy + height;\r\n    while (i > sy) {\r\n        brush.setXYZ(sx, i, sz).paint();\r\n        i--;\r\n    }\r\n    brush.setShapeState(0);\r\n}\r\n","import { StairStates } from \"divine-voxel-engine/Data/Shapes/StairStates\";\r\nexport function GenerateStairRoof(brush, sx, sy, sz, width, depth, height, stairId) {\r\n    brush.setId(stairId);\r\n    let c = 0;\r\n    for (let y = sy; y < sy + height; y++) {\r\n        let startX = sx + c;\r\n        let endX = sx + width - c;\r\n        let startZ = sz + c;\r\n        let endZ = sz + depth - c;\r\n        for (let x = startX; x < endX; x++) {\r\n            for (let z = startZ; z < endZ; z++) {\r\n                brush.setXYZ(x, y, z);\r\n                if (x == startX && z == startZ) {\r\n                    brush.setShapeState(StairStates.connected.bottom.northEast).paint();\r\n                    continue;\r\n                }\r\n                if (x == startX && z == endZ - 1) {\r\n                    brush.setShapeState(StairStates.connected.bottom.southEast).paint();\r\n                    continue;\r\n                }\r\n                if (x == endX - 1 && z == startZ) {\r\n                    brush.setShapeState(StairStates.connected.bottom.northWest).paint();\r\n                    continue;\r\n                }\r\n                if (x == endX - 1 && z == endZ - 1) {\r\n                    brush.setShapeState(StairStates.connected.bottom.southWest).paint();\r\n                    continue;\r\n                }\r\n                if (x == startX) {\r\n                    brush.setShapeState(StairStates.normal.bottom.east).paint();\r\n                    continue;\r\n                }\r\n                if (x == endX - 1) {\r\n                    brush.setShapeState(StairStates.normal.bottom.west).paint();\r\n                    continue;\r\n                }\r\n                if (z == startZ) {\r\n                    brush.setShapeState(StairStates.normal.bottom.north).paint();\r\n                    continue;\r\n                }\r\n                if (z == endZ - 1) {\r\n                    brush.setShapeState(StairStates.normal.bottom.south).paint();\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        c++;\r\n    }\r\n    brush.setShapeState(0);\r\n}\r\n","import { VisitAll } from \"divine-voxel-engine/Math\";\r\nimport { GenerateCircle } from \"./Circle.js\";\r\nconst start = { x: 0, y: 0, z: 0 };\r\nconst end = { x: 0, y: 0, z: 0 };\r\nexport function GenerateTree(brush, sx, sy, sz, logId, leafId) {\r\n    const height = ((Math.random() * 15) >> 0) + 5;\r\n    const rx = ((sx - 5 + Math.random() * 10) >> 0) + 1;\r\n    const rz = ((sz - 5 + Math.random() * 10) >> 0) + 1;\r\n    start.x = sx;\r\n    start.y = sy;\r\n    start.z = sz;\r\n    end.x = rx;\r\n    end.y = sy + height;\r\n    end.z = rz;\r\n    brush.setId(logId);\r\n    let c = 0;\r\n    const voxels = VisitAll(start, end, (x, y, z) => {\r\n        c++;\r\n        if (c > 50) {\r\n            end.x = x;\r\n            end.y = y;\r\n            end.z = z;\r\n            return false;\r\n        }\r\n        return true;\r\n    });\r\n    for (let i = 0; i < voxels.length; i += 3) {\r\n        const x = voxels[i];\r\n        const y = voxels[i + 1];\r\n        const z = voxels[i + 2];\r\n        brush.setXYZ(x, y, z).paint();\r\n    }\r\n    let capHeight = ((Math.random() * 10) >> 0) + 1;\r\n    if (capHeight < 4)\r\n        capHeight = 4;\r\n    let i = capHeight;\r\n    let radius = 1;\r\n    while (i--) {\r\n        brush.setId(logId);\r\n        if (i == capHeight - 1) {\r\n            brush.setId(leafId);\r\n        }\r\n        brush.setXYZ(end.x, end.y + i, end.z).paint();\r\n        GenerateCircle(brush, leafId, end.x, end.y + i, end.z, radius, true, true);\r\n        radius++;\r\n    }\r\n}\r\n","import { GenerateStairPillar } from \"../../Functions/StairPillar.js\";\r\nimport { GenerateStairRoof } from \"../../Functions/StairRoof.js\";\r\nconst DimensionTempleVoxels = {\r\n    crimson: {\r\n        stone: \"ecd_crimson_star_stone\",\r\n        stair: \"ecd_crimson_star_stone_stair\",\r\n        lamp: \"ecd_crimson_lamp\",\r\n        ether: \"ecd_crimson_ether\",\r\n    },\r\n};\r\n/*\r\necd_crimson_star_stone\r\necd_crimson_lamp\r\necd_crimson_ether\r\n*/\r\nexport function GenerateDimensionTemple(brush, sx, sy, sz, templeDimension) {\r\n    const dimensionData = DimensionTempleVoxels[templeDimension];\r\n    if (!dimensionData)\r\n        return false;\r\n    const dataTool = brush._dt;\r\n    const width = 16;\r\n    const depth = 16;\r\n    for (let x = sx; x < sx + width; x++) {\r\n        for (let z = sz; z < sz + depth; z++) {\r\n            for (let y = sy; y > 0; y--) {\r\n                if (dataTool.loadInAt(x, y, z)) {\r\n                    if (dataTool.isOpaque())\r\n                        continue;\r\n                }\r\n                brush.setXYZ(x, y, z);\r\n                if (y > sy - 5) {\r\n                    if ((x == sx + 7 && z == sz + 7) ||\r\n                        (x == sx + 8 && z == sz + 8) ||\r\n                        (x == sx + 7 && z == sz + 8) ||\r\n                        (x == sx + 8 && z == sz + 7)) {\r\n                        brush.setId(dimensionData.stone).paint();\r\n                        continue;\r\n                    }\r\n                    if (x >= sx + 4 && z >= sz + 4 && x <= sx + 11 && z <= sz + 11) {\r\n                        brush.setId(dimensionData.ether).paint();\r\n                        continue;\r\n                    }\r\n                }\r\n                brush.setId(dimensionData.stone).paint();\r\n            }\r\n        }\r\n    }\r\n    for (let x = sx; x < sx + width; x++) {\r\n        for (let z = sz; z < sz + depth; z++) {\r\n            for (let y = sy; y < sy + 10; y++) {\r\n                if (dataTool.loadInAt(x, y, z)) {\r\n                    if (dataTool.isOpaque())\r\n                        continue;\r\n                }\r\n                brush.setXYZ(x, y, z);\r\n                if ((x == sx + 7 && z == sz + 7) ||\r\n                    (x == sx + 8 && z == sz + 8) ||\r\n                    (x == sx + 7 && z == sz + 8) ||\r\n                    (x == sx + 8 && z == sz + 7)) {\r\n                    if (y == sy + 9) {\r\n                        brush.setId(dimensionData.lamp).paint();\r\n                        brush\r\n                            .setXYZ(x, y + 1, z)\r\n                            .setId(dimensionData.ether)\r\n                            .paint();\r\n                        continue;\r\n                    }\r\n                    brush.setId(dimensionData.stone).paint();\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    GenerateStairPillar(brush, sx + 1, sy + 1, sz + 1, 10, dimensionData.stair, dimensionData.stone);\r\n    GenerateStairPillar(brush, sx + 14, sy + 1, sz + 1, 10, dimensionData.stair, dimensionData.stone);\r\n    GenerateStairPillar(brush, sx + 1, sy + 1, sz + 14, 10, dimensionData.stair, dimensionData.stone);\r\n    GenerateStairPillar(brush, sx + 14, sy + 1, sz + 14, 10, dimensionData.stair, dimensionData.stone);\r\n    GenerateStairRoof(brush, sx, sy + 12, sz, 16, 16, 10, dimensionData.stair);\r\n}\r\n","import { MainWorldGen } from \"./Dimensions/Main/MainWorldGen.js\";\r\nexport const WorldGenerator = {\r\n    generate(dimension, x, y, z, data) {\r\n        if (dimension == \"main\") {\r\n            //  TestWorldGen.generate(dimension, x, y, z, data);\r\n            MainWorldGen.generate(dimension, x, y, z, data);\r\n        }\r\n    },\r\n};\r\n","class LCG {\r\n    seed;\r\n    m = 4294967296;\r\n    a = 1664525;\r\n    c = 1013904223;\r\n    z = 0;\r\n    constructor(seed) {\r\n        this.seed = seed;\r\n        this.setSeed(seed);\r\n    }\r\n    setSeed(val) {\r\n        this.z = this.seed = (val == null ? Math.random() * this.m : val) >>> 0;\r\n    }\r\n    getSeed() {\r\n        return this.seed;\r\n    }\r\n    rand() {\r\n        this.z = (this.a * this.z + this.c) % this.m;\r\n        return this.z / this.m;\r\n    }\r\n}\r\nexport class IndexedRNG {\r\n    seed;\r\n    MAX_VERTICES = 256_000;\r\n    MAX_VERTICES_MASK = this.MAX_VERTICES - 1;\r\n    amplitude = 1;\r\n    scale = 1;\r\n    r = [];\r\n    constructor(seed) {\r\n        this.seed = seed;\r\n        const lcg = new LCG(seed);\r\n        for (let i = 0; i < this.MAX_VERTICES; ++i) {\r\n            this.r.push(lcg.rand());\r\n        }\r\n    }\r\n    get(x) {\r\n        const scaledX = x * this.scale;\r\n        const xFloor = Math.floor(scaledX);\r\n        const t = scaledX - xFloor;\r\n        const tRemapSmoothstep = t * t * (3 - 2 * t);\r\n        const xMin = xFloor & this.MAX_VERTICES_MASK;\r\n        const xMax = (xMin + 1) & this.MAX_VERTICES_MASK;\r\n        const y = this._lerp(this.r[xMin], this.r[xMax], tRemapSmoothstep);\r\n        return y * this.amplitude;\r\n    }\r\n    _lerp(a, b, t) {\r\n        return a * (1 - t) + b * t;\r\n    }\r\n}\r\n","export * from \"./IndexedRNG/index.js\";\r\nexport * from \"./perlin/index.js\";\r\nexport * from \"./random/index.js\";\r\n","/**# Perlin Noise 3d\r\n * ---\r\n * TypeScript version of the library found here:\r\n * https://github.com/alterebro/perlin-noise-3d\r\n */\r\nexport class PerlinNoise3d {\r\n    // Based on http://mrl.nyu.edu/~perlin/noise/\r\n    // Adapting from runemadsen/rune.noise.js\r\n    // Which was adapted from P5.js\r\n    // Which was adapted from PApplet.java\r\n    // which was adapted from toxi\r\n    // which was adapted from the german demo group farbrausch as used in their demo \"art\": http://www.farb-rausch.de/fr010src.zip\r\n    PERLIN_YWRAPB = 4;\r\n    PERLIN_YWRAP = 1 << this.PERLIN_YWRAPB;\r\n    PERLIN_ZWRAPB = 8;\r\n    PERLIN_ZWRAP = 1 << this.PERLIN_ZWRAPB;\r\n    PERLIN_SIZE = 4095;\r\n    SINCOS_PRECISION = 0.5;\r\n    SINCOS_LENGTH = Math.floor(360 / this.SINCOS_PRECISION);\r\n    sinLUT = new Array(this.SINCOS_LENGTH);\r\n    cosLUT = new Array(this.SINCOS_LENGTH);\r\n    DEG_TO_RAD = Math.PI / 180.0;\r\n    perlin_octaves = 4; // default to medium smooth\r\n    perlin_amp_falloff = 0.5; // 50% reduction/octave\r\n    perlin = null;\r\n    perlin_PI = this.SINCOS_LENGTH;\r\n    constructor() {\r\n        this.perlin_PI >>= 1;\r\n        for (let i = 0; i < this.SINCOS_LENGTH; i++) {\r\n            this.sinLUT[i] = Math.sin(i * this.DEG_TO_RAD * this.SINCOS_PRECISION);\r\n            this.cosLUT[i] = Math.cos(i * this.DEG_TO_RAD * this.SINCOS_PRECISION);\r\n        }\r\n    }\r\n    lcg() {\r\n        // Set to values from http://en.wikipedia.org/wiki/Numerical_Recipes\r\n        // m is basically chosen to be large (as it is the max period)\r\n        // and for its relationships to a and c\r\n        let m = 4294967296, \r\n        // a - 1 should be divisible by m's prime factors\r\n        a = 1664525, \r\n        // c and m should be co-prime\r\n        c = 1013904223, seed, z;\r\n        return {\r\n            setSeed: function (val) {\r\n                // pick a random seed if val is undefined or null\r\n                // the >>> 0 casts the seed to an unsigned 32-bit integer\r\n                z = seed = (val == null ? Math.random() * m : val) >>> 0;\r\n            },\r\n            getSeed: function () {\r\n                return seed;\r\n            },\r\n            rand: function () {\r\n                // define the recurrence relationship\r\n                z = (a * z + c) % m;\r\n                // return a float in [0, 1)\r\n                // if z = m then z / m = 0 therefore (z % m) / m < 1 always\r\n                return z / m;\r\n            },\r\n        };\r\n    }\r\n    noiseSeed(seed) {\r\n        // Linear Congruential Generator\r\n        // Variant of a Lehman Generator\r\n        const lcg = this.lcg();\r\n        lcg.setSeed(seed);\r\n        this.perlin = new Array(this.PERLIN_SIZE + 1);\r\n        for (let i = 0; i < this.PERLIN_SIZE + 1; i++) {\r\n            this.perlin[i] = lcg.rand();\r\n        }\r\n        return this;\r\n    }\r\n    noise_fsc(i) {\r\n        // using cosine lookup table\r\n        return (0.5 *\r\n            (1.0 - this.cosLUT[Math.floor(i * this.perlin_PI) % this.SINCOS_LENGTH]));\r\n    }\r\n    get(x, y, z) {\r\n        y = y || 0;\r\n        z = z || 0;\r\n        if (this.perlin == null) {\r\n            this.perlin = new Array(this.PERLIN_SIZE + 1);\r\n            for (let i = 0; i < this.PERLIN_SIZE + 1; i++) {\r\n                this.perlin[i] = Math.random();\r\n            }\r\n        }\r\n        if (x < 0) {\r\n            x = -x;\r\n        }\r\n        if (y < 0) {\r\n            y = -y;\r\n        }\r\n        if (z < 0) {\r\n            z = -z;\r\n        }\r\n        let xi = Math.floor(x), yi = Math.floor(y), zi = Math.floor(z);\r\n        let xf = x - xi;\r\n        let yf = y - yi;\r\n        let zf = z - zi;\r\n        let rxf, ryf;\r\n        let r = 0;\r\n        let ampl = 0.5;\r\n        let n1, n2, n3;\r\n        for (let o = 0; o < this.perlin_octaves; o++) {\r\n            let of = xi + (yi << this.PERLIN_YWRAPB) + (zi << this.PERLIN_ZWRAPB);\r\n            rxf = this.noise_fsc(xf);\r\n            ryf = this.noise_fsc(yf);\r\n            n1 = this.perlin[of & this.PERLIN_SIZE];\r\n            n1 += rxf * (this.perlin[(of + 1) & this.PERLIN_SIZE] - n1);\r\n            n2 = this.perlin[(of + this.PERLIN_YWRAP) & this.PERLIN_SIZE];\r\n            n2 +=\r\n                rxf *\r\n                    (this.perlin[(of + this.PERLIN_YWRAP + 1) & this.PERLIN_SIZE] - n2);\r\n            n1 += ryf * (n2 - n1);\r\n            of += this.PERLIN_ZWRAP;\r\n            n2 = this.perlin[of & this.PERLIN_SIZE];\r\n            n2 += rxf * (this.perlin[(of + 1) & this.PERLIN_SIZE] - n2);\r\n            n3 = this.perlin[(of + this.PERLIN_YWRAP) & this.PERLIN_SIZE];\r\n            n3 +=\r\n                rxf *\r\n                    (this.perlin[(of + this.PERLIN_YWRAP + 1) & this.PERLIN_SIZE] - n3);\r\n            n2 += ryf * (n3 - n2);\r\n            n1 += this.noise_fsc(zf) * (n2 - n1);\r\n            r += n1 * ampl;\r\n            ampl *= this.perlin_amp_falloff;\r\n            xi <<= 1;\r\n            xf *= 2;\r\n            yi <<= 1;\r\n            yf *= 2;\r\n            zi <<= 1;\r\n            zf *= 2;\r\n            if (xf >= 1.0) {\r\n                xi++;\r\n                xf--;\r\n            }\r\n            if (yf >= 1.0) {\r\n                yi++;\r\n                yf--;\r\n            }\r\n            if (zf >= 1.0) {\r\n                zi++;\r\n                zf--;\r\n            }\r\n        }\r\n        return r;\r\n    }\r\n}\r\n","/**\r\n * @class\r\n * @classdesc Base class all algorithm implementations should inherit from.\r\n */\r\nclass Base {\r\n    /**\r\n     * Generate a hash from a string that is suitable to use as a seed for any\r\n     * of the PRNG's that inherit from this.\r\n     *\r\n     * @param {string} str\r\n     * @returns {Function}\r\n     */\r\n    static _xfnv1a(str) {\r\n        let h = 2166136261 >>> 0;\r\n        for (let i = 0; i < str.length; i++) {\r\n            h = Math.imul(h ^ str.charCodeAt(i), 16777619);\r\n        }\r\n        return () => {\r\n            h += h << 13;\r\n            h ^= h >>> 7;\r\n            h += h << 3;\r\n            h ^= h >>> 17;\r\n            return (h += h << 5) >>> 0;\r\n        };\r\n    }\r\n}\r\nexport default Base;\r\n","import Base from './Base.js';\r\n/**\r\n * @class\r\n * @classdesc Concrete mulberry32 implementation.\r\n */\r\nclass Mulberry32 extends Base {\r\n    /**\r\n     * Seed parameter.\r\n     *\r\n     * @var {number}\r\n     */\r\n    a;\r\n    /**\r\n     * Create a new mulberry32 instance.\r\n     *\r\n     * @param {string} str\r\n     */\r\n    constructor(str) {\r\n        super();\r\n        this.a = Mulberry32._xfnv1a(str)();\r\n    }\r\n    /**\r\n     * Generate a random number using the mulberry32 algorithm.\r\n     *\r\n     * @returns {number}\r\n     */\r\n    next() {\r\n        let t = (this.a += 0x6d2b79f5);\r\n        t = Math.imul(t ^ (t >>> 15), t | 1);\r\n        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);\r\n        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\r\n    }\r\n}\r\nexport default Mulberry32;\r\n","import Base from './Base.js';\r\n/**\r\n * @class\r\n * @classdesc Concrete sfc32 implementation.\r\n */\r\nclass Sfc32 extends Base {\r\n    /**\r\n     * Seed parameters.\r\n     *\r\n     * @var {number}\r\n     */\r\n    a;\r\n    b;\r\n    c;\r\n    d;\r\n    /**\r\n     * Create a new sfc32 instance.\r\n     *\r\n     * @param {string} str\r\n     */\r\n    constructor(str) {\r\n        super();\r\n        // Create the seed for the random number algorithm\r\n        const seed = Sfc32._xfnv1a(str);\r\n        this.a = seed();\r\n        this.b = seed();\r\n        this.c = seed();\r\n        this.d = seed();\r\n    }\r\n    /**\r\n     * Generate a random number using the sfc32 algorithm.\r\n     *\r\n     * @returns {number}\r\n     */\r\n    next() {\r\n        this.a >>>= 0;\r\n        this.b >>>= 0;\r\n        this.c >>>= 0;\r\n        this.d >>>= 0;\r\n        let t = (this.a + this.b) | 0;\r\n        this.a = this.b ^ (this.b >>> 9);\r\n        this.b = (this.c + (this.c << 3)) | 0;\r\n        this.c = (this.c << 21) | (this.c >>> 11);\r\n        this.d = (this.d + 1) | 0;\r\n        t = (t + this.d) | 0;\r\n        this.c = (this.c + t) | 0;\r\n        return (t >>> 0) / 4294967296;\r\n    }\r\n}\r\nexport default Sfc32;\r\n","import Base from './Base.js';\r\n/**\r\n * @class\r\n * @classdesc Concrete xoshiro128** implementation.\r\n */\r\nclass Xoshiro128ss extends Base {\r\n    /**\r\n     * Seed parameters.\r\n     *\r\n     * @var {number}\r\n     */\r\n    a;\r\n    b;\r\n    c;\r\n    d;\r\n    /**\r\n     * Create a new xoshiro128** instance.\r\n     *\r\n     * @param {string} str\r\n     */\r\n    constructor(str) {\r\n        super();\r\n        // Create the seed for the random number algorithm\r\n        const seed = Xoshiro128ss._xfnv1a(str);\r\n        this.a = seed();\r\n        this.b = seed();\r\n        this.c = seed();\r\n        this.d = seed();\r\n    }\r\n    /**\r\n     * Generate a random number using the xoshiro128** algorithm.\r\n     *\r\n     * @returns {number}\r\n     */\r\n    next() {\r\n        const t = this.b << 9;\r\n        let r = this.a * 5;\r\n        r = (r << 7) | ((r >>> 25) * 9);\r\n        this.c ^= this.a;\r\n        this.d ^= this.b;\r\n        this.b ^= this.c;\r\n        this.a ^= this.d;\r\n        this.c ^= t;\r\n        this.d = (this.d << 11) | (this.d >>> 21);\r\n        return (r >>> 0) / 4294967296;\r\n    }\r\n}\r\nexport default Xoshiro128ss;\r\n","import Mulberry32 from './Algorithms/Mulberry32.js';\r\nimport Sfc32 from './Algorithms/Sfc32.js';\r\nimport Xoshiro128ss from './Algorithms/Xoshiro128ss.js';\r\nimport { isNullOrUndefined } from './helpers.js';\r\n/**\r\n * Available seedable random number generator algorithms.\r\n *\r\n * @var {PRNG}\r\n */\r\nexport var PRNG;\r\n(function (PRNG) {\r\n    PRNG[\"sfc32\"] = \"sfc32\";\r\n    PRNG[\"mulberry32\"] = \"mulberry32\";\r\n    PRNG[\"xoshiro128ss\"] = \"xoshiro128ss\";\r\n})(PRNG || (PRNG = {}));\r\n/**\r\n * A class for generating random numbers. Several different (seedable) random\r\n * number generator algorithms are configurable.\r\n *\r\n * See https://stackoverflow.com/a/47593316/7024747 for more info.\r\n * @class\r\n * @classdesc A class for generating random numbers.\r\n */\r\nclass Rand {\r\n    /**\r\n     * The string that will be used for generating a suitable hash for any of\r\n     * the provided PRNG algorithms.\r\n     *\r\n     * @var {string}\r\n     */\r\n    str;\r\n    /**\r\n     * The PRNG algorithm that should be used for random number generation.\r\n     *\r\n     * @var {PRNG}\r\n     */\r\n    prng;\r\n    /**\r\n     * The generator that should be used for generating random numbers.\r\n     *\r\n     * @var {Function}\r\n     */\r\n    generator;\r\n    /**\r\n     * Create a new rand instance.\r\n     *\r\n     * @param {string} str\r\n     * @param {PRNG} prng\r\n     */\r\n    constructor(str, prng = PRNG.sfc32) {\r\n        this.str = str;\r\n        this.prng = prng;\r\n        this.generator = this._initializeGenerator();\r\n    }\r\n    /**\r\n     * Generate a new random number using the selected generator.\r\n     *\r\n     * @returns {number}\r\n     */\r\n    next() {\r\n        return this.generator.next();\r\n    }\r\n    /**\r\n     * Initialize the chosen random number generator.\r\n     *\r\n     * @returns {Algorithm|Function}\r\n     */\r\n    _initializeGenerator() {\r\n        if (isNullOrUndefined(this.str))\r\n            return this.wrap();\r\n        switch (this.prng) {\r\n            case 'sfc32':\r\n                return new Sfc32(this.str);\r\n            case 'mulberry32':\r\n                return new Mulberry32(this.str);\r\n            case 'xoshiro128ss':\r\n                return new Xoshiro128ss(this.str);\r\n            default:\r\n                return this.wrap();\r\n        }\r\n    }\r\n    /**\r\n     * Wrap the standard random function in an object.\r\n     *\r\n     * @returns {Algorithm}\r\n     */\r\n    wrap() {\r\n        return {\r\n            /**\r\n             * Generate a random number.\r\n             *\r\n             * @return {number}\r\n             */\r\n            next() {\r\n                return Math.random();\r\n            },\r\n        };\r\n    }\r\n}\r\nexport default Rand;\r\n","/**\r\n * Determine if the given value is undefined.\r\n *\r\n * @param {mixed} value\r\n * @returns {boolean}\r\n */\r\nexport const isUndefined = (value) => typeof value === 'undefined';\r\n/**\r\n * Determine if the given value is null.\r\n *\r\n * @param {mixed} value\r\n * @returns {boolean}\r\n */\r\nexport const isNull = (value) => value === null;\r\n/**\r\n * Determine if the given value is null or undefined.\r\n *\r\n * @param {mixed} value\r\n * @returns {boolean}\r\n */\r\nexport const isNullOrUndefined = (value) => {\r\n    return isNull(value) || isUndefined(value);\r\n};\r\n","import Rand, { PRNG } from './Rand.js';\r\nexport default Rand;\r\nexport { PRNG };\r\n","export const ConstructorRemoteThreadTasks = {\r\n    syncShapeMap: -1,\r\n    addToRebuildQue: 0,\r\n    runRebuildQue: 1,\r\n    addToRGBLightUpdateQue: 2,\r\n    buildChunk: 3\r\n};\r\n","export const ConstructorTasks = {\r\n    buildChunk: 0,\r\n    buildColumn: 0,\r\n    generate: 0,\r\n    RGBlightUpdate: 0,\r\n    RGBlightRemove: 0,\r\n    worldSun: 0,\r\n    sunLightUpdate: 0,\r\n    sunLightRemove: 0,\r\n    analyzerPropagation: 0,\r\n    analyzerUpdate: 0,\r\n    flowUpdate: 0,\r\n    flowRemove: 0,\r\n    constructEntity: 0,\r\n    constructItem: 0,\r\n    explosion: 0,\r\n    voxelErease: 0,\r\n    voxelPaint: 0,\r\n};\r\nlet index = 0;\r\nfor (const key of Object.keys(ConstructorTasks)) {\r\n    ConstructorTasks[key] = index;\r\n    index++;\r\n}\r\n","//propagation\r\nimport { FlowUpdate } from \"../Propagation/Flow/Functions/FlowUpdate.js\";\r\nimport { Propagation } from \"../Propagation/Propagation.js\";\r\n//objects\r\nimport { EngineSettings } from \"../../Data/Settings/EngineSettings.js\";\r\nimport { DVEC } from \"../../Constructor/DivineVoxelEngineConstructor.js\";\r\nimport { AnalyzerProcessor } from \"./AnalyzerProcessor.js\";\r\nimport { AnalyzerUpdater } from \"./AnalyzerUpdater.js\";\r\nimport { TasksRequest } from \"../Tasks/TasksRequest.js\";\r\n//tools\r\nimport { GetConstructorDataTool } from \"../Tools/Data/ConstructorDataTool.js\";\r\nconst mainDT = GetConstructorDataTool();\r\nconst secondaryDT = GetConstructorDataTool();\r\nexport const Analyzer = {\r\n    updater: AnalyzerUpdater,\r\n    processor: AnalyzerProcessor,\r\n    _flowChecks: [\r\n        [0, -1, 0],\r\n        [1, 0, 0],\r\n        [-1, 0, 0],\r\n        [0, 0, 1],\r\n        [0, 0, -1],\r\n    ],\r\n    async runPropagation(data) {\r\n        const options = {\r\n            light: EngineSettings.doLight(),\r\n            flow: EngineSettings.doFlow(),\r\n        };\r\n        mainDT.setDimension(data[0][0]);\r\n        secondaryDT.setDimension(data[0][0]);\r\n        const tasks = TasksRequest.getVoxelUpdateRequests(data[0], \"none\", \"self\");\r\n        this.processor.goThroughColumn(data[0], (x, y, z) => {\r\n            if (!mainDT.loadInAt(x, y, z))\r\n                return;\r\n            const substance = mainDT.getSubstance();\r\n            if (options.light) {\r\n                if (mainDT.isLightSource()) {\r\n                    tasks.queues.rgb.update.push(x, y, z);\r\n                }\r\n            }\r\n            if (options.flow) {\r\n                if (substance == \"#dve_liquid\" || substance == \"#dve_magma\") {\r\n                    let add = false;\r\n                    for (const check of this._flowChecks) {\r\n                        if (secondaryDT.loadInAt(x + check[0], y + check[1], z + check[2])) {\r\n                            if (secondaryDT.isAir()) {\r\n                                add = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (add) {\r\n                        tasks.queues.flow.update.queue.push([x, y, z]);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        tasks.start();\r\n        Propagation.rgb.update(tasks);\r\n        const dimension = data[0][0];\r\n        for (const flowUpdate of tasks.queues.flow.update.queue) {\r\n            const [x, y, z] = flowUpdate;\r\n            if (!mainDT.loadInAt(x, y, z))\r\n                continue;\r\n            await FlowUpdate(TasksRequest.getFlowUpdateRequest([dimension, x, y, z], \"none\", \"self\"), false, mainDT.getStringId());\r\n        }\r\n        tasks.stop();\r\n    },\r\n    async runUpdate(data) {\r\n        if (!this.processor.columnTool.setLocation(data[0]).loadIn())\r\n            return;\r\n        const deltaTime = Date.now() - this.processor.columnTool.getLastAnalyzerUpdateTimestamp();\r\n        const location = [...data[0]];\r\n        this.processor.goThroughColumn(data[0], (x, y, z) => {\r\n            if (!mainDT.loadInAt(x, y, z))\r\n                return;\r\n            location[1] = x;\r\n            location[2] = y;\r\n            location[3] = z;\r\n            const run = this.updater.getVoxel(mainDT.getStringId());\r\n            if (!run)\r\n                return;\r\n            run(location, deltaTime, this, DVEC);\r\n        });\r\n        this.processor.columnTool.setLastAnalyzerUpdateTimestamp();\r\n    },\r\n};\r\n","import { WorldSpaces } from \"../../Data/World/WorldSpaces.js\";\r\nimport { ColumnDataTool } from \"../../Tools/Data/WorldData/ColumnDataTool.js\";\r\nimport { HeightMapTool } from \"../../Tools/Data/WorldData/HeightMapTool.js\";\r\nimport { ChunkDataTool } from \"../../Tools/Data/WorldData/ChunkDataTool.js\";\r\nimport { WorldRegister } from \"../../Data/World/WorldRegister.js\";\r\nconst columnTool = new ColumnDataTool();\r\nconst heightMapTool = new HeightMapTool();\r\nconst chunkTool = new ChunkDataTool();\r\nexport const AnalyzerProcessor = {\r\n    columnTool: columnTool,\r\n    chunkTool: chunkTool,\r\n    goThroughColumn(location, run) {\r\n        if (!columnTool.setLocation(location).loadIn())\r\n            return;\r\n        WorldRegister.cache.enable();\r\n        const column = columnTool.getColumn();\r\n        let maxX = WorldSpaces.chunk._bounds.x + location[1];\r\n        let maxZ = WorldSpaces.chunk._bounds.z + location[3];\r\n        for (const [index, chunk] of column.chunks) {\r\n            heightMapTool.chunk.setChunk(chunk);\r\n            chunkTool.setChunk(chunk);\r\n            const [dimension, cx, cy, cz] = chunkTool.getLocationData();\r\n            let [minY, maxY] = heightMapTool.chunk.getMinMax();\r\n            minY += cy;\r\n            maxY += cy + 1;\r\n            for (let x = cx; x < maxX; x += 1) {\r\n                for (let z = cz; z < maxZ; z += 1) {\r\n                    for (let y = minY; y < maxY; y += 1) {\r\n                        run(x, y, z, columnTool);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        WorldRegister.cache.disable();\r\n    },\r\n};\r\n","export const AnalyzerUpdater = {\r\n    _voxels: new Map(),\r\n    registerVoxel(id, run) {\r\n        this._voxels.set(id, run);\r\n    },\r\n    getVoxel(id) {\r\n        const run = this._voxels.get(id);\r\n        if (!run)\r\n            return false;\r\n        return run;\r\n    },\r\n};\r\n","//objects\r\nimport { DVEC } from \"../DivineVoxelEngineConstructor.js\";\r\nimport { ShapeManager } from \"./Shapes/ShapeManager.js\";\r\nimport { TextureManager } from \"./Textures/TextureManager.js\";\r\nimport { Processor } from \"./Processor/Processor.js\";\r\nimport { ChunkMesher } from \"./Mesher/ChunkMesher.js\";\r\nimport { SubstanceRules } from \"./Rules/SubstanceRules.js\";\r\n//functions\r\nimport { InitBuilder } from \"./Init/InitBuilder.js\";\r\nimport { OverrideManager } from \"./Rules/Overrides/OverridesManager.js\";\r\nexport const Builder = {\r\n    textureManager: TextureManager,\r\n    shapeManager: ShapeManager,\r\n    chunkMesher: ChunkMesher,\r\n    processor: Processor,\r\n    substanceRules: SubstanceRules,\r\n    overrides: OverrideManager,\r\n    dimension: 0,\r\n    async $INIT() {\r\n        InitBuilder(this);\r\n    },\r\n    syncSettings(settings) {\r\n        this.processor.syncSettings(settings);\r\n    },\r\n    buildChunk(location, LOD = 1) {\r\n        let chunk = DVEC.data.worldRegister.chunk.get(location);\r\n        if (!chunk) {\r\n            console.warn(`${location.toString()}could not be loaded`);\r\n            return;\r\n        }\r\n        DVEC.data.worldRegister.cache.enable();\r\n        const template = this.processor.makeAllChunkTemplates(location, LOD);\r\n        this.chunkMesher.buildChunkMesh(location, template, LOD);\r\n        this.processor.flush();\r\n        DVEC.data.worldRegister.cache.disable();\r\n        return true;\r\n    },\r\n    constructEntity() {\r\n        /*   const template = this.processor.constructEntity();\r\n        this.entityMesher.buildEntityMesh(\r\n         this.entityConstructor.pos.x,\r\n         this.entityConstructor.pos.y,\r\n         this.entityConstructor.pos.z,\r\n         template.solid\r\n        );\r\n        this.entityConstructor.clearEntityData();\r\n        this.processor.flush(); */\r\n    },\r\n};\r\n","import { BoxVoxelConstructor, PillarBoxVoxelConstructor, } from \"./classes/Box.constructor.js\";\r\nimport { LiquidVoxelConstructor } from \"./classes/Liquid.constructor.js\";\r\nimport { PanelVoxelConstructor } from \"./classes/Panel.constructor.js\";\r\nexport const VoxelConstructors = {\r\n    voxelObjects: new Map(),\r\n    getVoxel(id) {\r\n        return this.voxelObjects.get(id);\r\n    },\r\n    registerVoxel(voxel) {\r\n        if (Array.isArray(voxel)) {\r\n            for (const vox of voxel) {\r\n                this.voxelObjects.set(vox.id, vox);\r\n            }\r\n            return;\r\n        }\r\n        this.voxelObjects.set(voxel.id, voxel);\r\n    },\r\n    defaults: {\r\n        box: {\r\n            simple(id, textures) {\r\n                return new BoxVoxelConstructor(id, textures);\r\n            },\r\n            pillar(id, textures) {\r\n                return new PillarBoxVoxelConstructor(id, textures);\r\n            },\r\n        },\r\n        panel: {\r\n            simple(id, texture) {\r\n                return new PanelVoxelConstructor(id, texture);\r\n            },\r\n        },\r\n        liquid: {\r\n            simple(id, textures) {\r\n                return new LiquidVoxelConstructor(id, textures);\r\n            },\r\n        },\r\n    },\r\n};\r\n","import { ConstructorHooks } from \"../../../../Hooks/ConstructorHooks.js\";\r\nexport class BoxVoxelConstructor {\r\n    id;\r\n    textures = [];\r\n    constructor(id, textures) {\r\n        this.id = id;\r\n        ConstructorHooks.texturesRegistered.addToRun((textureManager) => {\r\n            if (Array.isArray(textures)) {\r\n                let i = 6;\r\n                while (i--) {\r\n                    this.textures.push(textureManager.getTextureUV(textures));\r\n                }\r\n                return;\r\n            }\r\n            this.textures.push(textureManager.getTextureUV(textures.top));\r\n            this.textures.push(textureManager.getTextureUV(textures.bottom));\r\n            this.textures.push(textureManager.getTextureUV(textures.east));\r\n            this.textures.push(textureManager.getTextureUV(textures.west));\r\n            this.textures.push(textureManager.getTextureUV(textures.south));\r\n            this.textures.push(textureManager.getTextureUV(textures.north));\r\n        });\r\n    }\r\n    process(templater) {\r\n        if (templater.isFaceExpposed(\"top\")) {\r\n            templater.addUV(this.textures[0]).addOverlayUVs([0]);\r\n        }\r\n        if (templater.isFaceExpposed(\"bottom\")) {\r\n            templater.addUV(this.textures[1]).addOverlayUVs([0]);\r\n        }\r\n        if (templater.isFaceExpposed(\"east\")) {\r\n            templater.addUV(this.textures[2]).addOverlayUVs([0]);\r\n        }\r\n        if (templater.isFaceExpposed(\"west\")) {\r\n            templater.addUV(this.textures[3]).addOverlayUVs([0]);\r\n        }\r\n        if (templater.isFaceExpposed(\"south\")) {\r\n            templater.addUV(this.textures[4]).addOverlayUVs([0]);\r\n        }\r\n        if (templater.isFaceExpposed(\"north\")) {\r\n            templater.addUV(this.textures[5]).addOverlayUVs([0]);\r\n        }\r\n        templater.processVoxelLight();\r\n    }\r\n}\r\nexport class PillarBoxVoxelConstructor {\r\n    id;\r\n    textures;\r\n    constructor(id, textures) {\r\n        this.id = id;\r\n        ConstructorHooks.texturesRegistered.addToRun((textureManager) => {\r\n            this.textures = [\r\n                textureManager.getTextureUV(textures.top),\r\n                textureManager.getTextureUV(textures.bottom),\r\n                textureManager.getTextureUV(textures.sideMiddle),\r\n                textureManager.getTextureUV(textures.sideBottom),\r\n                textureManager.getTextureUV(textures.sideTop),\r\n                textureManager.getTextureUV(textures.sideFloat),\r\n            ];\r\n        });\r\n    }\r\n    process(templater) {\r\n        const topCheck = templater.currentVoxel.isSameVoxel(templater.currentVoxel.x, templater.currentVoxel.y + 1, templater.currentVoxel.z);\r\n        const bottomCheck = templater.currentVoxel.isSameVoxel(templater.currentVoxel.x, templater.currentVoxel.y, templater.currentVoxel.z);\r\n        let side = -1;\r\n        determineText: if (side) {\r\n            if (topCheck && bottomCheck) {\r\n                side = this.textures[2];\r\n                break determineText;\r\n            }\r\n            if (topCheck && !bottomCheck) {\r\n                side = this.textures[3];\r\n                break determineText;\r\n            }\r\n            if (!topCheck && bottomCheck) {\r\n                side = this.textures[4];\r\n                break determineText;\r\n            }\r\n            if (!topCheck && !bottomCheck) {\r\n                side = this.textures[5];\r\n                break determineText;\r\n            }\r\n            side = 0;\r\n        }\r\n        if (templater.isFaceExpposed(\"top\")) {\r\n            templater.addUV(this.textures[0]).addOverlayUVs([0]);\r\n        }\r\n        if (templater.isFaceExpposed(\"bottom\")) {\r\n            templater.addUV(this.textures[1]).addOverlayUVs([0]);\r\n        }\r\n        if (templater.isFaceExpposed(\"east\")) {\r\n            templater.addUV(side).addOverlayUVs([0]);\r\n        }\r\n        if (templater.isFaceExpposed(\"west\")) {\r\n            templater.addUV(side).addOverlayUVs([0]);\r\n        }\r\n        if (templater.isFaceExpposed(\"south\")) {\r\n            templater.addUV(side).addOverlayUVs([0]);\r\n        }\r\n        if (templater.isFaceExpposed(\"north\")) {\r\n            templater.addUV(side).addOverlayUVs([0]);\r\n        }\r\n        templater.processVoxelLight();\r\n    }\r\n}\r\n","import { ConstructorHooks } from \"../../../../Hooks/ConstructorHooks.js\";\r\nexport class LiquidVoxelConstructor {\r\n    id;\r\n    textures;\r\n    ignoreAO = true;\r\n    constructor(id, textures) {\r\n        this.id = id;\r\n        ConstructorHooks.texturesRegistered.addToRun((textureManager) => {\r\n            this.textures = [\r\n                textureManager.getTextureUV(textures[0]),\r\n                textureManager.getTextureUV(textures[1]),\r\n            ];\r\n        });\r\n    }\r\n    process(templater) {\r\n        const [still, flowing] = this.textures;\r\n        if (templater.isFaceExpposed(\"top\")) {\r\n            templater.addUV(still).addOverlayUVs([0]);\r\n        }\r\n        if (templater.isFaceExpposed(\"bottom\")) {\r\n            templater.addUV(still).addOverlayUVs([0]);\r\n        }\r\n        if (templater.isFaceExpposed(\"east\")) {\r\n            templater.addUV(flowing).addOverlayUVs([0]);\r\n        }\r\n        if (templater.isFaceExpposed(\"west\")) {\r\n            templater.addUV(flowing).addOverlayUVs([0]);\r\n        }\r\n        if (templater.isFaceExpposed(\"south\")) {\r\n            templater.addUV(flowing).addOverlayUVs([0]);\r\n        }\r\n        if (templater.isFaceExpposed(\"north\")) {\r\n            templater.addUV(flowing).addOverlayUVs([0]);\r\n        }\r\n        templater.processVoxelLight(this.ignoreAO);\r\n    }\r\n}\r\n","import { ConstructorHooks } from \"../../../../Hooks/ConstructorHooks.js\";\r\nexport class PanelVoxelConstructor {\r\n    id;\r\n    texture = 0;\r\n    constructor(id, textures) {\r\n        this.id = id;\r\n        ConstructorHooks.texturesRegistered.addToRun((textureManager) => {\r\n            this.texture = textureManager.getTextureUV(textures);\r\n        });\r\n    }\r\n    process(templater) {\r\n        templater\r\n            .addUV(this.texture, 2)\r\n            .addOverlayUVs([0], 2)\r\n            .addCurrentLightValue(2)\r\n            .addAOValue(1, 2);\r\n    }\r\n}\r\n","import { QuadBuilder } from \"./Quad/QuadBuilder.js\";\r\nimport { QuadUVs } from \"./Quad/QuadUVs.js\";\r\nexport const GeometryBuilder = {\r\n    data: {},\r\n    quads: {\r\n        builder: QuadBuilder,\r\n        uvs: QuadUVs,\r\n    },\r\n    setData(data) {\r\n        this.data = data;\r\n    },\r\n    clearData() {\r\n        this.data = null;\r\n    },\r\n    createQuad(directon, dimensions, origion, flip = false, transforms) {\r\n        QuadBuilder.create(directon, origion, dimensions, this.data, flip, transforms);\r\n    },\r\n};\r\n","const defaultTransform = {\r\n    1: { x: 0, y: 0, z: 0 },\r\n    2: { x: 0, y: 0, z: 0 },\r\n    3: { x: 0, y: 0, z: 0 },\r\n    4: { x: 0, y: 0, z: 0 },\r\n};\r\nconst qDimensinos = {\r\n    width: 0,\r\n    height: 0,\r\n};\r\nexport const QuadBuilder = {\r\n    faceFunctions: {\r\n        top: (origin, data, transform, flip) => {\r\n            if (!flip) {\r\n                data.positions.push(\r\n                //v1\r\n                origin.x - qDimensinos.width + transform[1].x, origin.y + transform[1].y, origin.z - qDimensinos.height + transform[1].z, \r\n                //v2\r\n                origin.x - qDimensinos.width + transform[2].x, origin.y + transform[2].y, origin.z + qDimensinos.height + transform[2].z, \r\n                //v3\r\n                origin.x + qDimensinos.width + transform[3].x, origin.y + transform[3].y, origin.z + qDimensinos.height + transform[3].z, \r\n                //v4\r\n                origin.x + qDimensinos.width + transform[4].x, origin.y + transform[4].y, origin.z - qDimensinos.height + transform[4].z);\r\n            }\r\n            else {\r\n                data.positions.push(\r\n                //v1\r\n                origin.x + qDimensinos.width + transform[4].x, origin.y + transform[4].y, origin.z - qDimensinos.height + transform[4].z, \r\n                //v2\r\n                origin.x - qDimensinos.width + transform[1].x, origin.y + transform[1].y, origin.z - qDimensinos.height + transform[1].z, \r\n                //v3\r\n                origin.x - qDimensinos.width + transform[2].x, origin.y + transform[2].y, origin.z + qDimensinos.height + transform[2].z, \r\n                //v4\r\n                origin.x + qDimensinos.width + transform[3].x, origin.y + transform[3].y, origin.z + qDimensinos.height + transform[3].z);\r\n            }\r\n            data.indices.push(data.indicieIndex + 3, data.indicieIndex + 2, data.indicieIndex, data.indicieIndex + 2, data.indicieIndex + 1, data.indicieIndex);\r\n            data.normals.push(0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0);\r\n            data.indicieIndex += 4;\r\n        },\r\n        bottom: (origin, data, transform, flip) => {\r\n            if (!flip) {\r\n                data.positions.push(\r\n                //v1\r\n                origin.x - qDimensinos.width + transform[1].x, origin.y + transform[1].y, origin.z - qDimensinos.height + transform[1].z, \r\n                //v2\r\n                origin.x + qDimensinos.width + transform[2].x, origin.y + transform[2].y, origin.z - qDimensinos.height + transform[2].z, \r\n                //v3\r\n                origin.x + qDimensinos.width + transform[3].x, origin.y + transform[3].y, origin.z + qDimensinos.height + transform[3].z, \r\n                //v4\r\n                origin.x - qDimensinos.width + transform[4].x, origin.y + transform[4].y, origin.z + qDimensinos.height + transform[4].z);\r\n            }\r\n            else {\r\n                data.positions.push(\r\n                //v1\r\n                origin.x - qDimensinos.width + transform[4].x, origin.y + transform[4].y, origin.z + qDimensinos.height + transform[4].z, \r\n                //v2\r\n                origin.x - qDimensinos.width + transform[1].x, origin.y + transform[1].y, origin.z - qDimensinos.height + transform[1].z, \r\n                //v3\r\n                origin.x + qDimensinos.width + transform[2].x, origin.y + transform[2].y, origin.z - qDimensinos.height + transform[2].z, \r\n                //v4\r\n                origin.x + qDimensinos.width + transform[3].x, origin.y + transform[3].y, origin.z + qDimensinos.height + transform[3].z);\r\n            }\r\n            data.indices.push(data.indicieIndex + 2, data.indicieIndex + 1, data.indicieIndex, data.indicieIndex + 3, data.indicieIndex + 2, data.indicieIndex);\r\n            data.normals.push(0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0);\r\n            data.indicieIndex += 4;\r\n        },\r\n        //front\r\n        south: (origin, data, transform, flip) => {\r\n            if (!flip) {\r\n                data.positions.push(\r\n                //v1\r\n                origin.x - qDimensinos.width + transform[1].x, origin.y + qDimensinos.height + transform[1].y, origin.z + transform[1].z, \r\n                //v2\r\n                origin.x + qDimensinos.width + transform[2].x, origin.y + qDimensinos.height + transform[2].y, origin.z + transform[2].z, \r\n                //v3\r\n                origin.x + qDimensinos.width + transform[3].x, origin.y - qDimensinos.height + transform[3].y, origin.z + transform[3].z, \r\n                //v4\r\n                origin.x - qDimensinos.width + transform[4].x, origin.y - qDimensinos.height + transform[4].y, origin.z + transform[4].z);\r\n            }\r\n            else {\r\n                data.positions.push(\r\n                //v1\r\n                origin.x - qDimensinos.width + transform[4].x, origin.y - qDimensinos.height + transform[4].y, origin.z + transform[4].z, \r\n                //v2\r\n                origin.x - qDimensinos.width + transform[1].x, origin.y + qDimensinos.height + transform[1].y, origin.z + transform[1].z, \r\n                //v3\r\n                origin.x + qDimensinos.width + transform[2].x, origin.y + qDimensinos.height + transform[2].y, origin.z + transform[2].z, \r\n                //v4\r\n                origin.x + qDimensinos.width + transform[3].x, origin.y - qDimensinos.height + transform[3].y, origin.z + transform[3].z);\r\n            }\r\n            data.indices.push(data.indicieIndex + 2, data.indicieIndex + 1, data.indicieIndex, data.indicieIndex + 3, data.indicieIndex + 2, data.indicieIndex);\r\n            data.normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            data.indicieIndex += 4;\r\n        },\r\n        //back\r\n        north: (origin, data, transform, flip) => {\r\n            if (!flip) {\r\n                data.positions.push(\r\n                //v1\r\n                origin.x + qDimensinos.width + transform[1].x, origin.y + qDimensinos.height + transform[1].y, origin.z + transform[1].z, \r\n                //v2\r\n                origin.x - qDimensinos.width + transform[2].x, origin.y + qDimensinos.height + transform[2].y, origin.z + transform[2].z, \r\n                //v3\r\n                origin.x - qDimensinos.width + transform[3].x, origin.y - qDimensinos.height + transform[3].y, origin.z + transform[3].z, \r\n                //v4\r\n                origin.x + qDimensinos.width + transform[4].x, origin.y - qDimensinos.height + transform[4].y, origin.z + transform[4].z);\r\n            }\r\n            else {\r\n                data.positions.push(\r\n                //v1\r\n                origin.x + qDimensinos.width + transform[4].x, origin.y - qDimensinos.height + transform[4].y, origin.z + transform[4].z, \r\n                //v2\r\n                origin.x + qDimensinos.width + transform[1].x, origin.y + qDimensinos.height + transform[1].y, origin.z + transform[1].z, \r\n                //v3\r\n                origin.x - qDimensinos.width + transform[2].x, origin.y + qDimensinos.height + transform[2].y, origin.z + transform[2].z, \r\n                //v4\r\n                origin.x - qDimensinos.width + transform[3].x, origin.y - qDimensinos.height + transform[3].y, origin.z + transform[3].z);\r\n            }\r\n            data.indices.push(data.indicieIndex + 2, data.indicieIndex + 1, data.indicieIndex, data.indicieIndex + 3, data.indicieIndex + 2, data.indicieIndex);\r\n            data.normals.push(0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1);\r\n            data.indicieIndex += 4;\r\n        },\r\n        //left\r\n        west: (origin, data, transform, flip) => {\r\n            if (!flip) {\r\n                data.positions.push(\r\n                //v1\r\n                origin.x + transform[1].x, origin.y + qDimensinos.height + transform[1].y, origin.z + qDimensinos.width + transform[1].z, \r\n                //v2\r\n                origin.x + transform[2].x, origin.y + qDimensinos.height + transform[2].y, origin.z - qDimensinos.width + transform[2].z, \r\n                //v3\r\n                origin.x + transform[3].x, origin.y - qDimensinos.height + transform[3].y, origin.z - qDimensinos.width + +transform[3].z, \r\n                //v4\r\n                origin.x + transform[4].x, origin.y - qDimensinos.height + transform[4].y, origin.z + qDimensinos.width + transform[4].z);\r\n            }\r\n            else {\r\n                data.positions.push(\r\n                //v1\r\n                origin.x + transform[4].x, origin.y - qDimensinos.height + transform[4].y, origin.z + qDimensinos.width + transform[4].z, \r\n                //v2\r\n                origin.x + transform[1].x, origin.y + qDimensinos.height + transform[1].y, origin.z + qDimensinos.width + transform[1].z, \r\n                //v3\r\n                origin.x + transform[2].x, origin.y + qDimensinos.height + transform[2].y, origin.z - qDimensinos.width + transform[2].z, \r\n                //v4\r\n                origin.x + transform[3].x, origin.y - qDimensinos.height + transform[3].y, origin.z - qDimensinos.width + transform[3].z);\r\n            }\r\n            data.indices.push(data.indicieIndex + 2, data.indicieIndex + 1, data.indicieIndex, data.indicieIndex + 3, data.indicieIndex + 2, data.indicieIndex);\r\n            data.normals.push(-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0);\r\n            data.indicieIndex += 4;\r\n        },\r\n        //right\r\n        east: (origin, data, transform, flip) => {\r\n            if (!flip) {\r\n                data.positions.push(\r\n                //v1\r\n                origin.x + transform[1].x, origin.y + qDimensinos.height + transform[1].y, origin.z - qDimensinos.width + transform[1].z, \r\n                //v2\r\n                origin.x + transform[2].x, origin.y + qDimensinos.height + transform[2].y, origin.z + qDimensinos.width + transform[2].z, \r\n                //v3\r\n                origin.x + transform[3].x, origin.y - qDimensinos.height + transform[3].y, origin.z + qDimensinos.width + transform[3].z, \r\n                //v4\r\n                origin.x + transform[4].x, origin.y - qDimensinos.height + transform[4].y, origin.z - qDimensinos.width + transform[4].z);\r\n            }\r\n            else {\r\n                data.positions.push(\r\n                //v1\r\n                origin.x + transform[4].x, origin.y - qDimensinos.height + transform[4].y, origin.z - qDimensinos.width + transform[4].z, \r\n                //v2\r\n                origin.x + transform[1].x, origin.y + qDimensinos.height + transform[1].y, origin.z - qDimensinos.width + transform[1].z, \r\n                //v3\r\n                origin.x + transform[2].x, origin.y + qDimensinos.height + transform[2].y, origin.z + qDimensinos.width + transform[2].z, \r\n                //v4\r\n                origin.x + transform[3].x, origin.y - qDimensinos.height + transform[3].y, origin.z + qDimensinos.width + transform[3].z);\r\n            }\r\n            data.indices.push(data.indicieIndex + 2, data.indicieIndex + 1, data.indicieIndex, data.indicieIndex + 3, data.indicieIndex + 2, data.indicieIndex);\r\n            data.normals.push(1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0);\r\n            data.indicieIndex += 4;\r\n        },\r\n    },\r\n    create(direction, origin, dimensions, data, flip = false, transform = defaultTransform) {\r\n        qDimensinos.width = dimensions.width / 2;\r\n        qDimensinos.height = dimensions.height / 2;\r\n        this.faceFunctions[direction](origin, data, transform, flip);\r\n    },\r\n};\r\n","/**\r\n * |||||||||||||||||||||||||||||||||||||\r\n * [TOP & BOTTOM]\r\n * Not Flipped\r\n *\r\n * 2: w 0,h 0        3: w 1, h 0\r\n *          |--------|\r\n *          |      / |\r\n *          |   /    |\r\n *          |/       |\r\n *          |--------|\r\n * 1: w 0,h 1        4: w 1,h 1\r\n *\r\n * ===============================\r\n * Flipped\r\n *\r\n * 4: w 1,h 0        3: w 0, h 0\r\n *          |--------|\r\n *          |\\       |\r\n *          |   \\    |\r\n *          |      \\ |\r\n *          |--------|\r\n * 1: w 1,h 1        2: w 0, h 1\r\n *\r\n *||||||||||||||||||||||||||||||||||||||||\r\n * [Sides]\r\n * Not Flipped\r\n * 4: w 1,h 0        3: w 0, h 0\r\n *          |--------|\r\n *          |\\       |\r\n *          |   \\    |\r\n *          |      \\ |\r\n *          |--------|\r\n * 1: w 1,h 1        2: w 0, h 1\r\n *\r\n * ===============================\r\n * Flipped\r\n * 2: w 0,h 0        3: w 1, h 0\r\n *          |--------|\r\n *          |      / |\r\n *          |   /    |\r\n *          |/       |\r\n *          |--------|\r\n * 1: w 0,h 1        4: w 1,h 1\r\n *\r\n */\r\nexport const QuadUVs = {\r\n    uvRotations: {\r\n        top: {\r\n            0: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(ws, he, uv, ws, hs, uv, we, hs, uv, we, he, uv);\r\n                }\r\n                else {\r\n                    uvs.push(we, he, uv, ws, he, uv, ws, hs, uv, we, hs, uv);\r\n                }\r\n            },\r\n            45: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(0.5, 1, uv, 1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv);\r\n                }\r\n                else {\r\n                    uvs.push(0, 0.5, uv, 0.5, 1, uv, 1, 0.5, uv, 0.5, 0, uv);\r\n                }\r\n            },\r\n            //-45\r\n            315: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv, 0.5, 1, uv);\r\n                }\r\n                else {\r\n                    uvs.push(0.5, 1, uv, 1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv);\r\n                }\r\n            },\r\n            90: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(we, he, uv, ws, he, uv, ws, hs, uv, we, hs, uv);\r\n                }\r\n                else {\r\n                    uvs.push(we, hs, uv, we, he, uv, ws, he, uv, ws, hs, uv);\r\n                }\r\n            },\r\n            180: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(we, hs, uv, we, he, uv, ws, he, uv, ws, hs, uv);\r\n                }\r\n                else {\r\n                    uvs.push(ws, hs, uv, we, hs, uv, we, he, uv, ws, he, uv);\r\n                }\r\n            },\r\n            270: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(ws, hs, uv, we, hs, uv, we, he, uv, ws, he, uv);\r\n                }\r\n                else {\r\n                    uvs.push(ws, he, uv, ws, hs, uv, we, hs, uv, we, he, uv);\r\n                }\r\n            },\r\n            360: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(he, we, uv, he, ws, uv, hs, ws, uv, hs, we, uv);\r\n                }\r\n                else {\r\n                    uvs.push(hs, we, uv, he, we, uv, he, ws, uv, hs, ws, uv);\r\n                }\r\n            },\r\n        },\r\n        bottom: {\r\n            0: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(ws, hs, uv, we, hs, uv, we, he, uv, ws, he, uv);\r\n                }\r\n                else {\r\n                    uvs.push(ws, he, uv, ws, hs, uv, we, hs, uv, we, he, uv);\r\n                }\r\n            },\r\n            90: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(ws, he, uv, ws, hs, uv, we, hs, uv, we, he, uv);\r\n                }\r\n                else {\r\n                    uvs.push(we, he, uv, ws, he, uv, ws, hs, uv, we, hs, uv);\r\n                }\r\n            },\r\n            45: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(0.5, 1, uv, 1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv);\r\n                }\r\n                else {\r\n                    uvs.push(0.5, 1, uv, 1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv);\r\n                }\r\n            },\r\n            //-45\r\n            315: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv, 0.5, 1, uv);\r\n                }\r\n                else {\r\n                    uvs.push(1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv, 0.5, 1, uv);\r\n                }\r\n            },\r\n            180: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(we, he, uv, ws, he, uv, ws, hs, uv, we, hs, uv);\r\n                }\r\n                else {\r\n                    uvs.push(we, hs, uv, we, he, uv, ws, he, uv, ws, hs, uv);\r\n                }\r\n            },\r\n            270: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(we, hs, uv, we, he, uv, ws, he, uv, ws, hs, uv);\r\n                }\r\n                else {\r\n                    uvs.push(ws, hs, uv, we, hs, uv, we, he, uv, ws, he, uv);\r\n                }\r\n            },\r\n            360: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(he, ws, uv, hs, hs, uv, hs, we, uv, he, we, uv);\r\n                }\r\n                else {\r\n                    uvs.push(he, we, uv, he, ws, uv, hs, ws, uv, hs, we, uv);\r\n                }\r\n            },\r\n        },\r\n        side: {\r\n            0: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(ws, hs, uv, we, hs, uv, we, he, uv, ws, he, uv);\r\n                }\r\n                else {\r\n                    uvs.push(ws, he, uv, ws, hs, uv, we, hs, uv, we, he, uv);\r\n                }\r\n            },\r\n            90: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(ws, he, uv, ws, hs, uv, we, hs, uv, we, he, uv);\r\n                }\r\n                else {\r\n                    uvs.push(we, he, uv, ws, he, uv, ws, hs, uv, we, hs, uv);\r\n                }\r\n            },\r\n            45: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(0.5, 1, uv, 1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv);\r\n                }\r\n                else {\r\n                    uvs.push(0.5, 1, uv, 1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv);\r\n                }\r\n            },\r\n            //-45\r\n            315: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv, 0.5, 1, uv);\r\n                }\r\n                else {\r\n                    uvs.push(1, 0.5, uv, 0.5, 0, uv, 0, 0.5, uv, 0.5, 1, uv);\r\n                }\r\n            },\r\n            180: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(we, he, uv, ws, he, uv, ws, hs, uv, we, hs, uv);\r\n                }\r\n                else {\r\n                    uvs.push(we, hs, uv, we, he, uv, ws, he, uv, ws, hs, uv);\r\n                }\r\n            },\r\n            270: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(we, hs, uv, we, he, uv, ws, he, uv, ws, hs, uv);\r\n                }\r\n                else {\r\n                    uvs.push(ws, hs, uv, we, hs, uv, we, he, uv, ws, he, uv);\r\n                }\r\n            },\r\n            360: (uv, ws, we, hs, he, flipped, uvs) => {\r\n                if (!flipped) {\r\n                    uvs.push(he, ws, uv, hs, ws, uv, hs, we, uv, he, we, uv);\r\n                }\r\n                else {\r\n                    uvs.push(he, we, uv, he, ws, uv, hs, ws, uv, hs, we, uv);\r\n                }\r\n            },\r\n        },\r\n    },\r\n    advancedUVs: {\r\n        top: (uv, data, uvs, flipped = false) => {\r\n            if (!flipped) {\r\n                uvs.push(data.ws1, data.he1, uv, data.ws2, data.hs1, uv, data.we1, data.hs2, uv, data.we2, data.he2, uv);\r\n            }\r\n            else {\r\n                uvs.push(data.ws1, data.he1, uv, data.ws2, data.hs1, uv, data.we1, data.hs2, uv, data.we2, data.he2, uv);\r\n            }\r\n        },\r\n        side: (uv, data, uvs, flipped = false) => {\r\n            if (!flipped) {\r\n                uvs.push(data.ws1, data.hs1, uv, data.we1, data.hs2, uv, data.we2, data.he1, uv, data.ws2, data.he2, uv);\r\n                return;\r\n            }\r\n            else {\r\n                uvs.push(data.ws2, data.he2, uv, data.ws1, data.hs1, uv, data.we1, data.hs2, uv, data.we2, data.he1, uv);\r\n            }\r\n        },\r\n    },\r\n    uvFunctions: {\r\n        top: (data) => {\r\n            QuadUVs.uvRotations.top[data.rotoate](data.uv, data.width.start, data.width.end, data.height.start, data.height.end, data.flipped, data.uvs);\r\n        },\r\n        bottom: (data) => {\r\n            QuadUVs.uvRotations.bottom[data.rotoate](data.uv, data.width.start, data.width.end, data.height.start, data.height.end, data.flipped, data.uvs);\r\n        },\r\n        north: (data) => {\r\n            QuadUVs.uvRotations.side[data.rotoate](data.uv, data.width.start, data.width.end, data.height.start, data.height.end, data.flipped, data.uvs);\r\n        },\r\n        south: (data) => {\r\n            QuadUVs.uvRotations.side[data.rotoate](data.uv, data.width.start, data.width.end, data.height.start, data.height.end, data.flipped, data.uvs);\r\n        },\r\n        east: (data) => {\r\n            QuadUVs.uvRotations.side[data.rotoate](data.uv, data.width.start, data.width.end, data.height.start, data.height.end, data.flipped, data.uvs);\r\n        },\r\n        west: (data) => {\r\n            QuadUVs.uvRotations.side[data.rotoate](data.uv, data.width.start, data.width.end, data.height.start, data.height.end, data.flipped, data.uvs);\r\n        },\r\n    },\r\n    addUVs(face, data) {\r\n        this.uvFunctions[face](data);\r\n    },\r\n    addAdvancedUVs(direction, uv, uvs, data, flipped = false) {\r\n        let d = \"top\";\r\n        if (direction != \"top\") {\r\n            d = \"side\";\r\n        }\r\n        this.advancedUVs[d](uv, data, uvs, flipped);\r\n    },\r\n    processOverlayUVs(data) {\r\n        let k = data.overylayUVTemplateIndex;\r\n        let i = 4;\r\n        while (i--) {\r\n            data.overlayUVs.push(data.overylayUVTemplate[k], data.overylayUVTemplate[k + 1], data.overylayUVTemplate[k + 2], data.overylayUVTemplate[k + 3]);\r\n        }\r\n    },\r\n};\r\n","import { RegisterDefaultShapes } from \"../Shapes/default/RegisterDefaultShapes.js\";\r\nexport function InitBuilder(DVEB) {\r\n    DVEB.processor.$INIT();\r\n    DVEB.substanceRules.$INIT();\r\n    RegisterDefaultShapes(DVEB);\r\n}\r\n","//types\r\n//objects\r\nimport { DVEC } from \"../../DivineVoxelEngineConstructor.js\";\r\nimport { VoxelMesher } from \"../Tools/VoxelMesher.js\";\r\nexport const ChunkMesher = {\r\n    voxelBuildOrder: [\r\n        \"#dve_solid\",\r\n        \"#dve_flora\",\r\n        \"#dve_liquid\",\r\n        \"#dve_magma\",\r\n    ],\r\n    buildChunkMesh(location, template, LOD = 1) {\r\n        let i = this.voxelBuildOrder.length;\r\n        const chunks = [location, []];\r\n        const trasnfers = [];\r\n        for (const key of this.voxelBuildOrder) {\r\n            const baseTemplate = template[key];\r\n            if (!baseTemplate) {\r\n                chunks[1].push([key, false]);\r\n                continue;\r\n            }\r\n            const meshData = VoxelMesher.$buildMesh(key, baseTemplate, LOD, location);\r\n            if (!meshData)\r\n                return;\r\n            chunks[1].push([\r\n                key,\r\n                //@ts-ignore\r\n                ...meshData[0],\r\n            ]);\r\n            trasnfers.push(...meshData[1]);\r\n        }\r\n        DVEC.parentComm.runTasks(\"set-chunk\", chunks, trasnfers);\r\n    },\r\n};\r\n","const checkSets = {\r\n    1: [\r\n        -1, 0, 0, -1,\r\n        //corner\r\n        -1, -1,\r\n    ],\r\n    2: [\r\n        -1, 0, 0, 1,\r\n        //corner\r\n        -1, 1,\r\n    ],\r\n    3: [\r\n        1, 0, 0, 1,\r\n        //corner\r\n        1, 1,\r\n    ],\r\n    4: [\r\n        1, 0, 0, -1,\r\n        //corner\r\n        1, -1,\r\n    ],\r\n};\r\nlet currentId = \"\";\r\nconst flowStates = {\r\n    1: 0,\r\n    2: 0,\r\n    3: 0,\r\n    4: 0,\r\n};\r\nexport function CalculateFlow(faceFlipped, x, y, z, flowTemplate) {\r\n    currentId = this.mDataTool.getStringId();\r\n    const currentLevel = this.mDataTool.getLevel();\r\n    const state = this.mDataTool.getLevelState();\r\n    //flowTemplate.push(state);\r\n    calculateFlowV(this, state, currentLevel, 1, x, y, z);\r\n    calculateFlowV(this, state, currentLevel, 2, x, y, z);\r\n    calculateFlowV(this, state, currentLevel, 3, x, y, z);\r\n    calculateFlowV(this, state, currentLevel, 4, x, y, z);\r\n    flowTemplate.push(flowStates[1], flowStates[2], flowStates[3], flowStates[4]);\r\n}\r\nconst getLevel = (process) => {\r\n    if (!process.nDataTool.isRenderable())\r\n        return -1;\r\n    if (process.nDataTool.getStringId() != currentId)\r\n        return -1;\r\n    const level = process.nDataTool.getLevel();\r\n    return level;\r\n};\r\nconst getState = (process) => {\r\n    if (!process.nDataTool.isRenderable())\r\n        return -1;\r\n    if (process.nDataTool.getStringId() != currentId)\r\n        return -1;\r\n    const state = process.nDataTool.getLevelState();\r\n    return state;\r\n};\r\nconst calculateFlowV = (process, cs, cl, vertex, x, y, z) => {\r\n    const checkSet = checkSets[vertex];\r\n    if (cl == 15 && cs != 1) {\r\n        flowStates[vertex] = 15;\r\n        return;\r\n    }\r\n    let finalLevel = cl;\r\n    let voxelCount = 0;\r\n    let zeroCount = 0;\r\n    let totalZero = true;\r\n    let ovveride = false;\r\n    let totalLevel = 0;\r\n    for (let iy = 0; iy < 2; iy++) {\r\n        for (let i = 0; i < 6; i += 2) {\r\n            const cx = checkSet[i] + x;\r\n            const cz = checkSet[i + 1] + z;\r\n            const loadedIn = process.nDataTool.loadInAt(cx, y + iy, cz);\r\n            if (!loadedIn)\r\n                continue;\r\n            const level = getLevel(process);\r\n            const hasVoxel = process.nDataTool.isRenderable();\r\n            if (hasVoxel && process.nDataTool.getSubstance() == \"#dve_solid\") {\r\n                voxelCount++;\r\n            }\r\n            if (iy == 1) {\r\n                if (level > 0) {\r\n                    finalLevel = 15;\r\n                    totalZero = false;\r\n                    ovveride = true;\r\n                    totalLevel += level;\r\n                }\r\n            }\r\n            if (level <= 0 && !hasVoxel) {\r\n                if (iy == 0) {\r\n                    zeroCount++;\r\n                }\r\n                continue;\r\n            }\r\n            if (level == 15) {\r\n                finalLevel = 15;\r\n                totalZero = false;\r\n                zeroCount = 0;\r\n                break;\r\n            }\r\n            if (level > 0 && !hasVoxel) {\r\n                totalZero = false;\r\n            }\r\n            if (finalLevel < level) {\r\n                finalLevel += level - finalLevel;\r\n            }\r\n        }\r\n    }\r\n    if (ovveride && totalLevel == 1 && voxelCount == 3) {\r\n        finalLevel = cl;\r\n    }\r\n    if (zeroCount >= 1 && cs == 0 && !ovveride) {\r\n        finalLevel = 0;\r\n    }\r\n    if (totalZero && cs == 1 && cl == 15) {\r\n        finalLevel = 7;\r\n    }\r\n    if (finalLevel > 15)\r\n        finalLevel = 15;\r\n    if (finalLevel < 1)\r\n        finalLevel = 1;\r\n    flowStates[vertex] = finalLevel;\r\n};\r\n","import { Processor } from \"../Processor.js\";\r\nimport { $3dCardinalNeighbors } from \"../../../../Data/Constants/Util/CardinalNeighbors.js\";\r\nimport { FaceMap } from \"../../../../Data/Constants/Util/Faces.js\";\r\nimport { LightData } from \"../../../../Data/Light/LightByte.js\";\r\nimport { OverrideManager } from \"../../Rules/Overrides/OverridesManager.js\";\r\nconst LD = LightData;\r\nconst RGBvertexStates = {\r\n    1: {\r\n        totalZero: false,\r\n        value: 0,\r\n    },\r\n    2: {\r\n        totalZero: false,\r\n        value: 0,\r\n    },\r\n    3: {\r\n        totalZero: false,\r\n        value: 0,\r\n    },\r\n    4: {\r\n        totalZero: false,\r\n        value: 0,\r\n    },\r\n};\r\nconst sunVertexStates = {\r\n    1: {\r\n        totalZero: false,\r\n        value: 0,\r\n    },\r\n    2: {\r\n        totalZero: false,\r\n        value: 0,\r\n    },\r\n    3: {\r\n        totalZero: false,\r\n        value: 0,\r\n    },\r\n    4: {\r\n        totalZero: false,\r\n        value: 0,\r\n    },\r\n};\r\nconst AOVerotexStates = {\r\n    1: {\r\n        totalLight: false,\r\n        value: 1,\r\n    },\r\n    2: {\r\n        totalLight: false,\r\n        value: 1,\r\n    },\r\n    3: {\r\n        totalLight: false,\r\n        value: 1,\r\n    },\r\n    4: {\r\n        totalLight: false,\r\n        value: 1,\r\n    },\r\n};\r\nconst swapSun = () => {\r\n    let v1 = LD.getS(RGBvertexStates[1].value);\r\n    let v2 = LD.getS(RGBvertexStates[2].value);\r\n    let v3 = LD.getS(RGBvertexStates[3].value);\r\n    let v4 = LD.getS(RGBvertexStates[4].value);\r\n    RGBvertexStates[1].value = LD.setS(v1, RGBvertexStates[1].value);\r\n    RGBvertexStates[2].value = LD.setS(v4, RGBvertexStates[2].value);\r\n    RGBvertexStates[3].value = LD.setS(v3, RGBvertexStates[3].value);\r\n    RGBvertexStates[4].value = LD.setS(v2, RGBvertexStates[4].value);\r\n};\r\nconst swapRGB = () => {\r\n    let v1 = LD.getRGB(RGBvertexStates[1].value);\r\n    let v2 = LD.getRGB(RGBvertexStates[2].value);\r\n    let v3 = LD.getRGB(RGBvertexStates[3].value);\r\n    let v4 = LD.getRGB(RGBvertexStates[4].value);\r\n    RGBvertexStates[2].value = LD.setRGB(v4, RGBvertexStates[2].value);\r\n    RGBvertexStates[1].value = LD.setRGB(v1, RGBvertexStates[1].value);\r\n    RGBvertexStates[4].value = LD.setRGB(v2, RGBvertexStates[4].value);\r\n    RGBvertexStates[3].value = LD.setRGB(v3, RGBvertexStates[3].value);\r\n};\r\nconst swapAO = () => {\r\n    let v1 = AOVerotexStates[1].value;\r\n    let v2 = AOVerotexStates[2].value;\r\n    let v3 = AOVerotexStates[3].value;\r\n    let v4 = AOVerotexStates[4].value;\r\n    AOVerotexStates[1].value = v1;\r\n    AOVerotexStates[2].value = v2;\r\n    AOVerotexStates[3].value = v3;\r\n    AOVerotexStates[4].value = v4;\r\n};\r\nconst shouldRGBFlip = () => {\r\n    let t1 = !RGBvertexStates[1].totalZero &&\r\n        RGBvertexStates[2].totalZero &&\r\n        RGBvertexStates[3].totalZero &&\r\n        RGBvertexStates[4].totalZero;\r\n    let t2 = RGBvertexStates[1].totalZero &&\r\n        RGBvertexStates[2].totalZero &&\r\n        !RGBvertexStates[3].totalZero &&\r\n        RGBvertexStates[4].totalZero;\r\n    let t3 = !RGBvertexStates[1].totalZero &&\r\n        RGBvertexStates[2].totalZero &&\r\n        !RGBvertexStates[3].totalZero &&\r\n        RGBvertexStates[4].totalZero;\r\n    return t1 || t2 || t3;\r\n};\r\nconst shouldSunFlip = () => {\r\n    if (Processor.settings.ignoreSun)\r\n        return false;\r\n    let t1 = !sunVertexStates[1].totalZero &&\r\n        sunVertexStates[2].totalZero &&\r\n        sunVertexStates[3].totalZero &&\r\n        sunVertexStates[4].totalZero;\r\n    let t2 = sunVertexStates[1].totalZero &&\r\n        sunVertexStates[2].totalZero &&\r\n        !sunVertexStates[3].totalZero &&\r\n        sunVertexStates[4].totalZero;\r\n    let t3 = !sunVertexStates[1].totalZero &&\r\n        sunVertexStates[2].totalZero &&\r\n        !sunVertexStates[3].totalZero &&\r\n        sunVertexStates[4].totalZero;\r\n    return t1 || t2 || t3;\r\n};\r\nconst shouldAOFlip = (face) => {\r\n    Processor.faceDataOverride.face = face;\r\n    Processor.faceDataOverride.default = false;\r\n    if (currentVoxelData.currentShape) {\r\n        if (OverrideManager.runOverride(\"AOFlipFace\", currentVoxelData.currentShape.id, \"Any\", Processor.faceDataOverride)) {\r\n            return false;\r\n        }\r\n    }\r\n    let check = false;\r\n    if (!states.ignoreAO) {\r\n        let t1 = !AOVerotexStates[1].totalLight &&\r\n            AOVerotexStates[2].totalLight &&\r\n            AOVerotexStates[3].totalLight &&\r\n            AOVerotexStates[4].totalLight;\r\n        let t2 = AOVerotexStates[1].totalLight &&\r\n            AOVerotexStates[2].totalLight &&\r\n            !AOVerotexStates[3].totalLight &&\r\n            AOVerotexStates[4].totalLight;\r\n        let t3 = !AOVerotexStates[1].totalLight &&\r\n            AOVerotexStates[2].totalLight &&\r\n            !AOVerotexStates[3].totalLight &&\r\n            AOVerotexStates[4].totalLight;\r\n        check = t1 || t2 || t3;\r\n    }\r\n    return check;\r\n};\r\nconst flipCheck = (face) => {\r\n    const rgbFlip = shouldRGBFlip();\r\n    const sunFlip = shouldSunFlip();\r\n    if (rgbFlip && !sunFlip) {\r\n        swapSun();\r\n    }\r\n    if (!rgbFlip && sunFlip) {\r\n        swapRGB();\r\n    }\r\n    const aoFlip = shouldAOFlip(face);\r\n    if ((sunFlip || rgbFlip) && !aoFlip) {\r\n        swapAO();\r\n    }\r\n    if (!sunFlip && aoFlip) {\r\n        swapSun();\r\n    }\r\n    if (!rgbFlip && aoFlip) {\r\n        swapRGB();\r\n    }\r\n    return rgbFlip || sunFlip || aoFlip;\r\n};\r\nconst handleAdd = (data, face, direction) => {\r\n    if (flipCheck(direction)) {\r\n        Processor.faceStates[face] = 1;\r\n        data.lightTemplate.push(RGBvertexStates[2].value, RGBvertexStates[1].value, RGBvertexStates[4].value, RGBvertexStates[3].value);\r\n        if (!states.ignoreAO) {\r\n            data.aoTemplate.push(AOVerotexStates[4].value, AOVerotexStates[1].value, AOVerotexStates[2].value, AOVerotexStates[3].value);\r\n        }\r\n    }\r\n    else {\r\n        data.lightTemplate.push(RGBvertexStates[1].value, RGBvertexStates[2].value, RGBvertexStates[3].value, RGBvertexStates[4].value);\r\n        if (!states.ignoreAO) {\r\n            data.aoTemplate.push(AOVerotexStates[1].value, AOVerotexStates[2].value, AOVerotexStates[3].value, AOVerotexStates[4].value);\r\n        }\r\n    }\r\n};\r\nconst checkSets = {\r\n    top: {\r\n        1: [-1, 1, 0, 0, 1, -1, -1, 1, -1],\r\n        2: [-1, 1, 0, 0, 1, 1, -1, 1, 1],\r\n        3: [1, 1, 0, 0, 1, 1, 1, 1, 1],\r\n        4: [1, 1, 0, 0, 1, -1, 1, 1, -1],\r\n    },\r\n    bottom: {\r\n        1: [0, -1, -1, -1, -1, 0, -1, -1, -1],\r\n        2: [0, -1, -1, 1, -1, 0, 1, -1, -1],\r\n        3: [0, -1, 1, 1, -1, 0, 1, -1, 1],\r\n        4: [0, -1, 1, -1, -1, 0, -1, -1, 1],\r\n    },\r\n    east: {\r\n        1: [1, 0, -1, 1, 1, 0, 1, 1, -1],\r\n        2: [1, 0, 1, 1, 1, 0, 1, 1, 1],\r\n        3: [1, 0, 1, 1, -1, 0, 1, -1, 1],\r\n        4: [1, 0, -1, 1, -1, 0, 1, -1, -1],\r\n    },\r\n    west: {\r\n        1: [-1, 0, 1, -1, 1, 0, -1, 1, 1],\r\n        2: [-1, 0, -1, -1, 1, 0, -1, 1, -1],\r\n        3: [-1, 0, -1, -1, -1, 0, -1, -1, -1],\r\n        4: [-1, 0, 1, -1, -1, 0, -1, -1, 1],\r\n    },\r\n    south: {\r\n        1: [-1, 0, -1, 0, 1, -1, -1, 1, -1],\r\n        2: [1, 0, -1, 0, 1, -1, 1, 1, -1],\r\n        3: [1, 0, -1, 0, -1, -1, 1, -1, -1],\r\n        4: [-1, 0, -1, 0, -1, -1, -1, -1, -1],\r\n    },\r\n    north: {\r\n        1: [1, 0, 1, 0, 1, 1, 1, 1, 1],\r\n        2: [-1, 0, 1, 0, 1, 1, -1, 1, 1],\r\n        3: [-1, 0, 1, 0, -1, 1, -1, -1, 1],\r\n        4: [1, 0, 1, 0, -1, 1, 1, -1, 1],\r\n    },\r\n};\r\nconst states = { ignoreAO: false };\r\nconst newRGBValues = [];\r\nconst zeroCheck = { s: 0, r: 0, g: 0, b: 0 };\r\nconst currentVoxelData = {\r\n    light: 0,\r\n    isLightSource: false,\r\n    voxelSubstance: \"#dve_solid\",\r\n    shapeState: 0,\r\n    currentShape: {},\r\n};\r\nconst RGBValues = { r: 0, g: 0, b: 0 };\r\nconst sunValues = { s: 0 };\r\nconst nlValues = { s: 0, r: 0, g: 0, b: 0 };\r\nconst AOValues = { a: 0 };\r\nexport function CalculateVoxelLight(data, tx, ty, tz, ignoreAO = false, LOD = 2) {\r\n    currentVoxelData.voxelSubstance = this.mDataTool.getSubstance();\r\n    currentVoxelData.isLightSource = this.mDataTool.isLightSource();\r\n    currentVoxelData.currentShape = this.mDataTool.getVoxelShapeObj();\r\n    currentVoxelData.shapeState = this.mDataTool.getShapeState();\r\n    if (this.settings.doAO && !ignoreAO) {\r\n        AOVerotexStates[1].value = 1;\r\n        AOVerotexStates[2].value = 1;\r\n        AOVerotexStates[3].value = 1;\r\n        AOVerotexStates[4].value = 1;\r\n        AOVerotexStates[1].totalLight = true;\r\n        AOVerotexStates[2].totalLight = true;\r\n        AOVerotexStates[3].totalLight = true;\r\n        AOVerotexStates[4].totalLight = true;\r\n        states.ignoreAO = false;\r\n    }\r\n    else {\r\n        states.ignoreAO = true;\r\n    }\r\n    const currentLight = this.mDataTool.getLight();\r\n    const max = $3dCardinalNeighbors.length;\r\n    for (let faceIndex = 0; faceIndex < max; faceIndex++) {\r\n        const point = $3dCardinalNeighbors[faceIndex];\r\n        if (Processor.exposedFaces[faceIndex]) {\r\n            this.nDataTool.loadInAt(point[0] + tx, point[1] + ty, point[2] + tz);\r\n            currentVoxelData.light = this.nDataTool.getLight();\r\n            if (currentVoxelData.light < 0) {\r\n                if (currentLight >= 0) {\r\n                    currentVoxelData.light = currentLight;\r\n                }\r\n                else {\r\n                    currentVoxelData.light = 0;\r\n                }\r\n            }\r\n            const face = FaceMap[faceIndex];\r\n            this.voxellightMixCalc(face, tx, ty, tz, checkSets[face][1], 1, LOD);\r\n            this.voxellightMixCalc(face, tx, ty, tz, checkSets[face][2], 2, LOD);\r\n            this.voxellightMixCalc(face, tx, ty, tz, checkSets[face][3], 3, LOD);\r\n            this.voxellightMixCalc(face, tx, ty, tz, checkSets[face][4], 4, LOD);\r\n            handleAdd(data, faceIndex, face);\r\n        }\r\n    }\r\n}\r\nconst doRGB = (neighborLightValue) => {\r\n    if (nlValues.r == 0)\r\n        zeroCheck.r++;\r\n    if (nlValues.g == 0)\r\n        zeroCheck.g++;\r\n    if (nlValues.b == 0)\r\n        zeroCheck.b++;\r\n    if (!neighborLightValue)\r\n        return;\r\n    if (nlValues.r > RGBValues.r && RGBValues.r < 15) {\r\n        RGBValues.r++;\r\n    }\r\n    if (nlValues.g > RGBValues.g && RGBValues.g < 15) {\r\n        RGBValues.g++;\r\n    }\r\n    if (nlValues.b > RGBValues.b && RGBValues.b < 15) {\r\n        RGBValues.b++;\r\n    }\r\n};\r\nconst doSun = (neighborLightValue) => {\r\n    if (nlValues.s == 0)\r\n        zeroCheck.s++;\r\n    if (!neighborLightValue)\r\n        return;\r\n    if (sunValues.s < nlValues.s && sunValues.s < 15) {\r\n        sunValues.s += LD.SRS;\r\n    }\r\n};\r\nconst lightEnd = (vertex) => {\r\n    let zeroTolerance = 2;\r\n    let totalZero = true;\r\n    if (zeroCheck.s >= zeroTolerance) {\r\n        sunVertexStates[vertex].totalZero = true;\r\n        newRGBValues[0] = 0;\r\n    }\r\n    else {\r\n        sunVertexStates[vertex].totalZero = false;\r\n        newRGBValues[0] = sunValues.s;\r\n    }\r\n    if (zeroCheck.r >= zeroTolerance) {\r\n        newRGBValues[1] = 0;\r\n    }\r\n    else {\r\n        totalZero = false;\r\n        newRGBValues[1] = RGBValues.r;\r\n    }\r\n    if (zeroCheck.g >= zeroTolerance) {\r\n        newRGBValues[2] = 0;\r\n    }\r\n    else {\r\n        totalZero = false;\r\n        newRGBValues[2] = RGBValues.g;\r\n    }\r\n    if (zeroCheck.b >= zeroTolerance) {\r\n        newRGBValues[3] = 0;\r\n    }\r\n    else {\r\n        totalZero = false;\r\n        newRGBValues[3] = RGBValues.b;\r\n    }\r\n    const returnValue = LD.setLightValues(newRGBValues);\r\n    RGBvertexStates[vertex].totalZero = totalZero;\r\n    RGBvertexStates[vertex].value = returnValue;\r\n    zeroCheck.s = 0;\r\n    zeroCheck.r = 0;\r\n    zeroCheck.b = 0;\r\n    zeroCheck.g = 0;\r\n};\r\nconst doAO = (face, vertex) => {\r\n    if (!Processor.nDataTool.isRenderable())\r\n        return;\r\n    const neighborVoxelSubstance = Processor.nDataTool.getSubstance();\r\n    let finalResult = false;\r\n    let substanceRuleResult = true;\r\n    const voxelSubstance = currentVoxelData.voxelSubstance;\r\n    if (voxelSubstance == \"#dve_transparent\" || voxelSubstance == \"#dve_solid\") {\r\n        if (neighborVoxelSubstance != \"#dve_solid\" &&\r\n            neighborVoxelSubstance != \"#dve_transparent\") {\r\n            substanceRuleResult = false;\r\n        }\r\n    }\r\n    else {\r\n        if (neighborVoxelSubstance !== voxelSubstance) {\r\n            substanceRuleResult = false;\r\n        }\r\n    }\r\n    const neightLightSource = Processor.nDataTool.isLightSource();\r\n    if (currentVoxelData.isLightSource || neightLightSource) {\r\n        substanceRuleResult = false;\r\n    }\r\n    Processor.faceDataOverride.face = face;\r\n    Processor.faceDataOverride.default = substanceRuleResult;\r\n    finalResult = OverrideManager.runOverride(\"AO\", currentVoxelData.currentShape.id, Processor.nDataTool.getVoxelShapeObj().id, Processor.faceDataOverride);\r\n    if (finalResult) {\r\n        AOVerotexStates[vertex].totalLight = false;\r\n        AOValues.a *= 0.65;\r\n    }\r\n};\r\nconst AOEnd = (vertex) => {\r\n    AOVerotexStates[vertex].value = AOValues.a;\r\n};\r\nexport function VoxelLightMixCalc(face, x, y, z, checkSet, vertex, LOD = 1) {\r\n    if (this.settings.doRGB || this.settings.doSun) {\r\n        const values = this.lightData.getLightValues(currentVoxelData.light);\r\n        if (this.settings.doSun) {\r\n            sunValues.s = values[0];\r\n            if (sunValues.s == 0)\r\n                zeroCheck.s++;\r\n        }\r\n        if (this.settings.doRGB) {\r\n            RGBValues.r = values[1];\r\n            if (RGBValues.r == 0)\r\n                zeroCheck.r++;\r\n            RGBValues.g = values[2];\r\n            if (RGBValues.g == 0)\r\n                zeroCheck.g++;\r\n            RGBValues.b = values[3];\r\n            if (RGBValues.b == 0)\r\n                zeroCheck.b++;\r\n        }\r\n    }\r\n    if (!states.ignoreAO) {\r\n        AOValues.a = 1;\r\n    }\r\n    for (let i = 0; i < 9; i += 3) {\r\n        const cx = checkSet[i] * LOD + x;\r\n        const cy = checkSet[i + 1] * LOD + y;\r\n        const cz = checkSet[i + 2] * LOD + z;\r\n        if (this.settings.doRGB || this.settings.doSun) {\r\n            if (!this.nDataTool.loadInAt(cx, cy, cz))\r\n                continue;\r\n            const nl = this.nDataTool.getLight();\r\n            if (nl != -1) {\r\n                const values = LD.getLightValues(nl);\r\n                nlValues.s = values[0];\r\n                nlValues.r = values[1];\r\n                nlValues.g = values[2];\r\n                nlValues.b = values[3];\r\n                if (this.settings.doRGB) {\r\n                    doRGB(LD.removeS(nl));\r\n                }\r\n                if (this.settings.doSun) {\r\n                    doSun(LD.getS(nl));\r\n                }\r\n            }\r\n        }\r\n        if (!states.ignoreAO) {\r\n            doAO(face, vertex);\r\n        }\r\n    }\r\n    if (this.settings.doSun || this.settings.doRGB) {\r\n        lightEnd(vertex);\r\n    }\r\n    if (this.settings.doAO) {\r\n        AOEnd(vertex);\r\n    }\r\n}\r\n","//functions\r\nimport { CalculateVoxelLight, VoxelLightMixCalc, } from \"./Functions/CalculateVoxelLight.js\";\r\nimport { CalculateFlow } from \"./Functions/CalculateFlow.js\";\r\n//objects\r\n//data\r\nimport { FaceByte } from \"../../../Data/Meshing/FaceByte.js\";\r\nimport { LightData } from \"../../../Data/Light/LightByte.js\";\r\n//maps\r\nimport { $3dCardinalNeighbors } from \"../../../Data/Constants/Util/CardinalNeighbors.js\";\r\nimport { FaceMap, FaceRecord } from \"../../../Data/Constants/Util/Faces.js\";\r\n//tools\r\nimport { GetConstructorDataTool } from \"../../../Constructor/Tools/Data/ConstructorDataTool.js\";\r\nimport { HeightMapTool } from \"../../../Tools/Data/WorldData/HeightMapTool.js\";\r\nimport { OverrideManager } from \"../Rules/Overrides/OverridesManager.js\";\r\nimport { WorldSpaces } from \"../../../Data/World/WorldSpaces.js\";\r\nimport { VoxelTemplater } from \"../Tools/VoxelTemplater.js\";\r\nimport { SubstanceRules } from \"../Rules/SubstanceRules.js\";\r\nconst mDT = GetConstructorDataTool();\r\nconst nDT = GetConstructorDataTool();\r\nconst heightMapTool = new HeightMapTool();\r\n/**# Chunk Processor\r\n * ---\r\n * Takes the given world data and generates templates\r\n * to build chunk meshes.\r\n */\r\nexport const Processor = {\r\n    LOD: 1,\r\n    mDataTool: mDT,\r\n    nDataTool: nDT,\r\n    faceByte: FaceByte,\r\n    lightData: LightData,\r\n    calculatFlow: CalculateFlow,\r\n    voxellightMixCalc: VoxelLightMixCalc,\r\n    doVoxelLight: CalculateVoxelLight,\r\n    nLocation: [\"main\", 0, 0, 0],\r\n    exposedFaces: [],\r\n    faceStates: [],\r\n    textureRotation: [],\r\n    settings: {\r\n        doAO: true,\r\n        doSun: true,\r\n        doRGB: true,\r\n        ignoreSun: false,\r\n        entity: false,\r\n        composedEntity: 1,\r\n    },\r\n    faceDataOverride: {\r\n        face: \"south\",\r\n        default: false,\r\n        currentVoxel: mDT,\r\n        neighborVoxel: nDT,\r\n    },\r\n    template: {},\r\n    getVoxelTemplate() {\r\n        return {\r\n            aoTemplate: [],\r\n            colorTemplate: [],\r\n            faceTemplate: [],\r\n            flowTemplate: [],\r\n            lightTemplate: [],\r\n            overlayUVTemplate: [],\r\n            positionTemplate: [],\r\n            uvTemplate: [],\r\n        };\r\n    },\r\n    $INIT() {\r\n        SubstanceRules.$INIT();\r\n        VoxelTemplater.currentVoxel = mDT;\r\n        VoxelTemplater.utilDataTool = nDT;\r\n    },\r\n    cullCheck(face, voxelObject, voxelShape, voxelSubstance, faceBit) {\r\n        const voxelExists = this.nDataTool.loadIn();\r\n        let finalResult = false;\r\n        if (voxelExists && this.nDataTool.isRenderable()) {\r\n            let substanceRuleResult = SubstanceRules.exposedCheck(voxelSubstance, this.nDataTool.getSubstance());\r\n            this.faceDataOverride.face = face;\r\n            this.faceDataOverride.default = substanceRuleResult;\r\n            finalResult = substanceRuleResult;\r\n            this.faceDataOverride.default = finalResult;\r\n            finalResult = OverrideManager.runOverride(\"CullFace\", voxelShape.id, \"Any\", this.faceDataOverride);\r\n            this.faceDataOverride.default = finalResult;\r\n            finalResult = OverrideManager.runOverride(\"CullFace\", voxelShape.id, this.nDataTool.getVoxelShapeObj().id, this.faceDataOverride);\r\n            this.faceDataOverride.default = finalResult;\r\n            finalResult = OverrideManager.runOverride(\"CullFace\", voxelObject.id, this.nDataTool.getVoxelShapeObj().id, this.faceDataOverride);\r\n        }\r\n        else {\r\n            finalResult = true;\r\n        }\r\n        const faceIndex = FaceRecord[face];\r\n        if (finalResult) {\r\n            this.exposedFaces[faceIndex] = 1;\r\n            this.faceStates[faceIndex] = 0;\r\n            this.textureRotation[faceIndex] = 0;\r\n            faceBit = this.faceByte.markFaceAsExposed(face, faceBit);\r\n        }\r\n        else {\r\n            this.exposedFaces[faceIndex] = 0;\r\n            this.faceStates[faceIndex] = -1;\r\n            this.textureRotation[faceIndex] = 0;\r\n        }\r\n        return faceBit;\r\n    },\r\n    faceStateCheck(face, faceBit) {\r\n        const faceIndex = FaceRecord[face];\r\n        if (this.exposedFaces[faceIndex]) {\r\n            faceBit = this.faceByte.setFaceRotateState(face, this.faceStates[faceIndex], faceBit);\r\n            faceBit = this.faceByte.setFaceTextureState(face, this.textureRotation[faceIndex], faceBit);\r\n        }\r\n        return faceBit;\r\n    },\r\n    _process(doSecondCheck = false) {\r\n        if (!this.mDataTool.loadInAtLocation(this.nLocation))\r\n            return;\r\n        if (!this.mDataTool.isRenderable())\r\n            return;\r\n        if (!doSecondCheck) {\r\n            if (this.mDataTool.hasSecondaryVoxel()) {\r\n                this._process(true);\r\n            }\r\n        }\r\n        this.mDataTool.setSecondary(doSecondCheck);\r\n        const voxelObject = this.mDataTool.getVoxelObj();\r\n        if (!voxelObject)\r\n            return;\r\n        const voxelShape = this.mDataTool.getVoxelShapeObj();\r\n        const voxelSubstance = this.mDataTool.getSubstance();\r\n        let faceBit = 0;\r\n        let i = $3dCardinalNeighbors.length;\r\n        while (i--) {\r\n            const point = $3dCardinalNeighbors[i];\r\n            this.nDataTool.setXYZ(this.nLocation[1] + point[0] * this.LOD, this.nLocation[2] + point[1] * this.LOD, this.nLocation[3] + point[2] * this.LOD);\r\n            faceBit = this.cullCheck(FaceMap[i], voxelObject, voxelShape, voxelSubstance, faceBit);\r\n        }\r\n        if (faceBit == 0)\r\n            return;\r\n        let baseTemplate = this.template[SubstanceRules.getSubstanceParent(voxelSubstance)];\r\n        if (!baseTemplate) {\r\n            baseTemplate = this.getVoxelTemplate();\r\n            this.template[SubstanceRules.getSubstanceParent(voxelSubstance)] =\r\n                baseTemplate;\r\n        }\r\n        VoxelTemplater._template = baseTemplate;\r\n        voxelObject.process(VoxelTemplater);\r\n        const voxelPOS = WorldSpaces.voxel.getPositionLocation(this.nLocation);\r\n        baseTemplate.positionTemplate.push(voxelPOS.x, voxelPOS.y, voxelPOS.z);\r\n        i = FaceMap.length;\r\n        while (i--) {\r\n            faceBit = this.faceStateCheck(FaceMap[i], faceBit);\r\n        }\r\n        baseTemplate.faceTemplate.push(faceBit);\r\n        if (this.exposedFaces[0] &&\r\n            (voxelSubstance == \"#dve_liquid\" || voxelSubstance == \"#dve_magma\")) {\r\n            this.calculatFlow(this.faceStates[0] == 1, this.nLocation[1], this.nLocation[2], this.nLocation[3], baseTemplate.flowTemplate);\r\n        }\r\n    },\r\n    makeAllChunkTemplates(location, LOD = 1) {\r\n        heightMapTool.chunk.loadInAtLocation(location);\r\n        this.nDataTool.setDimension(location[0]);\r\n        this.mDataTool.setDimension(location[0]);\r\n        this.settings.entity = false;\r\n        this.LOD = LOD;\r\n        const [dimension, cx, cy, cz] = location;\r\n        this.nLocation[0] = dimension;\r\n        let maxX = WorldSpaces.chunk._bounds.x + cx;\r\n        let maxZ = WorldSpaces.chunk._bounds.z + cz;\r\n        let [minY, maxY] = heightMapTool.chunk.getMinMax();\r\n        minY += cy;\r\n        maxY += cy + 1;\r\n        for (let x = cx; x < maxX; x += LOD) {\r\n            for (let z = cz; z < maxZ; z += LOD) {\r\n                for (let y = minY; y < maxY; y += LOD) {\r\n                    this.nLocation[1] = x;\r\n                    this.nLocation[2] = y;\r\n                    this.nLocation[3] = z;\r\n                    this._process();\r\n                }\r\n            }\r\n        }\r\n        return this.template;\r\n    },\r\n    syncSettings(settings) {\r\n        const materials = settings.materials;\r\n        if (materials?.doAO) {\r\n            this.settings.doAO = true;\r\n        }\r\n        if (materials?.doRGBLight) {\r\n            this.settings.doRGB = true;\r\n        }\r\n        if (materials?.doSunLight) {\r\n            this.settings.doSun = true;\r\n        }\r\n    },\r\n    flush() {\r\n        this.template = {};\r\n    },\r\n};\r\n","export const OverrideManager = {\r\n    overrides: {\r\n        AO: new Map(),\r\n        AOFlipFace: new Map(),\r\n        CullFace: new Map(),\r\n        FlipFace: new Map(),\r\n    },\r\n    registerOverride(type, subjectId, neighborShapeId, run) {\r\n        let map = this.overrides[type].get(subjectId);\r\n        if (!map) {\r\n            map = new Map();\r\n            this.overrides[type].set(subjectId, map);\r\n        }\r\n        map.set(neighborShapeId, run);\r\n    },\r\n    hasOverride(type, shapeId, neighborShapeId) {\r\n        let map = this.overrides[type].get(shapeId);\r\n        if (!map)\r\n            return false;\r\n        return map.has(neighborShapeId);\r\n    },\r\n    runOverride(type, shapeId, neighborShapeId, data) {\r\n        let map = this.overrides[type].get(shapeId);\r\n        if (!map)\r\n            return data.default;\r\n        const run = map.get(neighborShapeId);\r\n        if (!run)\r\n            return data.default;\r\n        return run(data);\r\n    },\r\n};\r\n","//types\r\nexport const SubstanceRules = {\r\n    rules: new Map(),\r\n    parents: new Map(),\r\n    registerSubstance(id, substanceCulls, parentId) {\r\n        const map = new Map();\r\n        this.rules.set(id, map);\r\n        if (substanceCulls) {\r\n            for (const culls of substanceCulls) {\r\n                map.set(culls, true);\r\n            }\r\n        }\r\n        if (parentId) {\r\n            this.parents.set(id, parentId);\r\n            return;\r\n        }\r\n        this.parents.set(id, id);\r\n    },\r\n    $INIT() {\r\n        SubstanceRules.registerSubstance(\"#dve_solid\", [\"#dve_solid\"]);\r\n        SubstanceRules.registerSubstance(\"#dve_flora\");\r\n        SubstanceRules.registerSubstance(\"#dve_transparent\", [\"#dve_transparent\"], \"#dve_solid\");\r\n        SubstanceRules.registerSubstance(\"#dve_liquid\", [\r\n            \"#dve_solid\",\r\n            \"#dve_liquid\",\r\n        ]);\r\n        SubstanceRules.registerSubstance(\"#dve_magma\", [\"#dve_solid\", \"#dve_magma\"]);\r\n    },\r\n    exposedCheck(subject, neightborVoxel) {\r\n        const rules = this.rules.get(subject);\r\n        if (!rules)\r\n            return true;\r\n        if (rules.has(neightborVoxel))\r\n            return false;\r\n        return true;\r\n    },\r\n    getSubstanceParent(id) {\r\n        return this.parents.get(id);\r\n    },\r\n};\r\n","export const ShapeManager = {\r\n    shapes: new Map(),\r\n    shapeCount: 0,\r\n    registerShape(shapeObject) {\r\n        this.shapes.set(shapeObject.id, shapeObject);\r\n    },\r\n    getShape(shapeId) {\r\n        const shape = this.shapes.get(shapeId);\r\n        if (!shape) {\r\n            throw new Error(`%${shapeId} does not exists.`);\r\n        }\r\n        return shape;\r\n    },\r\n};\r\n","import { OverrideManager } from \"../../../Rules/Overrides/OverridesManager.js\";\r\nexport const BoxVoxelShape = {\r\n    id: \"#dve_box\",\r\n    build(mesher) {\r\n        mesher.quad.setDimensions(1, 1);\r\n        let animationState = 0;\r\n        if (mesher.data.getSubstance() == \"#dve_flora\") {\r\n            animationState = 3;\r\n        }\r\n        if (mesher.templateData.loadIn(\"top\").isExposed()) {\r\n            mesher.quad\r\n                .setDirection(\"top\")\r\n                .updatePosition(0.5, 1, 0.5)\r\n                .addData(4, animationState)\r\n                .create();\r\n        }\r\n        if (mesher.templateData.loadIn(\"bottom\").isExposed()) {\r\n            mesher.quad\r\n                .setDirection(\"bottom\")\r\n                .updatePosition(0.5, 0, 0.5)\r\n                .addData(4, animationState)\r\n                .create();\r\n        }\r\n        if (mesher.templateData.loadIn(\"east\").isExposed()) {\r\n            mesher.quad\r\n                .setDirection(\"east\")\r\n                .updatePosition(1, 0.5, 0.5)\r\n                .addData(4, animationState)\r\n                .create();\r\n        }\r\n        if (mesher.templateData.loadIn(\"west\").isExposed()) {\r\n            mesher.quad\r\n                .setDirection(\"west\")\r\n                .updatePosition(0, 0.5, 0.5)\r\n                .addData(4, animationState)\r\n                .create();\r\n        }\r\n        if (mesher.templateData.loadIn(\"south\").isExposed()) {\r\n            mesher.quad\r\n                .setDirection(\"south\")\r\n                .updatePosition(0.5, 0.5, 0)\r\n                .addData(4, animationState)\r\n                .create();\r\n        }\r\n        if (mesher.templateData.loadIn(\"north\").isExposed()) {\r\n            mesher.quad\r\n                .setDirection(\"north\")\r\n                .updatePosition(0.5, 0.5, 1)\r\n                .addData(4, animationState)\r\n                .create();\r\n        }\r\n    },\r\n};\r\n//cull leaf faces\r\nconst BoxCullFunctions = {\r\n    top: (data) => {\r\n        if (data.currentVoxel.getSubstance() == \"#dve_flora\" &&\r\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1], data.currentVoxel.location[2] + 1, data.currentVoxel.location[3]) &&\r\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1], data.currentVoxel.location[2] + 2, data.currentVoxel.location[3])) {\r\n            return false;\r\n        }\r\n        return data.default;\r\n    },\r\n    bottom: (data) => {\r\n        if (data.currentVoxel.getSubstance() == \"#dve_flora\" &&\r\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1], data.currentVoxel.location[2] - 1, data.currentVoxel.location[3]) &&\r\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1], data.currentVoxel.location[2] - 2, data.currentVoxel.location[3])) {\r\n            return false;\r\n        }\r\n        return data.default;\r\n    },\r\n    east: (data) => {\r\n        if (data.currentVoxel.getSubstance() == \"#dve_flora\" &&\r\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1] + 1, data.currentVoxel.location[2], data.currentVoxel.location[3]) &&\r\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1] + 2, data.currentVoxel.location[2], data.currentVoxel.location[3])) {\r\n            return false;\r\n        }\r\n        return data.default;\r\n    },\r\n    west: (data) => {\r\n        if (data.currentVoxel.getSubstance() == \"#dve_flora\" &&\r\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1] - 1, data.currentVoxel.location[2], data.currentVoxel.location[3]) &&\r\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1] - 2, data.currentVoxel.location[2], data.currentVoxel.location[3])) {\r\n            return false;\r\n        }\r\n        return data.default;\r\n    },\r\n    north: (data) => {\r\n        if (data.currentVoxel.getSubstance() == \"#dve_flora\" &&\r\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1], data.currentVoxel.location[2], data.currentVoxel.location[3] + 1) &&\r\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1], data.currentVoxel.location[2], data.currentVoxel.location[3] + 2)) {\r\n            return false;\r\n        }\r\n        return data.default;\r\n    },\r\n    south: (data) => {\r\n        if (data.currentVoxel.getSubstance() == \"#dve_flora\" &&\r\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1], data.currentVoxel.location[2], data.currentVoxel.location[3] - 1) &&\r\n            data.currentVoxel.isSameVoxel(data.currentVoxel.location[1], data.currentVoxel.location[2], data.currentVoxel.location[3] - 2)) {\r\n            return false;\r\n        }\r\n        return data.default;\r\n    },\r\n};\r\n//cullface\r\nOverrideManager.registerOverride(\"CullFace\", \"#dve_box\", \"#dve_box\", (data) => {\r\n    return BoxCullFunctions[data.face](data);\r\n});\r\nOverrideManager.registerOverride(\"CullFace\", \"#dve_box\", \"Panel\", (data) => {\r\n    return true;\r\n});\r\nOverrideManager.registerOverride(\"CullFace\", \"#dve_box\", \"#dve_halfbox\", (data) => {\r\n    if (data.face == \"top\") {\r\n        if (data.neighborVoxel.getShapeState() == 0) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    return true;\r\n});\r\nOverrideManager.registerOverride(\"CullFace\", \"#dve_box\", \"#dve_stair\", (data) => {\r\n    StairCullFunctions[data.face](data);\r\n    return true;\r\n});\r\n//ao\r\nOverrideManager.registerOverride(\"AO\", \"#dve_box\", \"Panel\", (data) => {\r\n    return false;\r\n});\r\nOverrideManager.registerOverride(\"AO\", \"#dve_box\", \"#dve_half_box\", (data) => {\r\n    if (data.face == \"top\") {\r\n        if (data.neighborVoxel.getShapeState() == 0) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    return true;\r\n});\r\nconst StairCullFunctions = {\r\n    top: (data) => {\r\n        const neighborVoxelShapeState = data.neighborVoxel.getShapeState();\r\n        if ((neighborVoxelShapeState >= 0 && neighborVoxelShapeState <= 3) ||\r\n            (neighborVoxelShapeState >= 8 && neighborVoxelShapeState <= 11)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    },\r\n    bottom: (data) => {\r\n        const neighborVoxelShapeState = data.neighborVoxel.getShapeState();\r\n        if ((neighborVoxelShapeState >= 4 && neighborVoxelShapeState <= 7) ||\r\n            (neighborVoxelShapeState >= 12 && neighborVoxelShapeState <= 15)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    },\r\n    east: (data) => {\r\n        const neighborVoxelShapeState = data.neighborVoxel.getShapeState();\r\n        if (neighborVoxelShapeState == 1 || neighborVoxelShapeState == 5)\r\n            return false;\r\n        return true;\r\n    },\r\n    west: (data) => {\r\n        const neighborVoxelShapeState = data.neighborVoxel.getShapeState();\r\n        if (neighborVoxelShapeState == 3 || neighborVoxelShapeState == 7)\r\n            return false;\r\n        return true;\r\n    },\r\n    north: (data) => {\r\n        const neighborVoxelShapeState = data.neighborVoxel.getShapeState();\r\n        if (neighborVoxelShapeState == 0 || neighborVoxelShapeState == 4)\r\n            return false;\r\n        return true;\r\n    },\r\n    south: (data) => {\r\n        const neighborVoxelShapeState = data.neighborVoxel.getShapeState();\r\n        if (neighborVoxelShapeState == 2 || neighborVoxelShapeState == 6)\r\n            return false;\r\n        return true;\r\n    },\r\n};\r\n","import { OverrideManager } from \"../../../Rules/Overrides/OverridesManager.js\";\r\nexport const HalfBoxVoxelShape = {\r\n    id: \"#dve_half_box\",\r\n    build(mesher) {\r\n        mesher.quad.setDimensions(1, 1);\r\n        let animationState = 0;\r\n        if (mesher.data.getSubstance() == \"#dve_flora\") {\r\n            animationState = 3;\r\n        }\r\n        const shapeState = mesher.data.getShapeState();\r\n        let yAdd = 0;\r\n        if (shapeState == 1) {\r\n            yAdd = 0.5;\r\n        }\r\n        if (mesher.templateData.loadIn(\"top\").isExposed()) {\r\n            mesher.quad\r\n                .setDirection(\"top\")\r\n                .updatePosition(0.5, 0.5 + yAdd, 0.5)\r\n                .addData(4, animationState)\r\n                .create();\r\n        }\r\n        if (mesher.templateData.loadIn(\"bottom\").isExposed()) {\r\n            mesher.quad\r\n                .setDirection(\"bottom\")\r\n                .updatePosition(0.5, 0 + yAdd, 0.5)\r\n                .addData(4, animationState)\r\n                .create();\r\n        }\r\n        mesher.quad.setDimensions(1, 0.5).uvs.setWidth(0, 1).setHeight(0, 0.5);\r\n        if (mesher.templateData.loadIn(\"east\").isExposed()) {\r\n            mesher.quad\r\n                .setDirection(\"east\")\r\n                .updatePosition(1, 0.25 + yAdd, 0.5)\r\n                .addData(4, animationState)\r\n                .create();\r\n        }\r\n        if (mesher.templateData.loadIn(\"west\").isExposed()) {\r\n            mesher.quad\r\n                .setDirection(\"west\")\r\n                .updatePosition(0, 0.25 + yAdd, 0.5)\r\n                .addData(4, animationState)\r\n                .create();\r\n        }\r\n        if (mesher.templateData.loadIn(\"south\").isExposed()) {\r\n            mesher.quad\r\n                .setDirection(\"south\")\r\n                .updatePosition(0.5, 0.25 + yAdd, 0)\r\n                .addData(4, animationState)\r\n                .create();\r\n        }\r\n        if (mesher.templateData.loadIn(\"north\").isExposed()) {\r\n            mesher.quad\r\n                .setDirection(\"north\")\r\n                .updatePosition(0.5, 0.25 + yAdd, 1)\r\n                .addData(4, animationState)\r\n                .create();\r\n        }\r\n    },\r\n};\r\n//cullface\r\nOverrideManager.registerOverride(\"CullFace\", \"#dve_half_box\", \"#dve_panel\", (data) => {\r\n    return false;\r\n});\r\nOverrideManager.registerOverride(\"CullFace\", \"#dve_half_box\", \"#dve_box\", (data) => {\r\n    if (data.face == \"bottom\") {\r\n        if (data.currentVoxel.getShapeState() == 0) {\r\n            return false;\r\n        }\r\n    }\r\n    if (data.face == \"top\") {\r\n        if (data.currentVoxel.getShapeState() == 1) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n});\r\nOverrideManager.registerOverride(\"CullFace\", \"#dve_half_box\", \"#dve_stair\", (data) => {\r\n    return data.default;\r\n});\r\n//AO\r\nOverrideManager.registerOverride(\"AO\", \"#dve_half_box\", \"#dve_panel\", (data) => {\r\n    return false;\r\n});\r\nOverrideManager.registerOverride(\"AO\", \"#dve_half_box\", \"#dve_box\", (data) => {\r\n    const shapeState = data.currentVoxel.getShapeState();\r\n    if (shapeState == 1) {\r\n        if (data.face == \"top\") {\r\n            if (data.neighborVoxel.location[2] > data.currentVoxel.location[2]) {\r\n                return true;\r\n            }\r\n        }\r\n        if (data.neighborVoxel.location[2] == data.currentVoxel.location[2]) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    return data.default;\r\n});\r\n","//objects\r\nimport { OverrideManager } from \"../../../Rules/Overrides/OverridesManager.js\";\r\nexport const LiquidVoxelShape = {\r\n    id: \"#dve_liquid\",\r\n    build(mesher) {\r\n        const data = mesher._data;\r\n        mesher.quad.setDimensions(1, 1);\r\n        flowAnimationState = 0;\r\n        let topFaceExposed = false;\r\n        if (mesher.templateData.loadIn(\"top\").isExposed()) {\r\n            calculateVertexLevels(data);\r\n            topFaceExposed = true;\r\n            const angle = getAngle(data);\r\n            mesher.quad\r\n                .setTransform(1, 0, vertexLevels.v1v, 0)\r\n                .setTransform(2, 0, vertexLevels.v2v, 0)\r\n                .setTransform(3, 0, vertexLevels.v3v, 0)\r\n                .setTransform(4, 0, vertexLevels.v4v, 0)\r\n                .uvs.setRoation(angle);\r\n            mesher.quad\r\n                .setDirection(\"top\")\r\n                .updatePosition(0.5, 1, 0.5)\r\n                .addData(4, flowAnimationState, false)\r\n                .create()\r\n                .clearTransform()\r\n                .uvs.setRoation(0);\r\n        }\r\n        if (mesher.templateData.loadIn(\"bottom\").isExposed()) {\r\n            mesher.quad\r\n                .setDirection(\"bottom\")\r\n                .updatePosition(0.5, 0, 0.5)\r\n                .addData(4, flowAnimationState, false)\r\n                .create();\r\n        }\r\n        flowAnimationState = 1;\r\n        mesher.quad.uvs.setRoation(0);\r\n        if (mesher.templateData.loadIn(\"east\").isExposed()) {\r\n            mesher.quad\r\n                .setDirection(\"east\")\r\n                .updatePosition(1, 0.5, 0.5)\r\n                .setTransform(1, 0, vertexLevels.v4v, 0)\r\n                .setTransform(2, 0, vertexLevels.v3v, 0)\r\n                .light.add()\r\n                .oUVS.add()\r\n                .setAnimationState(flowAnimationState)\r\n                .create()\r\n                .clearTransform();\r\n            if (topFaceExposed) {\r\n                mesher.quad.uvs.advancedUVs.hs1 = Math.abs(vertexLevels.v4v);\r\n                mesher.quad.uvs.advancedUVs.hs2 = Math.abs(vertexLevels.v3v);\r\n                mesher.quad.uvs.addAdvancedUVs().resetAdvancedUVs();\r\n            }\r\n            else {\r\n                mesher.quad.uvs.add();\r\n            }\r\n        }\r\n        if (mesher.templateData.loadIn(\"west\").isExposed()) {\r\n            mesher.quad\r\n                .setDirection(\"west\")\r\n                .updatePosition(0, 0.5, 0.5)\r\n                .setTransform(1, 0, vertexLevels.v2v, 0)\r\n                .setTransform(2, 0, vertexLevels.v1v, 0)\r\n                .light.add()\r\n                .oUVS.add()\r\n                .setAnimationState(flowAnimationState)\r\n                .create()\r\n                .clearTransform();\r\n            if (topFaceExposed) {\r\n                mesher.quad.uvs.advancedUVs.hs1 = Math.abs(vertexLevels.v2v);\r\n                mesher.quad.uvs.advancedUVs.hs2 = Math.abs(vertexLevels.v1v);\r\n                mesher.quad.uvs.addAdvancedUVs().resetAdvancedUVs();\r\n            }\r\n            else {\r\n                mesher.quad.uvs.add();\r\n            }\r\n        }\r\n        if (mesher.templateData.loadIn(\"south\").isExposed()) {\r\n            mesher.quad\r\n                .setDirection(\"south\")\r\n                .updatePosition(0.5, 0.5, 0)\r\n                .setTransform(1, 0, vertexLevels.v1v, 0)\r\n                .setTransform(2, 0, vertexLevels.v4v, 0)\r\n                .light.add()\r\n                .oUVS.add()\r\n                .setAnimationState(flowAnimationState)\r\n                .create()\r\n                .clearTransform();\r\n            if (topFaceExposed) {\r\n                mesher.quad.uvs.advancedUVs.hs1 = Math.abs(vertexLevels.v1v);\r\n                mesher.quad.uvs.advancedUVs.hs2 = Math.abs(vertexLevels.v4v);\r\n                mesher.quad.uvs.addAdvancedUVs().resetAdvancedUVs();\r\n            }\r\n            else {\r\n                mesher.quad.uvs.add();\r\n            }\r\n        }\r\n        if (mesher.templateData.loadIn(\"north\").isExposed()) {\r\n            mesher.quad\r\n                .setDirection(\"north\")\r\n                .updatePosition(0.5, 0.5, 1)\r\n                .setTransform(1, 0, vertexLevels.v3v, 0)\r\n                .setTransform(2, 0, vertexLevels.v2v, 0)\r\n                .light.add()\r\n                .oUVS.add()\r\n                .setAnimationState(flowAnimationState)\r\n                .create()\r\n                .clearTransform();\r\n            if (topFaceExposed) {\r\n                mesher.quad.uvs.advancedUVs.hs1 = Math.abs(vertexLevels.v3v);\r\n                mesher.quad.uvs.advancedUVs.hs2 = Math.abs(vertexLevels.v2v);\r\n                mesher.quad.uvs.addAdvancedUVs().resetAdvancedUVs();\r\n            }\r\n            else {\r\n                mesher.quad.uvs.add();\r\n            }\r\n        }\r\n        clearVertexLevels(data);\r\n    },\r\n};\r\nOverrideManager.registerOverride(\"CullFace\", \"#dve_liquid\", \"Any\", (data) => {\r\n    if (data.face == \"top\" &&\r\n        data.neighborVoxel.getSubstance() != \"#dve_liquid\" &&\r\n        data.currentVoxel.getStringId() != data.neighborVoxel.getStringId()) {\r\n        return true;\r\n    }\r\n    return data.default;\r\n});\r\nlet flowAnimationState = 0;\r\nconst vertexLevels = {\r\n    v1l: 0,\r\n    v2l: 0,\r\n    v3l: 0,\r\n    v4l: 0,\r\n    v1v: 0,\r\n    v2v: 0,\r\n    v3v: 0,\r\n    v4v: 0,\r\n};\r\nconst getAngle = (data) => {\r\n    if (sourceBlockTest(data)) {\r\n        flowAnimationState = 0;\r\n        return 0;\r\n    }\r\n    const v1 = vertexLevels.v1l;\r\n    const v2 = vertexLevels.v2l;\r\n    const v3 = vertexLevels.v3l;\r\n    const v4 = vertexLevels.v4l;\r\n    if (v1 == v2 && v3 == v4 && v1 == v4 && v2 == v3) {\r\n        flowAnimationState = 0;\r\n        return 0;\r\n    }\r\n    if (v2 == v3 && v1 == v4 && v2 > v1) {\r\n        //flowing south\r\n        flowAnimationState = 1;\r\n        return 0;\r\n    }\r\n    if (v2 == v3 && v1 == v4 && v2 < v1) {\r\n        //flowing north\r\n        flowAnimationState = 2;\r\n        return 0;\r\n    }\r\n    if (v2 == v1 && v3 == v4 && v1 > v4) {\r\n        //flowing east\r\n        flowAnimationState = 2;\r\n        return 90;\r\n    }\r\n    if (v3 == v4 && v2 == v1 && v4 > v1) {\r\n        //flowing west\r\n        flowAnimationState = 1;\r\n        return 90;\r\n    }\r\n    if (v2 < v4) {\r\n        //flowing north west\r\n        flowAnimationState = 2;\r\n        return 315;\r\n    }\r\n    if (v2 > v4) {\r\n        //flowing south east\r\n        flowAnimationState = 1;\r\n        return 315;\r\n    }\r\n    if (v1 > v3) {\r\n        //flowing north east\r\n        flowAnimationState = 2;\r\n        return 45;\r\n    }\r\n    if (v1 < v3) {\r\n        //flowing south west\r\n        flowAnimationState = 1;\r\n        return 45;\r\n    }\r\n    return 0;\r\n};\r\nconst sourceBlockTest = (data) => {\r\n    if (data.flowTemplate && data.flowTemplateIndex != undefined) {\r\n        if (data.flowTemplate[data.flowTemplateIndex] == 15 &&\r\n            data.flowTemplate[data.flowTemplateIndex + 1] == 15 &&\r\n            data.flowTemplate[data.flowTemplateIndex + 2] == 15 &&\r\n            data.flowTemplate[data.flowTemplateIndex + 3] == 15) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\nconst calculateVertexLevels = (data) => {\r\n    if (data.flowTemplate && data.flowTemplateIndex != undefined) {\r\n        vertexLevels.v1l = data.flowTemplate[data.flowTemplateIndex];\r\n        vertexLevels.v2l = data.flowTemplate[data.flowTemplateIndex + 1];\r\n        vertexLevels.v3l = data.flowTemplate[data.flowTemplateIndex + 2];\r\n        vertexLevels.v4l = data.flowTemplate[data.flowTemplateIndex + 3];\r\n        vertexLevels.v1v = vertexLevels.v1l / 15 - 1;\r\n        vertexLevels.v2v = vertexLevels.v2l / 15 - 1;\r\n        vertexLevels.v3v = vertexLevels.v3l / 15 - 1;\r\n        vertexLevels.v4v = vertexLevels.v4l / 15 - 1;\r\n    }\r\n};\r\nconst clearVertexLevels = (data) => {\r\n    if (data.flowTemplate && data.flowTemplateIndex != undefined) {\r\n        vertexLevels.v1l = 0;\r\n        vertexLevels.v2l = 0;\r\n        vertexLevels.v3l = 0;\r\n        vertexLevels.v4l = 0;\r\n        vertexLevels.v1v = 0;\r\n        vertexLevels.v2v = 0;\r\n        vertexLevels.v3v = 0;\r\n        vertexLevels.v4v = 0;\r\n    }\r\n};\r\n","let topANIM = 0;\r\nlet bottomANIM = 0;\r\nexport const CrossedPanels = {\r\n    id: \"#dve_crossed_panels\",\r\n    build(mesher) {\r\n        topANIM = 0;\r\n        bottomANIM = 0;\r\n        if (mesher.data.getSubstance() == \"#dve_flora\") {\r\n            if (mesher.data.isSameVoxel(mesher.data.x, mesher.data.y + 1, mesher.data.z)) {\r\n                topANIM = 3;\r\n                bottomANIM = 3;\r\n            }\r\n            else {\r\n                topANIM = 1;\r\n            }\r\n        }\r\n        mesher.quad.setDimensions(1, 1);\r\n        mesher.setTemplateIncrement(false).templateData.loadIn(\"top\");\r\n        mesher.quad\r\n            .setDirection(\"north\")\r\n            .setFlipped(false)\r\n            .addData(1)\r\n            .setAnimationState([bottomANIM, bottomANIM, topANIM, topANIM])\r\n            .updatePosition(0.5, 0.5, 1)\r\n            .setTransform(1, 0, 0, -1)\r\n            .setTransform(4, 0, 0, -1)\r\n            .create()\r\n            .clearTransform();\r\n        mesher.setTemplateIncrement(true).templateData.loadIn(\"top\");\r\n        mesher.quad\r\n            .setDirection(\"north\")\r\n            .setFlipped(false)\r\n            .addData(1)\r\n            .setAnimationState([bottomANIM, bottomANIM, topANIM, topANIM])\r\n            .updatePosition(0.5, 0.5, 0)\r\n            .setTransform(1, 0, 0, 1)\r\n            .setTransform(4, 0, 0, 1)\r\n            .create()\r\n            .clearTransform();\r\n        mesher.setTemplateIncrement(false).templateData.loadIn(\"bottom\");\r\n        mesher.quad\r\n            .setDirection(\"south\")\r\n            .setFlipped(false)\r\n            .addData(1)\r\n            .setAnimationState([bottomANIM, bottomANIM, topANIM, topANIM])\r\n            .updatePosition(0.5, 0.5, 0)\r\n            .setTransform(1, 0, 0, 1)\r\n            .setTransform(4, 0, 0, 1)\r\n            .create()\r\n            .clearTransform();\r\n        mesher.setTemplateIncrement(true).templateData.loadIn(\"bottom\");\r\n        mesher.quad\r\n            .setDirection(\"south\")\r\n            .setFlipped(false)\r\n            .addData(1)\r\n            .setAnimationState([bottomANIM, bottomANIM, topANIM, topANIM])\r\n            .updatePosition(0.5, 0.5, 1)\r\n            .setTransform(1, 0, 0, -1)\r\n            .setTransform(4, 0, 0, -1)\r\n            .create()\r\n            .clearTransform();\r\n    },\r\n};\r\n","import { OverrideManager } from \"../../../Rules/Overrides/OverridesManager.js\";\r\nlet animationState = 0;\r\nconst shapeStates = {\r\n    0: (mesher) => {\r\n        mesher.templateData.loadIn(\"top\");\r\n        mesher.quad\r\n            .setDirection(\"south\")\r\n            .addData(1, animationState)\r\n            .updatePosition(0.5, 0.5, 0.05)\r\n            .create();\r\n        mesher.templateData.loadIn(\"bottom\");\r\n        mesher.quad\r\n            .setDirection(\"north\")\r\n            .addData(1, animationState)\r\n            .updatePosition(0.5, 0.5, 0.05)\r\n            .create();\r\n    },\r\n    1: (mesher) => {\r\n        mesher.templateData.loadIn(\"top\");\r\n        mesher.quad\r\n            .setDirection(\"north\")\r\n            .addData(1, animationState)\r\n            .updatePosition(0.5, 0.5, 0.95)\r\n            .create();\r\n        mesher.templateData.loadIn(\"bottom\");\r\n        mesher.quad\r\n            .setDirection(\"south\")\r\n            .addData(1, animationState)\r\n            .updatePosition(0.5, 0.5, 0.95)\r\n            .create();\r\n    },\r\n    2: (mesher) => {\r\n        mesher.templateData.loadIn(\"top\");\r\n        mesher.quad\r\n            .setDirection(\"east\")\r\n            .addData(1, animationState)\r\n            .updatePosition(0.95, 0.5, 0.5)\r\n            .create();\r\n        mesher.templateData.loadIn(\"bottom\");\r\n        mesher.quad\r\n            .setDirection(\"west\")\r\n            .addData(1, animationState)\r\n            .updatePosition(0.95, 0.5, 0.5)\r\n            .create();\r\n    },\r\n    3: (mesher) => {\r\n        mesher.templateData.loadIn(\"top\");\r\n        mesher.quad\r\n            .setDirection(\"west\")\r\n            .addData(1, animationState)\r\n            .updatePosition(0.05, 0.5, 0.5)\r\n            .create();\r\n        mesher.templateData.loadIn(\"bottom\");\r\n        mesher.quad\r\n            .setDirection(\"east\")\r\n            .addData(1, animationState)\r\n            .updatePosition(0.05, 0.5, 0.5)\r\n            .create();\r\n    },\r\n    4: (mesher) => {\r\n        mesher.templateData.loadIn(\"top\");\r\n        mesher.quad\r\n            .setDirection(\"top\")\r\n            .addData(1, animationState)\r\n            .updatePosition(0.5, 0.05, 0.5)\r\n            .create();\r\n        mesher.templateData.loadIn(\"bottom\");\r\n        mesher.quad\r\n            .setDirection(\"bottom\")\r\n            .addData(1, animationState)\r\n            .updatePosition(0.5, 0.05, 0.5)\r\n            .create();\r\n    },\r\n    5: (mesher) => {\r\n        mesher.templateData.loadIn(\"top\");\r\n        mesher.quad\r\n            .setDirection(\"bottom\")\r\n            .addData(1, animationState)\r\n            .updatePosition(0.5, 0.95, 0.5)\r\n            .create();\r\n        mesher.templateData.loadIn(\"bottom\");\r\n        mesher.quad\r\n            .setDirection(\"top\")\r\n            .addData(1, animationState)\r\n            .updatePosition(0.5, 0.95, 0.5)\r\n            .create();\r\n    },\r\n};\r\nexport const PanelVoxelShape = {\r\n    id: \"#dve_panel\",\r\n    build(mesher) {\r\n        animationState = 0;\r\n        if (mesher.data.getSubstance() == \"#dve_flora\") {\r\n            animationState = 2;\r\n        }\r\n        mesher.quad.setDimensions(1, 1);\r\n        const shapeState = mesher.data.getShapeState();\r\n        shapeStates[shapeState](mesher);\r\n    },\r\n};\r\nOverrideManager.registerOverride(\"CullFace\", \"Panel\", \"Any\", (data) => {\r\n    if (data.currentVoxel.getSubstance() == \"#dve_flora\") {\r\n        return false;\r\n    }\r\n    return data.default;\r\n});\r\nOverrideManager.registerOverride(\"CullFace\", \"Panel\", \"Any\", (data) => {\r\n    if (data.currentVoxel.getSubstance() == \"#dve_flora\") {\r\n        return false;\r\n    }\r\n    return data.default;\r\n});\r\n","//shapes\r\nimport { CrossedPanels } from \"./Panel/CrossedPanels.voxel.shape.js\";\r\nimport { BoxVoxelShape } from \"./Box/Box.voxel.shape.js\";\r\nimport { LiquidVoxelShape } from \"./Liquid/Liquid.voxel.shape.js\";\r\nimport { HalfBoxVoxelShape } from \"./Box/HalfBox.voxel.shape.js\";\r\nimport { PanelVoxelShape } from \"./Panel/Panel.voxel.shape.js\";\r\nimport { StairVoxelShape } from \"./Stair/Stair.voxel.shape.js\";\r\nexport function RegisterDefaultShapes(builder) {\r\n    builder.shapeManager.registerShape(BoxVoxelShape);\r\n    builder.shapeManager.registerShape(HalfBoxVoxelShape);\r\n    builder.shapeManager.registerShape(StairVoxelShape);\r\n    builder.shapeManager.registerShape(PanelVoxelShape);\r\n    builder.shapeManager.registerShape(LiquidVoxelShape);\r\n    builder.shapeManager.registerShape(CrossedPanels);\r\n}\r\n","import { OverrideManager } from \"../../../Rules/Overrides/OverridesManager.js\";\r\nimport { StairStates } from \"../../../../../Data/Shapes/StairStates.js\";\r\nimport { FaceRecord } from \"../../../../../Data/Constants/Util/Faces.js\";\r\n/*\r\n \"top\",\r\n \"bottom\",\r\n \"east\",\r\n \"west\",\r\n \"south\",\r\n \"north\",\r\n*/\r\nconst stairCulls = {};\r\nstairCulls[StairStates.normal.bottom.north] = {\r\n    faces: [0, 1, 3, 0, 3, 1, 0, 1],\r\n    stateCulls: [\r\n        [StairStates.normal.bottom.north],\r\n        [StairStates.normal.bottom.north],\r\n    ],\r\n};\r\nconst halfBoxCull = (Data) => {\r\n    return true;\r\n};\r\nconst stairCull = (data) => {\r\n    const shapeState = data.currentVoxel.getShapeState();\r\n    const stairData = stairCulls[shapeState];\r\n    if (!stairData)\r\n        return false;\r\n    const neighborShapeState = data.neighborVoxel.getShapeState();\r\n    let finalResult = false;\r\n    const faces = stairData.faces;\r\n    const type = faces[FaceRecord[data.face]];\r\n    if (type == 2 || type == 3) {\r\n        const i = faces[FaceRecord[data.face] + 1];\r\n        const override = stairData.stateCulls[i];\r\n        finalResult = !override.includes(neighborShapeState);\r\n    }\r\n    return finalResult;\r\n};\r\nconst boxCull = (data) => {\r\n    const shapeState = data.currentVoxel.getShapeState();\r\n    const stairData = stairCulls[shapeState];\r\n    if (!stairData)\r\n        return false;\r\n    let finalResult = false;\r\n    const faces = stairData.faces;\r\n    const type = faces[FaceRecord[data.face]];\r\n    if (type == 1 || type == 3) {\r\n        finalResult = false;\r\n    }\r\n    return finalResult;\r\n};\r\nexport const StairCullFace = (data) => {\r\n    const id = data.neighborVoxel.getVoxelShapeObj().id;\r\n    if (id == \"#dve_box\") {\r\n        return boxCull(data);\r\n    }\r\n    if (id == \"#dve_half_box\") {\r\n        return halfBoxCull(data);\r\n    }\r\n    if (id == \"#dve_stair\") {\r\n        return stairCull(data);\r\n    }\r\n    return true;\r\n};\r\nexport function SetUpStairOverrides() {\r\n    OverrideManager.registerOverride(\"CullFace\", \"#dve_stair\", \"Any\", (data) => {\r\n        return StairCullFace(data);\r\n    });\r\n    OverrideManager.registerOverride(\"AOFlipFace\", \"#dve_stair\", \"Any\", (data) => {\r\n        if (data.face == \"top\" || data.face == \"bottom\")\r\n            return true;\r\n        return false;\r\n    });\r\n}\r\n","//functions\r\nimport { SetUpStairOverrides } from \"./Stair.overrides.js\";\r\n//data\r\nimport { StairBuilderData } from \"./StairData.js\";\r\nimport { FaceMap } from \"../../../../../Data/Constants/Util/Faces.js\";\r\nexport const StairVoxelShape = {\r\n    id: \"#dve_stair\",\r\n    build(mesher) {\r\n        const data = StairBuilderData[mesher.data.getShapeState()];\r\n        if (!data)\r\n            return;\r\n        let i = 0;\r\n        for (const face of FaceMap) {\r\n            const node = data[i];\r\n            if (mesher.templateData.loadIn(face).isExposed()) {\r\n                let k = node.length;\r\n                for (const quad of node) {\r\n                    k--;\r\n                    mesher.setTemplateIncrement(k == 0);\r\n                    if (quad[6] >= 0) {\r\n                        mesher.quad.setFlipped(quad[6] == 1);\r\n                    }\r\n                    mesher.quad\r\n                        .setDimensions(quad[1][0], quad[1][1])\r\n                        .setDirection(quad[0])\r\n                        .updatePosition(quad[2][0], quad[2][1], quad[2][2])\r\n                        .AO.addCustom(quad[3])\r\n                        .light.addCustom(quad[4])\r\n                        .oUVS.add()\r\n                        .uvs.setRoation(quad[5][0])\r\n                        .setWidth(quad[5][1], quad[5][2])\r\n                        .setHeight(quad[5][3], quad[5][4])\r\n                        .add()\r\n                        .create()\r\n                        .clearTransform();\r\n                }\r\n            }\r\n            mesher.setTemplateIncrement(true);\r\n            i++;\r\n        }\r\n    },\r\n};\r\nSetUpStairOverrides();\r\n","import { StairStates } from \"../../../../../Data/Shapes/StairStates.js\";\r\nconst halfHeightQuad = (direction, position, AO, uvs) => {\r\n    const mewQuad = quad(direction, position);\r\n    mewQuad[1][1] = 0.5;\r\n    mewQuad[3] = AO;\r\n    mewQuad[4] = [-5, -5, -5, -5];\r\n    mewQuad[5] = [0, 0, 1, uvs[0], uvs[1]];\r\n    return mewQuad;\r\n};\r\nconst halfWidthQuad = (direction, position, AO, uvs) => {\r\n    const quad = halfHeightQuad(direction, position, AO, uvs);\r\n    quad[1][0] = 0.5;\r\n    quad[1][1] = 1;\r\n    quad[4] = [-5, -5, -5, -5];\r\n    quad[5] = [0, uvs[0], uvs[1], 0, 1];\r\n    return quad;\r\n};\r\nconst quaterQuad = (direction, position, AO, uvs) => {\r\n    const mewQuad = quad(direction, position);\r\n    mewQuad[1][0] = 0.5;\r\n    mewQuad[1][1] = 0.5;\r\n    mewQuad[3] = AO;\r\n    mewQuad[4] = [-5, -5, -5, -5];\r\n    mewQuad[5] = uvs;\r\n    return mewQuad;\r\n};\r\nconst quad = (direction, position, AO = [-1, -2, -3, -4], flip = -1 | 0 | 1) => {\r\n    return [\r\n        direction,\r\n        [1, 1],\r\n        position,\r\n        AO,\r\n        [-1, -2, -3, -4],\r\n        [0, 0, 1, 0, 1],\r\n        flip,\r\n    ];\r\n};\r\nconst fullQuads = {\r\n    top: quad(\"top\", [0.5, 1, 0.5]),\r\n    bottom: quad(\"bottom\", [0.5, 0, 0.5]),\r\n    east: quad(\"east\", [1, 0.5, 0.5]),\r\n    west: quad(\"west\", [0, 0.5, 0.5]),\r\n    south: quad(\"south\", [0.5, 0.5, 0]),\r\n    north: quad(\"north\", [0.5, 0.5, 1]),\r\n};\r\nconst a = 0.65;\r\nexport const StairBuilderData = {};\r\n//bottom\r\nStairBuilderData[StairStates.normal.bottom.north] = [\r\n    [\r\n        halfHeightQuad(\"top\", [0.5, 1, 0.75], [1, -2, -3, 1], [0, 0.5]),\r\n        halfHeightQuad(\"top\", [0.5, 0.5, 0.25], [1, a, a, 1], [0.5, 1]),\r\n    ],\r\n    [fullQuads.bottom],\r\n    [\r\n        quaterQuad(\"east\", [1, 0.75, 0.75], [-1, -2, 1, 1], [0, 0.5, 1, 0, 0.5]),\r\n        halfHeightQuad(\"east\", [1, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n    [\r\n        quaterQuad(\"west\", [0, 0.75, 0.75], [-1, -2, 1, 1], [0, 0, 0.5, 0, 0.5]),\r\n        halfHeightQuad(\"west\", [0, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n    [\r\n        halfHeightQuad(\"south\", [0.5, 0.25, 0], [1, 1, -3, -4], [0.5, 1]),\r\n        halfHeightQuad(\"south\", [0.5, 0.75, 0.5], [-1, -2, a, a], [0, 0.5]),\r\n    ],\r\n    [fullQuads.north],\r\n];\r\nStairBuilderData[StairStates.normal.bottom.south] = [\r\n    [\r\n        halfHeightQuad(\"top\", [0.5, 0.5, 0.75], [a, 1, 1, a], [0, 0.5]),\r\n        halfHeightQuad(\"top\", [0.5, 1, 0.25], [-1, 1, 1, -4], [0.5, 1]),\r\n    ],\r\n    [fullQuads.bottom],\r\n    [\r\n        quaterQuad(\"east\", [1, 0.75, 0.25], [-1, -2, 1, 1], [0, 0, 0.5, 0, 0.5]),\r\n        halfHeightQuad(\"east\", [1, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n    [\r\n        quaterQuad(\"west\", [0, 0.75, 0.25], [-1, -2, 1, 1], [0, 0.5, 1, 0, 0.5]),\r\n        halfHeightQuad(\"west\", [0, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n    [fullQuads.south],\r\n    [\r\n        halfHeightQuad(\"north\", [0.5, 0.25, 1], [1, 1, -3, -4], [0.5, 1]),\r\n        halfHeightQuad(\"north\", [0.5, 0.75, 0.5], [-1, -2, a, a], [0, 0.5]),\r\n    ],\r\n];\r\nStairBuilderData[StairStates.normal.bottom.east] = [\r\n    [\r\n        halfWidthQuad(\"top\", [0.75, 1, 0.5], [1, 1, -3, -5], [0.5, 1]),\r\n        halfWidthQuad(\"top\", [0.25, 0.5, 0.5], [1, 1, a, a], [0, 0.5]),\r\n    ],\r\n    [fullQuads.bottom],\r\n    [fullQuads.east],\r\n    [\r\n        halfHeightQuad(\"west\", [0, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\r\n        halfHeightQuad(\"west\", [0.5, 0.75, 0.5], [-1, -2, a, a], [0, 0.5]),\r\n    ],\r\n    [\r\n        quaterQuad(\"south\", [0.75, 0.75, 0], [-1, -2, 1, 1], [0, 0.5, 1, 0, 0.5]),\r\n        halfHeightQuad(\"south\", [0.5, 0.25, 0], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n    [\r\n        quaterQuad(\"north\", [0.75, 0.75, 1], [-1, -2, 1, 1], [0, 0, 0.5, 0, 0.5]),\r\n        halfHeightQuad(\"north\", [0.5, 0.25, 1], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n];\r\nStairBuilderData[StairStates.normal.bottom.west] = [\r\n    [\r\n        halfWidthQuad(\"top\", [0.75, 0.5, 0.5], [a, a, 1, 1], [0.5, 1]),\r\n        halfWidthQuad(\"top\", [0.25, 1, 0.5], [-1, -2, 1, 1], [0, 0.5]),\r\n    ],\r\n    [fullQuads.bottom],\r\n    [\r\n        halfHeightQuad(\"east\", [1, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\r\n        halfHeightQuad(\"east\", [0.5, 0.75, 0.5], [-1, -2, a, a], [0, 0.5]),\r\n    ],\r\n    [fullQuads.west],\r\n    [\r\n        quaterQuad(\"south\", [0.25, 0.75, 0], [-1, -2, 1, 1], [0, 0, 0.5, 0, 0.5]),\r\n        halfHeightQuad(\"south\", [0.5, 0.25, 0], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n    [\r\n        quaterQuad(\"north\", [0.25, 0.75, 1], [-1, -2, 1, 1], [0, 0.5, 1, 0, 0.5]),\r\n        halfHeightQuad(\"north\", [0.5, 0.25, 1], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n];\r\n//top\r\nStairBuilderData[StairStates.normal.top.north] = [\r\n    [fullQuads.top],\r\n    [\r\n        halfHeightQuad(\"bottom\", [0.5, 0, 0.75], [1, 1, -3, -4], [0, 0.5]),\r\n        halfHeightQuad(\"bottom\", [0.5, 0.5, 0.25], [1, 1, a, a], [0.5, 1]),\r\n    ],\r\n    [\r\n        quaterQuad(\"east\", [1, 0.25, 0.75], [-1, -2, 1, 1], [0, 0.5, 1, 0.5, 1]),\r\n        halfHeightQuad(\"east\", [1, 0.75, 0.5], [1, 1, -3, -4], [0, 0.5]),\r\n    ],\r\n    [\r\n        quaterQuad(\"west\", [0, 0.25, 0.75], [-1, -2, 1, 1], [0, 0, 0.5, 0.5, 1]),\r\n        halfHeightQuad(\"west\", [0, 0.75, 0.5], [1, 1, -3, -4], [0, 0.5]),\r\n    ],\r\n    [\r\n        halfHeightQuad(\"south\", [0.5, 0.25, 0.5], [a, a, 1, 1], [0.5, 1]),\r\n        halfHeightQuad(\"south\", [0.5, 0.75, 0], [-1, -2, 1, 1], [0, 0.5]),\r\n    ],\r\n    [fullQuads.north],\r\n];\r\nStairBuilderData[StairStates.normal.top.south] = [\r\n    [fullQuads.top],\r\n    [\r\n        halfHeightQuad(\"bottom\", [0.5, 0, 0.25], [-1, -2, 1, 1], [0, 0.5]),\r\n        halfHeightQuad(\"bottom\", [0.5, 0.5, 0.75], [a, a, 1, 1], [0.5, 1]),\r\n    ],\r\n    [\r\n        quaterQuad(\"east\", [1, 0.25, 0.25], [-1, -2, 1, 1], [0, 0, 0.5, 0.5, 1]),\r\n        halfHeightQuad(\"east\", [1, 0.75, 0.5], [1, 1, -3, -4], [0, 0.5]),\r\n    ],\r\n    [\r\n        quaterQuad(\"west\", [0, 0.25, 0.25], [-1, -2, 1, 1], [0, 0.5, 1, 0.5, 1]),\r\n        halfHeightQuad(\"west\", [0, 0.75, 0.5], [1, 1, -3, -4], [0, 0.5]),\r\n    ],\r\n    [fullQuads.south],\r\n    [\r\n        halfHeightQuad(\"north\", [0.5, 0.25, 0.5], [a, a, 1, 1], [0.5, 1]),\r\n        halfHeightQuad(\"north\", [0.5, 0.75, 1], [-1, -2, 1, 1], [0, 0.5]),\r\n    ],\r\n];\r\nStairBuilderData[StairStates.normal.top.east] = [\r\n    [fullQuads.top],\r\n    [\r\n        halfWidthQuad(\"bottom\", [0.75, 0, 0.5], [1, -2, -3, 1], [0.5, 1]),\r\n        halfWidthQuad(\"bottom\", [0.25, 0.5, 0.5], [1, a, a, 1], [0, 0.5]),\r\n    ],\r\n    [fullQuads.east],\r\n    [\r\n        halfHeightQuad(\"west\", [0.5, 0.25, 0.5], [a, a, 1, 1], [0.5, 1]),\r\n        halfHeightQuad(\"west\", [0, 0.75, 0.5], [-1, -2, 1, 1], [0, 0.5]),\r\n    ],\r\n    [\r\n        quaterQuad(\"south\", [0.75, 0.25, 0], [-1, -2, 1, 1], [0, 0.5, 1, 0.5, 1]),\r\n        halfHeightQuad(\"south\", [0.5, 0.75, 0], [1, 1, -3, -4], [0, 0.5]),\r\n    ],\r\n    [\r\n        quaterQuad(\"north\", [0.75, 0.25, 1], [-1, -2, 1, 1], [0, 0, 0.5, 0.5, 1]),\r\n        halfHeightQuad(\"north\", [0.5, 0.75, 1], [1, 1, -3, -4], [0, 0.5]),\r\n    ],\r\n];\r\nStairBuilderData[StairStates.normal.top.west] = [\r\n    [fullQuads.top],\r\n    [\r\n        halfWidthQuad(\"bottom\", [0.75, 0.5, 0.5], [a, 1, 1, a], [0.5, 1]),\r\n        halfWidthQuad(\"bottom\", [0.25, 0, 0.5], [-1, 1, 1, -4], [0, 0.5]),\r\n    ],\r\n    [\r\n        halfHeightQuad(\"east\", [0.5, 0.25, 0.5], [a, a, 1, 1], [0.5, 1]),\r\n        halfHeightQuad(\"east\", [1, 0.75, 0.5], [-1, -2, 1, 1], [0, 0.5]),\r\n    ],\r\n    [fullQuads.west],\r\n    [\r\n        quaterQuad(\"south\", [0.25, 0.25, 0], [-1, -2, 1, 1], [0, 0, 0.5, 0.5, 1]),\r\n        halfHeightQuad(\"south\", [0.5, 0.75, 0], [1, 1, -3, -4], [0, 0.5]),\r\n    ],\r\n    [\r\n        quaterQuad(\"north\", [0.25, 0.25, 1], [-1, -2, 1, 1], [0, 0.5, 1, 0.5, 1]),\r\n        halfHeightQuad(\"north\", [0.5, 0.75, 1], [1, 1, -3, -4], [0, 0.5]),\r\n    ],\r\n];\r\n//connected states\r\n//bottom\r\nStairBuilderData[StairStates.connected.bottom.northEast] = [\r\n    [\r\n        quaterQuad(\"top\", [0.75, 1, 0.75], [1, -2, -3, 1], [0, 0, 0.5, 0.5, 1]),\r\n        quad(\"top\", [0.5, 0.5, 0.5], [1, 1, a, 1]),\r\n    ],\r\n    [fullQuads.bottom],\r\n    [\r\n        quaterQuad(\"east\", [1, 0.75, 0.75], [-1, -2, 1, 1], [0, 0.5, 1, 0, 0.5]),\r\n        halfHeightQuad(\"east\", [1, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n    [\r\n        quaterQuad(\"west\", [0.5, 0.75, 0.75], [-1, -2, a, a], [0, 0, 0.5, 0, 0.5]),\r\n        halfHeightQuad(\"west\", [0, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n    [\r\n        quaterQuad(\"south\", [0.75, 0.75, 0.5], [-1, -2, a, a], [0, 0.5, 1, 0, 0.5]),\r\n        halfHeightQuad(\"south\", [0.5, 0.25, 0], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n    [\r\n        quaterQuad(\"north\", [0.75, 0.75, 1], [-1, -2, 1, 1], [0, 0, 0.5, 0, 0.5]),\r\n        halfHeightQuad(\"north\", [0.5, 0.25, 1], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n];\r\nStairBuilderData[StairStates.connected.bottom.northWest] = [\r\n    [\r\n        quaterQuad(\"top\", [0.25, 1, 0.75], [1, -2, -3, 1], [0, 0, 0.5, 0.5, 1]),\r\n        quad(\"top\", [0.5, 0.5, 0.5], [1, 1, a, 1], 1),\r\n    ],\r\n    [fullQuads.bottom],\r\n    [\r\n        quaterQuad(\"east\", [0.5, 0.75, 0.75], [-1, -2, a, a], [0, 0.5, 1, 0, 0.5]),\r\n        halfHeightQuad(\"east\", [1, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n    [\r\n        quaterQuad(\"west\", [0, 0.75, 0.75], [-1, -2, 1, 1], [0, 0, 0.5, 0, 0.5]),\r\n        halfHeightQuad(\"west\", [0, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n    [\r\n        quaterQuad(\"south\", [0.25, 0.75, 0.5], [-1, -2, a, a], [0, 0, 0.5, 0, 0.5]),\r\n        halfHeightQuad(\"south\", [0.5, 0.25, 0], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n    [\r\n        quaterQuad(\"north\", [0.25, 0.75, 1], [-1, -2, 1, 1], [0, 0.5, 1, 0, 0.5]),\r\n        halfHeightQuad(\"north\", [0.5, 0.25, 1], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n];\r\nStairBuilderData[StairStates.connected.bottom.southEast] = [\r\n    [\r\n        quaterQuad(\"top\", [0.75, 1, 0.25], [1, -2, -3, 1], [0, 0, 0.5, 0.5, 1]),\r\n        quad(\"top\", [0.5, 0.5, 0.5], [a, 1, 1, 1], 1),\r\n    ],\r\n    [fullQuads.bottom],\r\n    [\r\n        quaterQuad(\"east\", [1, 0.75, 0.25], [-1, -2, 1, 1], [0, 0, 0.5, 0, 0.5]),\r\n        halfHeightQuad(\"east\", [1, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n    [\r\n        quaterQuad(\"west\", [0.5, 0.75, 0.25], [-1, -2, a, a], [0, 0.5, 1, 0, 0.5]),\r\n        halfHeightQuad(\"west\", [0, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n    [\r\n        quaterQuad(\"south\", [0.75, 0.75, 0], [-1, -2, 1, 1], [0, 0.5, 1, 0, 0.5]),\r\n        halfHeightQuad(\"south\", [0.5, 0.25, 0], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n    [\r\n        quaterQuad(\"north\", [0.75, 0.75, 0.5], [-1, -2, a, a], [0, 0, 0.5, 0, 0.5]),\r\n        halfHeightQuad(\"north\", [0.5, 0.25, 1], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n];\r\nStairBuilderData[StairStates.connected.bottom.southWest] = [\r\n    [\r\n        quaterQuad(\"top\", [0.25, 1, 0.25], [1, -2, -3, 1], [0, 0, 0.5, 0.5, 1]),\r\n        quad(\"top\", [0.5, 0.5, 0.5], [a, 1, 1, 1]),\r\n    ],\r\n    [fullQuads.bottom],\r\n    [\r\n        quaterQuad(\"east\", [0.5, 0.75, 0.25], [-1, -2, a, a], [0, 0, 0.5, 0, 0.5]),\r\n        halfHeightQuad(\"east\", [1, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n    [\r\n        quaterQuad(\"west\", [0, 0.75, 0.25], [-1, -2, 1, 1], [0, 0.5, 1, 0, 0.5]),\r\n        halfHeightQuad(\"west\", [0, 0.25, 0.5], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n    [\r\n        quaterQuad(\"south\", [0.25, 0.75, 0], [-1, -2, 1, 1], [0, 0, 0.5, 0, 0.5]),\r\n        halfHeightQuad(\"south\", [0.5, 0.25, 0], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n    [\r\n        quaterQuad(\"north\", [0.25, 0.75, 0.5], [-1, -2, a, a], [0, 0.5, 1, 0, 0.5]),\r\n        halfHeightQuad(\"north\", [0.5, 0.25, 1], [1, 1, -3, -4], [0.5, 1]),\r\n    ],\r\n];\r\n//top\r\nStairBuilderData[StairStates.connected.top.northEast] = [\r\n    [fullQuads.top],\r\n    [\r\n        quaterQuad(\"bottom\", [0.75, 0, 0.75], [1, -2, -3, 1], [0, 0.5, 1, 0.5, 1]),\r\n        quad(\"bottom\", [0.5, 0.5, 0.5], [1, 1, a, 1]),\r\n    ],\r\n    [\r\n        halfHeightQuad(\"east\", [1, 0.75, 0.5], [-1, -2, 1, 1], [0, 0.5]),\r\n        quaterQuad(\"east\", [1, 0.25, 0.75], [1, 1, -3, -4], [0, 0.5, 1, 0.5, 1]),\r\n    ],\r\n    [\r\n        halfHeightQuad(\"west\", [0, 0.75, 0.5], [-1, -2, 1, 1], [0, 0.5]),\r\n        quaterQuad(\"west\", [0.5, 0.25, 0.75], [a, a, -3, -4], [0, 0, 0.5, 0.5, 1]),\r\n    ],\r\n    [\r\n        halfHeightQuad(\"south\", [0.5, 0.75, 0], [-1, -2, 1, 1], [0, 0.5]),\r\n        quaterQuad(\"south\", [0.75, 0.25, 0.5], [a, a, -3, -4], [0, 0.5, 1, 0.5, 1]),\r\n    ],\r\n    [\r\n        halfHeightQuad(\"north\", [0.5, 0.75, 1], [-1, -2, 1, 1], [0, 0.5]),\r\n        quaterQuad(\"north\", [0.75, 0.25, 1], [1, 1, -3, -4], [0, 0, 0.5, 0.5, 1]),\r\n    ],\r\n];\r\nStairBuilderData[StairStates.connected.top.northWest] = [\r\n    [fullQuads.top],\r\n    [\r\n        quaterQuad(\"bottom\", [0.25, 0, 0.75], [1, -2, -3, 1], [0, 0, 0.5, 0.5, 1]),\r\n        quad(\"bottom\", [0.5, 0.5, 0.5], [a, 1, 1, 1], 1),\r\n    ],\r\n    [\r\n        halfHeightQuad(\"east\", [1, 0.75, 0.5], [-1, -2, 1, 1], [0, 0.5]),\r\n        quaterQuad(\"east\", [0.5, 0.25, 0.75], [a, a, -3, -4], [0, 0.5, 1, 0.5, 1]),\r\n    ],\r\n    [\r\n        halfHeightQuad(\"west\", [0, 0.75, 0.5], [-1, -2, 1, 1], [0, 0.5]),\r\n        quaterQuad(\"west\", [0, 0.25, 0.75], [1, 1, -3, -4], [0, 0, 0.5, 0.5, 1]),\r\n    ],\r\n    [\r\n        halfHeightQuad(\"south\", [0.5, 0.75, 0], [-1, -2, 1, 1], [0, 0.5]),\r\n        quaterQuad(\"south\", [0.25, 0.25, 0.5], [a, a, -3, -4], [0, 0, 0.5, 0.5, 1]),\r\n    ],\r\n    [\r\n        halfHeightQuad(\"north\", [0.5, 0.75, 1], [-1, -2, 1, 1], [0, 0.5]),\r\n        quaterQuad(\"north\", [0.25, 0.25, 1], [1, 1, -3, -4], [0, 0.5, 1, 0.5, 1]),\r\n    ],\r\n];\r\nStairBuilderData[StairStates.connected.top.southEast] = [\r\n    [fullQuads.top],\r\n    [\r\n        quaterQuad(\"bottom\", [0.75, 0, 0.25], [1, -2, -3, 1], [0, 0.5, 1, 0, 0.5]),\r\n        quad(\"bottom\", [0.5, 0.5, 0.5], [1, 1, a, 1], 1),\r\n    ],\r\n    [\r\n        halfHeightQuad(\"east\", [1, 0.75, 0.5], [-1, -2, 1, 1], [0, 0.5]),\r\n        quaterQuad(\"east\", [1, 0.25, 0.25], [1, 1, -3, -4], [0, 0, 0.5, 0.5, 1]),\r\n    ],\r\n    [\r\n        halfHeightQuad(\"west\", [0, 0.75, 0.5], [-1, -2, 1, 1], [0, 0.5]),\r\n        quaterQuad(\"west\", [0.5, 0.25, 0.25], [a, a, -3, -4], [0, 0.5, 1, 0.5, 1]),\r\n    ],\r\n    [\r\n        halfHeightQuad(\"south\", [0.5, 0.75, 0], [-1, -2, 1, 1], [0, 0.5]),\r\n        quaterQuad(\"south\", [0.75, 0.25, 0], [1, 1, -3, -4], [0, 0.5, 1, 0.5, 1]),\r\n    ],\r\n    [\r\n        halfHeightQuad(\"north\", [0.5, 0.75, 1], [-1, -2, 1, 1], [0, 0.5]),\r\n        quaterQuad(\"north\", [0.75, 0.25, 0.5], [a, a, -3, -4], [0, 0, 0.5, 0.5, 1]),\r\n    ],\r\n];\r\nStairBuilderData[StairStates.connected.top.southWest] = [\r\n    [fullQuads.top],\r\n    [\r\n        quaterQuad(\"bottom\", [0.25, 0, 0.25], [1, -2, -3, 1], [0, 0, 0.5, 0, 0.5]),\r\n        quad(\"bottom\", [0.5, 0.5, 0.5], [a, 1, 1, 1]),\r\n    ],\r\n    [\r\n        halfHeightQuad(\"east\", [1, 0.75, 0.5], [-1, -2, 1, 1], [0, 0.5]),\r\n        quaterQuad(\"east\", [0.5, 0.25, 0.25], [a, a, -3, -4], [0, 0, 0.5, 0.5, 1]),\r\n    ],\r\n    [\r\n        halfHeightQuad(\"west\", [0, 0.75, 0.5], [-1, -2, 1, 1], [0, 0.5]),\r\n        quaterQuad(\"west\", [0, 0.25, 0.25], [1, 1, -3, -4], [0, 0.5, 1, 0.5, 1]),\r\n    ],\r\n    [\r\n        halfHeightQuad(\"south\", [0.5, 0.75, 0], [-1, -2, 1, 1], [0, 0.5]),\r\n        quaterQuad(\"south\", [0.25, 0.25, 0], [1, 1, -3, -4], [0, 0, 0.5, 0.5, 1]),\r\n    ],\r\n    [\r\n        halfHeightQuad(\"north\", [0.5, 0.75, 1], [-1, -2, 1, 1], [0, 0.5]),\r\n        quaterQuad(\"north\", [0.25, 0.25, 0.5], [a, a, -3, -4], [0, 0.5, 1, 0.5, 1]),\r\n    ],\r\n];\r\n","export const TextureManager = {\r\n    textureDataHasBeenSet: false,\r\n    data: {},\r\n    getTextureUV(data, overlay = false) {\r\n        const [textureType, textureId, varation] = data;\r\n        let id = textureId;\r\n        if (varation) {\r\n            id = `${textureId}:${varation}`;\r\n        }\r\n        let uv = -1;\r\n        if (!overlay) {\r\n            uv = this.data[textureType][\"main\"][id];\r\n        }\r\n        else {\r\n            uv = this.data[textureType][\"overlay\"][id];\r\n        }\r\n        if (uv == -1) {\r\n            throw new Error(`Texture with id: ${id} does not exists. Overlay : ${overlay}`);\r\n        }\r\n        return uv;\r\n    },\r\n    setUVTextureMap(data) {\r\n        this.textureDataHasBeenSet = true;\r\n        this.data = data;\r\n    },\r\n    releaseTextureData() {\r\n        this.data = null;\r\n        delete this[\"data\"];\r\n    },\r\n    isReady() {\r\n        return this.textureDataHasBeenSet;\r\n    },\r\n};\r\n","//data\r\nimport { MeshFaceDataByte } from \"../../../Data/Meshing/MeshFaceDataBytes.js\";\r\nimport { LightData } from \"../../../Data/Light/LightByte.js\";\r\nimport { FaceByte } from \"../../../Data/Meshing/FaceByte.js\";\r\nimport { GetConstructorDataTool } from \"../../Tools/Data/ConstructorDataTool.js\";\r\nimport { GeometryBuilder } from \"../Geometry/GeometryBuilder.js\";\r\nconst dataTool = GetConstructorDataTool();\r\n/**# Voxel Mesher Tool\r\n * ---\r\n * Tool desinged to help make it easy to build voxel meshes.\r\n */\r\nexport const VoxelMesher = {\r\n    _data: {},\r\n    _template: {},\r\n    templateIncrement: true,\r\n    setTemplateIncrement(onOff) {\r\n        this.templateIncrement = onOff;\r\n        return this;\r\n    },\r\n    $buildMesh(type, template, LOD = 1, location) {\r\n        const data = {\r\n            substance: type,\r\n            LOD: LOD,\r\n            //mesh data\r\n            positions: [],\r\n            normals: [],\r\n            indices: [],\r\n            faceData: [],\r\n            lightColors: [],\r\n            colors: [],\r\n            AOColors: [],\r\n            uvs: [],\r\n            overlayUVs: [],\r\n            indicieIndex: 0,\r\n            //chunks template\r\n            shapeState: 0,\r\n            flowTemplateIndex: 0,\r\n            flowTemplate: template.flowTemplate,\r\n            unTemplate: template.uvTemplate,\r\n            uvTemplateIndex: 0,\r\n            overylayUVTemplate: template.overlayUVTemplate,\r\n            overylayUVTemplateIndex: 0,\r\n            colorTemplate: template.colorTemplate,\r\n            colorIndex: 0,\r\n            lightTemplate: template.lightTemplate,\r\n            lightIndex: 0,\r\n            aoTemplate: template.aoTemplate,\r\n            aoIndex: 0,\r\n            //voxel data\r\n            face: 0,\r\n            position: { x: 0, y: 0, z: 0 },\r\n        };\r\n        GeometryBuilder.setData(data);\r\n        this._template = template;\r\n        this._data = data;\r\n        let i = 0;\r\n        for (let positionIndex = 0; positionIndex < template.positionTemplate.length; positionIndex += 3) {\r\n            data.position.x = template.positionTemplate[positionIndex];\r\n            data.position.y = template.positionTemplate[positionIndex + 1];\r\n            data.position.z = template.positionTemplate[positionIndex + 2];\r\n            if (!this.data.loadInAt(location[1] + data.position.x, location[2] + data.position.y, location[3] + data.position.z)) {\r\n                return false;\r\n            }\r\n            if (!this.data.isRenderable()) {\r\n                return false;\r\n            }\r\n            this.quad.setPosition(data.position.x, data.position.y, data.position.z);\r\n            data.face = template.faceTemplate[i];\r\n            data.shapeState = this.data.getShapeState();\r\n            this.data.getVoxelShapeObj().build(this);\r\n            if (data.flowTemplate) {\r\n                if (this.templateData.loadIn(\"top\").isExposed()) {\r\n                    data.flowTemplateIndex += 4;\r\n                }\r\n            }\r\n            this.quad.clear();\r\n            i++;\r\n        }\r\n        GeometryBuilder.clearData();\r\n        const positionArray = new Float32Array(data.positions);\r\n        const normalsArray = new Float32Array(data.normals);\r\n        const indiciesArray = new Uint16Array(data.indices);\r\n        const faceDataArray = new Float32Array(data.faceData);\r\n        const AOColorsArray = new Float32Array(data.AOColors);\r\n        const lightColors = new Float32Array(data.lightColors);\r\n        const colorsArray = new Float32Array(data.colors);\r\n        const uvArray = new Float32Array(data.uvs);\r\n        const overlayUVArray = new Float32Array(data.overlayUVs);\r\n        this._template = null;\r\n        this._data = null;\r\n        return [\r\n            [\r\n                positionArray,\r\n                normalsArray,\r\n                indiciesArray,\r\n                faceDataArray,\r\n                AOColorsArray,\r\n                lightColors,\r\n                colorsArray,\r\n                uvArray,\r\n                overlayUVArray,\r\n            ],\r\n            [\r\n                positionArray.buffer,\r\n                normalsArray.buffer,\r\n                indiciesArray.buffer,\r\n                faceDataArray.buffer,\r\n                AOColorsArray.buffer,\r\n                lightColors.buffer,\r\n                colorsArray.buffer,\r\n                uvArray.buffer,\r\n                overlayUVArray.buffer,\r\n            ],\r\n        ];\r\n    },\r\n    data: dataTool,\r\n    quad: {\r\n        _direction: \"top\",\r\n        _faceData: [0, 0, 0, 0],\r\n        _fliped: false,\r\n        _cachedPosition: { x: 0, y: 0, z: 0 },\r\n        _dimension: { height: 0, width: 0 },\r\n        _transform: {\r\n            1: { x: 0, y: 0, z: 0 },\r\n            2: { x: 0, y: 0, z: 0 },\r\n            3: { x: 0, y: 0, z: 0 },\r\n            4: { x: 0, y: 0, z: 0 },\r\n        },\r\n        setAnimationState(type) {\r\n            if (Array.isArray(type)) {\r\n                for (let i = 0; i < this._faceData.length; i++) {\r\n                    this._faceData[i] = MeshFaceDataByte.setAnimationType(type[i], this._faceData[i]);\r\n                }\r\n                return this;\r\n            }\r\n            for (let i = 0; i < this._faceData.length; i++) {\r\n                this._faceData[i] = MeshFaceDataByte.setAnimationType(type, this._faceData[i]);\r\n            }\r\n            return this;\r\n        },\r\n        setDimensions(width = 0, height = 0) {\r\n            this._dimension.width = width;\r\n            this._dimension.height = height;\r\n            return this;\r\n        },\r\n        setPosition(x = 0, y = 0, z = 0) {\r\n            VoxelMesher._data.position.x = x;\r\n            VoxelMesher._data.position.y = y;\r\n            VoxelMesher._data.position.z = z;\r\n            this._cachedPosition.x = x;\r\n            this._cachedPosition.y = y;\r\n            this._cachedPosition.z = z;\r\n            return this;\r\n        },\r\n        updatePosition(x = 0, y = 0, z = 0) {\r\n            VoxelMesher._data.position.x = this._cachedPosition.x + x;\r\n            VoxelMesher._data.position.y = this._cachedPosition.y + y;\r\n            VoxelMesher._data.position.z = this._cachedPosition.z + z;\r\n            return this;\r\n        },\r\n        updatePositionInPlace(x = 0, y = 0, z = 0) {\r\n            VoxelMesher._data.position.x += x;\r\n            VoxelMesher._data.position.y += y;\r\n            VoxelMesher._data.position.z += z;\r\n            return this;\r\n        },\r\n        setTransform(vertex, x = 0, y = 0, z = 0) {\r\n            const t = this._transform[vertex];\r\n            t.x = x;\r\n            t.y = y;\r\n            t.z = z;\r\n            return this;\r\n        },\r\n        clearTransform() {\r\n            this.setTransform(1);\r\n            this.setTransform(2);\r\n            this.setTransform(3);\r\n            this.setTransform(4);\r\n            return this;\r\n        },\r\n        setFlipped(flipped) {\r\n            this._fliped = flipped;\r\n            this.uvs._fliped = flipped;\r\n            return this;\r\n        },\r\n        setDirection(direction) {\r\n            this._direction = direction;\r\n            return this;\r\n        },\r\n        create() {\r\n            GeometryBuilder.createQuad(this._direction, this._dimension, VoxelMesher._data.position, this._fliped, this._transform);\r\n            let i = 4;\r\n            while (i--) {\r\n                VoxelMesher._data.faceData.push(this._faceData[i]);\r\n                this._faceData[i] = 0;\r\n            }\r\n            return VoxelMesher.quad;\r\n        },\r\n        addData(stride = 4, animationState = 0, doAO = true) {\r\n            if (animationState) {\r\n                this.setAnimationState(animationState);\r\n            }\r\n            this.uvs.add().oUVS.add();\r\n            if (doAO) {\r\n                this.AO.add(stride);\r\n            }\r\n            this.light.add(stride);\r\n            return this;\r\n        },\r\n        clear() {\r\n            this.uvs.clear();\r\n            this.uvs.resetAdvancedUVs();\r\n            this._fliped = false;\r\n            this._cachedPosition.x = 0;\r\n            this._cachedPosition.y = 0;\r\n            this._cachedPosition.z = 0;\r\n            for (let i = 1; i < 5; i++) {\r\n                this._transform[i].x = 0;\r\n                this._transform[i].y = 0;\r\n                this._transform[i].z = 0;\r\n            }\r\n            return VoxelMesher;\r\n        },\r\n        oUVS: {\r\n            getCurrent() {\r\n                const data = VoxelMesher._data;\r\n                let i = data.overylayUVTemplateIndex;\r\n                return [\r\n                    data.overylayUVTemplate[i],\r\n                    data.overylayUVTemplate[i + 1],\r\n                    data.overylayUVTemplate[i + 2],\r\n                    data.overylayUVTemplate[i + 3],\r\n                ];\r\n            },\r\n            add(cumstomUVS) {\r\n                const data = VoxelMesher._data;\r\n                let uv1 = 0;\r\n                let uv2 = 0;\r\n                let uv3 = 0;\r\n                let uv4 = 0;\r\n                if (!cumstomUVS) {\r\n                    let i = data.overylayUVTemplateIndex;\r\n                    uv1 = data.overylayUVTemplate[i];\r\n                    uv2 = data.overylayUVTemplate[i + 1];\r\n                    uv3 = data.overylayUVTemplate[i + 2];\r\n                    uv4 = data.overylayUVTemplate[i + 3];\r\n                    if (VoxelMesher.templateIncrement) {\r\n                        data.overylayUVTemplateIndex += 4;\r\n                    }\r\n                }\r\n                else {\r\n                    if (cumstomUVS.length == 1) {\r\n                        const uv = cumstomUVS[0];\r\n                        uv1 = uv;\r\n                        uv2 = uv;\r\n                        uv3 = uv;\r\n                        uv4 = uv;\r\n                    }\r\n                    else {\r\n                        uv1 = cumstomUVS[0];\r\n                        uv2 = cumstomUVS[1];\r\n                        uv3 = cumstomUVS[2];\r\n                        uv4 = cumstomUVS[3];\r\n                    }\r\n                }\r\n                let i = 4;\r\n                while (i--) {\r\n                    data.overlayUVs.push(uv1, uv2, uv3, uv4);\r\n                }\r\n                return VoxelMesher.quad;\r\n            },\r\n        },\r\n        uvs: {\r\n            _data: {\r\n                width: [0, 1],\r\n                height: [0, 1],\r\n            },\r\n            _fliped: false,\r\n            advancedUVs: {\r\n                hs1: 0,\r\n                hs2: 0,\r\n                he1: 1,\r\n                he2: 1,\r\n                ws1: 0,\r\n                ws2: 0,\r\n                we1: 1,\r\n                we2: 1,\r\n            },\r\n            resetAdvancedUVs() {\r\n                this.advancedUVs.hs1 = 0;\r\n                this.advancedUVs.hs2 = 0;\r\n                this.advancedUVs.he1 = 1;\r\n                this.advancedUVs.he2 = 1;\r\n                this.advancedUVs.ws1 = 0;\r\n                this.advancedUVs.ws2 = 0;\r\n                this.advancedUVs.we1 = 1;\r\n                this.advancedUVs.we2 = 1;\r\n            },\r\n            addAdvancedUVs(uv) {\r\n                const data = VoxelMesher._data;\r\n                if (!uv) {\r\n                    uv = this.getCurrentUV();\r\n                    if (VoxelMesher.templateIncrement) {\r\n                        data.uvTemplateIndex += 1;\r\n                    }\r\n                }\r\n                GeometryBuilder.quads.uvs.addAdvancedUVs(VoxelMesher.quad._direction, uv, VoxelMesher._data.uvs, this.advancedUVs, this._fliped);\r\n                return this;\r\n            },\r\n            _rotation: 0,\r\n            clear() {\r\n                this._data.width[0] = 0;\r\n                this._data.width[1] = 1;\r\n                this._data.height[0] = 0;\r\n                this._data.height[1] = 1;\r\n                this._fliped = false;\r\n                this._rotation = 0;\r\n            },\r\n            setFlipped(flipped) {\r\n                this._fliped = flipped;\r\n                return this;\r\n            },\r\n            setWidth(start, end) {\r\n                this._data.width[0] = start;\r\n                this._data.width[1] = end;\r\n                return this;\r\n            },\r\n            setHeight(start, end) {\r\n                this._data.height[0] = start;\r\n                this._data.height[1] = end;\r\n                return this;\r\n            },\r\n            setRoation(rotation) {\r\n                this._rotation = rotation;\r\n                return this;\r\n            },\r\n            getCurrentUV() {\r\n                const data = VoxelMesher._data;\r\n                return data.unTemplate[data.uvTemplateIndex];\r\n            },\r\n            add(uv) {\r\n                const data = VoxelMesher._data;\r\n                if (!uv) {\r\n                    uv = this.getCurrentUV();\r\n                    if (VoxelMesher.templateIncrement) {\r\n                        data.uvTemplateIndex += 1;\r\n                    }\r\n                }\r\n                GeometryBuilder.quads.uvs.addUVs(VoxelMesher.quad._direction, {\r\n                    uvs: data.uvs,\r\n                    uv: uv,\r\n                    width: { start: this._data.width[0], end: this._data.width[1] },\r\n                    height: { start: this._data.height[0], end: this._data.height[1] },\r\n                    flipped: this._fliped,\r\n                    rotoate: this._rotation,\r\n                });\r\n                return VoxelMesher.quad;\r\n            },\r\n        },\r\n        AO: {\r\n            add(stride = 4) {\r\n                if (stride == 4) {\r\n                    for (let v = 0; v < 4; v++) {\r\n                        const aColor = VoxelMesher._data.aoTemplate[VoxelMesher._data.aoIndex + v];\r\n                        const newColor = aColor ** 2.2;\r\n                        VoxelMesher._data.AOColors.push(newColor);\r\n                    }\r\n                    if (VoxelMesher.templateIncrement) {\r\n                        VoxelMesher._data.aoIndex += 4;\r\n                    }\r\n                }\r\n                if (stride == 1) {\r\n                    const aoValue = VoxelMesher._data.aoTemplate[VoxelMesher._data.aoIndex];\r\n                    const newColor = aoValue ** 2.2;\r\n                    for (let v = 0; v < 4; v++) {\r\n                        VoxelMesher._data.AOColors.push(newColor);\r\n                    }\r\n                    if (VoxelMesher.templateIncrement) {\r\n                        VoxelMesher._data.aoIndex += 1;\r\n                    }\r\n                }\r\n                return VoxelMesher.quad;\r\n            },\r\n            addCustom(data) {\r\n                if (data.length == 4) {\r\n                    for (let v = 0; v < 4; v++) {\r\n                        let aColor = data[v];\r\n                        if (aColor < 0) {\r\n                            aColor =\r\n                                VoxelMesher._data.aoTemplate[VoxelMesher._data.aoIndex + Math.abs(aColor) - 1];\r\n                        }\r\n                        const newColor = aColor ** 2.2;\r\n                        VoxelMesher._data.AOColors.push(newColor);\r\n                    }\r\n                    if (VoxelMesher.templateIncrement) {\r\n                        VoxelMesher._data.aoIndex += 4;\r\n                    }\r\n                }\r\n                if (data.length == 1) {\r\n                    let aoValue = data[0];\r\n                    if (aoValue < 0) {\r\n                        aoValue =\r\n                            VoxelMesher._data.aoTemplate[VoxelMesher._data.aoIndex + Math.abs(aoValue) - 1];\r\n                    }\r\n                    const newColor = aoValue ** 2.2;\r\n                    for (let v = 0; v < 4; v++) {\r\n                        VoxelMesher._data.AOColors.push(newColor);\r\n                    }\r\n                    if (VoxelMesher.templateIncrement) {\r\n                        VoxelMesher._data.aoIndex += 1;\r\n                    }\r\n                }\r\n                return VoxelMesher.quad;\r\n            },\r\n        },\r\n        light: {\r\n            lightMap: [\r\n                0.06, 0.1, 0.11, 0.14, 0.17, 0.21, 0.26, 0.31, 0.38, 0.45, 0.54, 0.64, 0.74,\r\n                0.85, 0.97, 1,\r\n            ],\r\n            add(stride = 4) {\r\n                if (stride == 4) {\r\n                    for (let v = 0; v < 4; v++) {\r\n                        const values = LightData.getLightValues(VoxelMesher._data.lightTemplate[VoxelMesher._data.lightIndex + v]);\r\n                        const s = this.lightMap[values[0]];\r\n                        const r = this.lightMap[values[1]];\r\n                        const g = this.lightMap[values[2]];\r\n                        const b = this.lightMap[values[3]];\r\n                        VoxelMesher._data.lightColors.push(r, g, b, s);\r\n                    }\r\n                    if (VoxelMesher.templateIncrement) {\r\n                        VoxelMesher._data.lightIndex += 4;\r\n                    }\r\n                }\r\n                if (stride == 1) {\r\n                    const lightValue = VoxelMesher._data.lightTemplate[VoxelMesher._data.lightIndex];\r\n                    const values = LightData.getLightValues(lightValue);\r\n                    const s = this.lightMap[values[0]];\r\n                    const r = this.lightMap[values[1]];\r\n                    const g = this.lightMap[values[2]];\r\n                    const b = this.lightMap[values[3]];\r\n                    for (let v = 0; v < 4; v++) {\r\n                        VoxelMesher._data.lightColors.push(r, g, b, s);\r\n                    }\r\n                    if (VoxelMesher.templateIncrement) {\r\n                        VoxelMesher._data.lightIndex += 1;\r\n                    }\r\n                }\r\n                return VoxelMesher.quad;\r\n            },\r\n            addCustom(data) {\r\n                if (data.length == 4) {\r\n                    for (let v = 0; v < 4; v++) {\r\n                        let value = data[v];\r\n                        if (value < 0 && value > -5) {\r\n                            value =\r\n                                VoxelMesher._data.lightTemplate[VoxelMesher._data.lightIndex + Math.abs(value) - 1];\r\n                        }\r\n                        if (value == -5) {\r\n                            value = this._getBrightestLight();\r\n                        }\r\n                        const values = LightData.getLightValues(value);\r\n                        const s = this.lightMap[values[0]];\r\n                        const r = this.lightMap[values[1]];\r\n                        const g = this.lightMap[values[2]];\r\n                        const b = this.lightMap[values[3]];\r\n                        VoxelMesher._data.lightColors.push(r, g, b, s);\r\n                    }\r\n                    if (VoxelMesher.templateIncrement) {\r\n                        VoxelMesher._data.lightIndex += 4;\r\n                    }\r\n                }\r\n                if (data.length == 1) {\r\n                    let lightValue = data[0];\r\n                    if (lightValue < 0 && lightValue > -5) {\r\n                        lightValue =\r\n                            VoxelMesher._data.lightTemplate[VoxelMesher._data.lightIndex + Math.abs(lightValue) - 1];\r\n                    }\r\n                    if (lightValue == -5) {\r\n                        lightValue = this._getBrightestLight();\r\n                    }\r\n                    const values = LightData.getLightValues(lightValue);\r\n                    const s = this.lightMap[values[0]];\r\n                    const r = this.lightMap[values[1]];\r\n                    const g = this.lightMap[values[2]];\r\n                    const b = this.lightMap[values[3]];\r\n                    for (let v = 0; v < 4; v++) {\r\n                        VoxelMesher._data.lightColors.push(r, g, b, s);\r\n                    }\r\n                    if (VoxelMesher.templateIncrement) {\r\n                        VoxelMesher._data.lightIndex += 1;\r\n                    }\r\n                }\r\n                return VoxelMesher.quad;\r\n            },\r\n            _getBrightestLight() {\r\n                const direction = VoxelMesher.quad._direction;\r\n                const x = dataTool.location[1];\r\n                const y = dataTool.location[2];\r\n                const z = dataTool.location[3];\r\n                let l = this._getLight[direction](x, y, z);\r\n                dataTool.loadInAt(x, y, z);\r\n                if (l < 0) {\r\n                    l = dataTool.getLight();\r\n                }\r\n                if (l < 0)\r\n                    l = 0;\r\n                return l;\r\n            },\r\n            _getLight: {\r\n                top: (x, y, z) => {\r\n                    if (!dataTool.loadInAt(x, y + 1, z))\r\n                        return -1;\r\n                    return dataTool.getLight();\r\n                },\r\n                bottom: (x, y, z) => {\r\n                    if (!dataTool.loadInAt(x, y - 1, z))\r\n                        return -1;\r\n                    return dataTool.getLight();\r\n                },\r\n                east: (x, y, z) => {\r\n                    if (!dataTool.loadInAt(x + 1, y, z))\r\n                        return -1;\r\n                    return dataTool.getLight();\r\n                },\r\n                west: (x, y, z) => {\r\n                    if (!dataTool.loadInAt(x - 1, y, z))\r\n                        return -1;\r\n                    return dataTool.getLight();\r\n                },\r\n                south: (x, y, z) => {\r\n                    if (!dataTool.loadInAt(x, y, z - 1))\r\n                        return -1;\r\n                    return dataTool.getLight();\r\n                },\r\n                north: (x, y, z) => {\r\n                    if (!dataTool.loadInAt(x, y, z + 1))\r\n                        return -1;\r\n                    return dataTool.getLight();\r\n                },\r\n            },\r\n        },\r\n    },\r\n    templateData: {\r\n        _face: \"top\",\r\n        _exposed: false,\r\n        loadIn(face) {\r\n            this._face = face;\r\n            const flipped = FaceByte.getFaceRotateState(face, VoxelMesher._data.face) == 1;\r\n            VoxelMesher.quad.setFlipped(flipped);\r\n            this._exposed = FaceByte.isFaceExposed(face, VoxelMesher._data.face);\r\n            VoxelMesher.quad.uvs.setFlipped(flipped);\r\n            VoxelMesher.quad.uvs.setRoation(FaceByte.getFaceTextureState(face, VoxelMesher._data.face));\r\n            return this;\r\n        },\r\n        isExposed() {\r\n            return this._exposed;\r\n        },\r\n    },\r\n};\r\n","//objects\r\nimport { Processor } from \"../Processor/Processor.js\";\r\nimport { FaceRecord } from \"../../../Data/Constants/Util/Faces.js\";\r\nclass VoxelTemplaterBase {\r\n    _template = {};\r\n    _faces = 0;\r\n    currentVoxel = {};\r\n    utilDataTool = {};\r\n    addUV(index, forNumFaces = 1) {\r\n        while (forNumFaces--) {\r\n            this._template.uvTemplate.push(index);\r\n        }\r\n        return this;\r\n    }\r\n    addOverlayUVs(index, forNumFaces = 1) {\r\n        if (index.length == 1) {\r\n            while (forNumFaces--) {\r\n                this._template.overlayUVTemplate.push(index[0], index[0], index[0], index[0]);\r\n            }\r\n            return this;\r\n        }\r\n        while (forNumFaces--) {\r\n            this._template.overlayUVTemplate.push(...index);\r\n        }\r\n        return this;\r\n    }\r\n    addAOValue(value, forNumFaces = 1) {\r\n        while (forNumFaces--) {\r\n            this._template.aoTemplate.push(value);\r\n        }\r\n        return this;\r\n    }\r\n    addLightValue(value, forNumFaces = 1) {\r\n        while (forNumFaces--) {\r\n            this._template.lightTemplate.push(value);\r\n        }\r\n        return this;\r\n    }\r\n    addCurrentLightValue(forNumFaces = 1) {\r\n        const l = this.currentVoxel.getLight();\r\n        while (forNumFaces--) {\r\n            this._template.lightTemplate.push(l);\r\n        }\r\n        return this;\r\n    }\r\n    setTextureRotation(face, rotation) {\r\n        Processor.textureRotation[FaceRecord[face]] = rotation;\r\n        return this;\r\n    }\r\n    isFaceExpposed(face) {\r\n        return Processor.exposedFaces[FaceRecord[face]] == 1;\r\n    }\r\n    processVoxelLight(ignoreAO = false) {\r\n        Processor.doVoxelLight(this._template, this.currentVoxel.x, this.currentVoxel.y, this.currentVoxel.z, ignoreAO, Processor.LOD);\r\n        return this;\r\n    }\r\n}\r\nexport const VoxelTemplater = new VoxelTemplaterBase();\r\n","//objects\r\nimport { EngineSettings } from \"../Data/Settings/EngineSettings.js\";\r\nimport { Util } from \"../Global/Util.helper.js\";\r\nimport { Builder } from \"./Builder/Builder.js\";\r\nimport { Propagation } from \"./Propagation/Propagation.js\";\r\nimport { WorldGeneration } from \"./WorldGeneration/WorldGeneration.js\";\r\nimport { TasksQueue } from \"./Tasks/TasksQueue.js\";\r\nimport { Analyzer } from \"./Analyzer/Analyzer.js\";\r\n//data\r\nimport { DataManager } from \"../Data/DataManager.js\";\r\nimport { DataSyncNode } from \"../Data/DataSyncNode.js\";\r\nimport { VoxelConstructors } from \"./Builder/Constructors/Voxel/VoxelConstructors.js\";\r\n//threadcomm\r\nimport { ThreadComm } from \"threadcomm\";\r\nimport { ParentComm } from \"./Threads/Parent/ParentComm.js\";\r\nimport { WorldComm } from \"./Threads/World/WorldComm.js\";\r\nimport { Tasks } from \"./Tasks/Tasks.js\";\r\n//functions\r\nimport { InitWorker } from \"./Init/InitWorker.js\";\r\nimport { GetConstructorDataTool } from \"./Tools/Data/ConstructorDataTool.js\";\r\nimport { ConstructorHooks } from \"./Hooks/ConstructorHooks.js\";\r\nexport const DVEC = {\r\n    environment: \"browser\",\r\n    __settingsHaveBeenSynced: false,\r\n    UTIL: Util,\r\n    settings: EngineSettings,\r\n    propagation: Propagation,\r\n    worldGen: WorldGeneration,\r\n    builder: Builder,\r\n    analyzer: Analyzer,\r\n    dataSyncNode: DataSyncNode,\r\n    data: DataManager,\r\n    voxelManager: VoxelConstructors,\r\n    TC: ThreadComm,\r\n    parentComm: ParentComm,\r\n    worldComm: WorldComm,\r\n    tasks: Tasks,\r\n    tasksQueue: TasksQueue,\r\n    hooks: ConstructorHooks,\r\n    syncSettings(data) {\r\n        this.settings.syncSettings(data);\r\n        Builder.syncSettings(data);\r\n        this.__settingsHaveBeenSynced = true;\r\n    },\r\n    reStart() { },\r\n    isReady() {\r\n        if (this.environment == \"node\") {\r\n            return (DVEC.worldComm.isPortSet() &&\r\n                DVEC.__settingsHaveBeenSynced &&\r\n                DataSyncNode.isReady());\r\n        }\r\n        else {\r\n            return (DVEC.worldComm.isPortSet() &&\r\n                DVEC.__settingsHaveBeenSynced &&\r\n                Builder.textureManager.isReady() &&\r\n                DataSyncNode.isReady());\r\n        }\r\n    },\r\n    async $INIT() {\r\n        await InitWorker(this);\r\n    },\r\n    getDataTool() {\r\n        return GetConstructorDataTool();\r\n    },\r\n};\r\nDVEC.environment = Util.getEnviorment();\r\n","import { Hooks } from \"divine-hooks\";\r\nexport const ConstructorHooks = {\r\n    texturesRegistered: Hooks.getSyncHook(),\r\n};\r\n","import { ThreadComm } from \"threadcomm\";\r\nexport async function InitWorker(DVEC) {\r\n    let parent = \"render\";\r\n    if (DVEC.environment == \"node\") {\r\n        parent = \"server\";\r\n    }\r\n    await ThreadComm.$INIT(\"constructor\", parent);\r\n    DVEC.builder.$INIT();\r\n    DVEC.tasksQueue.$INIT();\r\n    await DVEC.UTIL.createPromiseCheck({\r\n        check: () => {\r\n            return DVEC.isReady();\r\n        },\r\n        onReady() { },\r\n        checkInterval: 1,\r\n    });\r\n}\r\n","//data\r\nimport { $3dCardinalNeighbors } from \"../../../Data/Constants/Util/CardinalNeighbors.js\";\r\n//objects\r\nimport { DataTool } from \"../../../Tools/Data/DataTool.js\";\r\nimport { LightData } from \"../../../Data/Light/LightByte.js\";\r\n//functions\r\nimport { Distance3D } from \"../../../Math/Functions/Distance3d.js\";\r\nimport { RGBRemove, RGBUpdate } from \"../Illumanation/Functions/RGBUpdate.js\";\r\nimport { SunRemove, SunUpdate } from \"../Illumanation/Functions/SunUpdate.js\";\r\nimport { FlowManager } from \"../Flow/FlowManager.js\";\r\nconst dataTool = new DataTool();\r\nconst nDataTool = new DataTool();\r\nexport const ExplosionManager = {\r\n    runExplosion(tasks) {\r\n        tasks.start();\r\n        const [dimension, sx, sy, sz] = tasks.origin;\r\n        FlowManager.setDimension(dimension);\r\n        tasks.setPriority(0);\r\n        const queue = tasks.queues.queue;\r\n        const map = tasks.queues.map;\r\n        queue.push([sx, sy, sz]);\r\n        dataTool.setDimension(dimension);\r\n        nDataTool.setDimension(dimension);\r\n        const radius = tasks.getData();\r\n        while (queue.length) {\r\n            const node = queue.shift();\r\n            if (!node)\r\n                break;\r\n            const x = node[0];\r\n            const y = node[1];\r\n            const z = node[2];\r\n            if (!map.inMap(x + 1, y, z)) {\r\n                if (dataTool.loadInAt(x + 1, y, z)) {\r\n                    const d = Distance3D(sx, sy, sz, x + 1, y, z);\r\n                    if (d <= radius) {\r\n                        queue.push([x + 1, y, z]);\r\n                    }\r\n                    map.add(x + 1, y, z);\r\n                }\r\n            }\r\n            if (!map.inMap(x - 1, y, z)) {\r\n                if (dataTool.loadInAt(x - 1, y, z)) {\r\n                    const d = Distance3D(sx, sy, sz, x - 1, y, z);\r\n                    if (d <= radius) {\r\n                        queue.push([x - 1, y, z]);\r\n                    }\r\n                }\r\n                map.add(x - 1, y, z);\r\n            }\r\n            if (!map.inMap(x, y, z + 1)) {\r\n                if (dataTool.loadInAt(x, y, z + 1)) {\r\n                    const d = Distance3D(sx, sy, sz, x, y, z + 1);\r\n                    if (d <= radius) {\r\n                        queue.push([x, y, z + 1]);\r\n                    }\r\n                }\r\n                map.add(x, y, z + 1);\r\n            }\r\n            if (!map.inMap(x, y, z - 1)) {\r\n                if (dataTool.loadInAt(x, y, z - 1)) {\r\n                    const d = Distance3D(sx, sy, sz, x, y, z - 1);\r\n                    if (d <= radius) {\r\n                        queue.push([x, y, z - 1]);\r\n                    }\r\n                }\r\n                map.add(x, y, z - 1);\r\n            }\r\n            if (!map.inMap(x, y + 1, z)) {\r\n                if (dataTool.loadInAt(x, y + 1, z)) {\r\n                    const d = Distance3D(sx, sy, sz, x, y + 1, z);\r\n                    if (d <= radius) {\r\n                        queue.push([x, y + 1, z]);\r\n                    }\r\n                }\r\n                map.add(x, y + 1, z);\r\n            }\r\n            if (!map.inMap(x, y - 1, z)) {\r\n                if (dataTool.loadInAt(x, y - 1, z)) {\r\n                    const d = Distance3D(sx, sy, sz, x, y - 1, z);\r\n                    if (d <= radius) {\r\n                        queue.push([x, y - 1, z]);\r\n                    }\r\n                }\r\n                map.add(x, y - 1, z);\r\n            }\r\n            if (dataTool.loadInAt(x, y, z)) {\r\n                if (dataTool.isRenderable()) {\r\n                    const substance = dataTool.getSubstance();\r\n                    for (const n of $3dCardinalNeighbors) {\r\n                        const nx = x + n[0];\r\n                        const ny = y + n[1];\r\n                        const nz = z + n[2];\r\n                        if (nDataTool.loadInAt(nx, ny, nz)) {\r\n                            const l = nDataTool.getLight();\r\n                            if (l > 0) {\r\n                                if (LightData.getS(l) > 0) {\r\n                                    tasks.queues.sun.rmeove.push(nx, ny, nz);\r\n                                }\r\n                                if (LightData.hasRGBLight(l)) {\r\n                                    tasks.queues.rgb.rmeove.push(nx, ny, nz);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    tasks.addNeighborsToRebuildQueue(x, y, z);\r\n                    if (dataTool.getHardness() > 10_000 ||\r\n                        substance == \"#dve_liquid\" ||\r\n                        substance == \"#dve_magma\") {\r\n                        continue;\r\n                    }\r\n                    dataTool.setAir().commit(2);\r\n                }\r\n            }\r\n        }\r\n        RGBRemove(tasks);\r\n        SunRemove(tasks);\r\n        RGBUpdate(tasks);\r\n        SunUpdate(tasks);\r\n        tasks.runRebuildQueue();\r\n        tasks.stop();\r\n    },\r\n};\r\n","import { $3dCardinalNeighbors } from \"../../../Data/Constants/Util/CardinalNeighbors.js\";\r\nimport { LightData } from \"../../../Data/Light/LightByte.js\";\r\nimport { DataTool } from \"../../../Tools/Data/DataTool.js\";\r\nimport { BrushTool } from \"../../../Tools/Brush/Brush.js\";\r\nimport { SunRemove, SunUpdate } from \"../Illumanation/Functions/SunUpdate.js\";\r\nimport { RGBUpdate } from \"../Illumanation/Functions/RGBUpdate.js\";\r\nimport { IlluminationManager } from \"../Illumanation/IlluminationManager.js\";\r\nexport const FlowManager = {\r\n    lightData: LightData,\r\n    _brush: new BrushTool(),\r\n    _sDataTool: new DataTool(),\r\n    _nDataTool: new DataTool(),\r\n    setVoxel(tasks, vox, level, levelState, x, y, z) {\r\n        this.sunCheck(tasks, x, y, z);\r\n        this._brush.setId(vox).setXYZ(x, y, z).paint();\r\n        this._sDataTool.loadInAt(x, y, z);\r\n        this._sDataTool\r\n            .setLevel(level)\r\n            .setLevelState(levelState)\r\n            .setLight(this.getAbsorbLight(x, y, z))\r\n            .commit();\r\n    },\r\n    setDimension(dimension) {\r\n        this._sDataTool.setDimension(dimension);\r\n        this._nDataTool.setDimension(dimension);\r\n        this._brush.setDimension(dimension);\r\n        IlluminationManager.setDimension(dimension);\r\n    },\r\n    removeVoxel(tasks, x, y, z) {\r\n        for (const n of $3dCardinalNeighbors) {\r\n            const nx = x + n[0];\r\n            const ny = y + n[1];\r\n            const nz = z + n[2];\r\n            if (!this._nDataTool.loadInAt(nx, ny, nz))\r\n                continue;\r\n            const l = this._nDataTool.getLight();\r\n            if (l <= 0)\r\n                continue;\r\n            if (this.lightData.getS(l) > 0) {\r\n                tasks.queues.sun.update.push(nx, ny, nz);\r\n            }\r\n            if (this.lightData.hasRGBLight(l)) {\r\n                tasks.queues.rgb.update.push(nx, ny, nz);\r\n            }\r\n        }\r\n        this._brush.setXYZ(x, y, z).erase();\r\n        SunUpdate(tasks);\r\n        RGBUpdate(tasks);\r\n    },\r\n    getVoxel(x, y, z) {\r\n        if (!this._sDataTool.loadInAt(x, y, z))\r\n            return \"\";\r\n        if (!this._sDataTool.isRenderable())\r\n            return \"\";\r\n        const substance = this._sDataTool.getSubstance();\r\n        if (substance != \"#dve_liquid\" && substance != \"#dve_magma\")\r\n            return \"\";\r\n        return this._sDataTool.getStringId();\r\n    },\r\n    setLevel(level, x, y, z) {\r\n        this._nDataTool.loadInAt(x, y, z);\r\n        this._nDataTool.setLevel(level).commit();\r\n    },\r\n    getLevel(vox, x, y, z) {\r\n        if (!this._nDataTool.loadInAt(x, y, z))\r\n            return -2;\r\n        const voxel = this._nDataTool.getStringId();\r\n        if (this._nDataTool.isAir()) {\r\n            return 0;\r\n        }\r\n        if (voxel == vox) {\r\n            return this._nDataTool.getLevel();\r\n        }\r\n        return -1;\r\n    },\r\n    getLevelState(vox, x, y, z) {\r\n        if (!this._nDataTool.loadInAt(x, y, z))\r\n            return -2;\r\n        const voxel = this._nDataTool.getStringId();\r\n        if (voxel == vox) {\r\n            return this._nDataTool.getLevelState();\r\n        }\r\n        if (this._nDataTool.isAir()) {\r\n            return -1;\r\n        }\r\n        return -3;\r\n    },\r\n    canFlowOutwardTest(vox, x, y, z) {\r\n        const level = this.getLevel(vox, x, y - 1, z);\r\n        if (level == -1) {\r\n            return true;\r\n        }\r\n        return false;\r\n    },\r\n    flowDownTest(vox, x, y, z) {\r\n        const level = this.getLevel(vox, x, y - 1, z);\r\n        if (level >= 0) {\r\n            return true;\r\n        }\r\n        return false;\r\n    },\r\n    wait(ms) {\r\n        return new Promise((resolve, reject) => setTimeout(resolve, ms));\r\n    },\r\n    _lightValues: [0, 0, 0, 0],\r\n    getAbsorbLight(x, y, z) {\r\n        for (const n of $3dCardinalNeighbors) {\r\n            if (!this._nDataTool.loadInAt(x + n[0], y + n[1], z + n[2]))\r\n                continue;\r\n            let l = this._nDataTool.getLight();\r\n            if (l <= 0)\r\n                continue;\r\n            const v = this.lightData.getLightValues(l);\r\n            for (let i = 0; i < 4; i++) {\r\n                if (this._lightValues[i] < v[i]) {\r\n                    this._lightValues[i] = v[i];\r\n                }\r\n            }\r\n        }\r\n        let brightest = this.lightData.setLightValues(this._lightValues);\r\n        for (let i = 0; i < 4; i++) {\r\n            this._lightValues[i] = 0;\r\n        }\r\n        return this.lightData.minusOneForAll(brightest);\r\n    },\r\n    sunCheck(tasks, x, y, z) {\r\n        if (!this._nDataTool.loadInAt(x, y - 1, z))\r\n            return;\r\n        if (!this._nDataTool.isAir())\r\n            return;\r\n        const l = this._nDataTool.getLight();\r\n        if (this.lightData.getS(l) == 0xf) {\r\n            tasks.queues.sun.rmeove.push(x, y - 1, z);\r\n            SunRemove(tasks);\r\n        }\r\n    },\r\n};\r\n","import { FlowManager as FM } from \"../FlowManager.js\";\r\nimport { FlowUpdate } from \"./FlowUpdate.js\";\r\nfunction RunRemoveCheck(tasks, vox) {\r\n    const [dimension, x, y, z] = tasks.origin;\r\n    const queue = tasks.queues.flow.rmeove.queue;\r\n    const cl = FM.getLevel(vox, x, y, z);\r\n    queue.push([x, y, z]);\r\n    const n1 = FM.getLevel(vox, x + 1, y, z);\r\n    const n1s = FM.getLevelState(vox, x + 1, y, z);\r\n    if ((n1 > -1 && n1 < cl) || n1s == 1) {\r\n        queue.push([x + 1, y, z]);\r\n    }\r\n    const n2 = FM.getLevel(vox, x - 1, y, z);\r\n    const n2s = FM.getLevelState(vox, x - 1, y, z);\r\n    if ((n2 > 0 && n2 < cl) || n2s == 1) {\r\n        queue.push([x - 1, y, z]);\r\n    }\r\n    const n3 = FM.getLevel(vox, x, y, z + 1);\r\n    const n3s = FM.getLevelState(vox, x, y, z + 1);\r\n    if ((n3 > 0 && n3 < cl) || n3s == 1) {\r\n        queue.push([x, y, z + 1]);\r\n    }\r\n    const n4 = FM.getLevel(vox, x, y, z - 1);\r\n    const n4s = FM.getLevelState(vox, x, y, z - 1);\r\n    if ((n4 > 0 && n4 < cl) || n4s == 1) {\r\n        queue.push([x, y, z - 1]);\r\n    }\r\n}\r\nexport async function FlowRemove(tasks) {\r\n    const [dimension, x, y, z] = tasks.origin;\r\n    const vox = FM.getVoxel(x, y, z);\r\n    if (!vox)\r\n        return;\r\n    RunRemoveCheck(tasks, vox);\r\n    const noRemoveMap = tasks.queues.flow.rmeove.noRemoveMap;\r\n    while (tasks.queues.flow.rmeove.queue.length != 0) {\r\n        FM.setDimension(dimension);\r\n        RunRemovePropagation(tasks, vox);\r\n        RunFlowReduce(tasks, vox);\r\n        await FlowUpdate(tasks, false, vox);\r\n        noRemoveMap.clear();\r\n        tasks.runRebuildQueue();\r\n        await FM.wait(100);\r\n    }\r\n}\r\nfunction RunRemovePropagation(tasks, vox) {\r\n    const removeQ = tasks.queues.flow.rmeove.queue;\r\n    const updateQ = tasks.queues.flow.update.queue;\r\n    const map = tasks.queues.flow.update.map;\r\n    const noRemoveMap = tasks.queues.flow.rmeove.noRemoveMap;\r\n    for (let i = 0; i < removeQ.length; i++) {\r\n        const node = removeQ[i];\r\n        const x = node[0];\r\n        const y = node[1];\r\n        const z = node[2];\r\n        const l = FM.getLevel(vox, x, y, z);\r\n        const s = FM.getLevelState(vox, x, y, z);\r\n        map.add(x, y, z);\r\n        if (noRemoveMap.inMap(x, y, z))\r\n            continue;\r\n        n1t: if (!map.inMap(x + 1, y, z)) {\r\n            const n1 = FM.getLevel(vox, x + 1, y, z);\r\n            const n1s = FM.getLevelState(vox, x + 1, y, z);\r\n            if (n1 <= 0 || n1s == 1)\r\n                break n1t;\r\n            if (n1 < l && l > 0 && n1 > 0) {\r\n                removeQ.push([x + 1, y, z]);\r\n            }\r\n            if (n1 > l) {\r\n                updateQ.push([x + 1, y, z]);\r\n            }\r\n        }\r\n        n2t: if (!map.inMap(x - 1, y, z)) {\r\n            const n2 = FM.getLevel(vox, x - 1, y, z);\r\n            const n2s = FM.getLevelState(vox, x - 1, y, z);\r\n            if (n2 <= 0 || n2s == 1)\r\n                break n2t;\r\n            if (n2 < l && l > 0 && n2 > 0) {\r\n                removeQ.push([x - 1, y, z]);\r\n            }\r\n            if (n2 > l) {\r\n                updateQ.push([x - 1, y, z]);\r\n            }\r\n        }\r\n        n3t: if (!map.inMap(x, y, z + 1)) {\r\n            const n3 = FM.getLevel(vox, x, y, z + 1);\r\n            const n3s = FM.getLevelState(vox, x, y, z + 1);\r\n            if (n3 <= 0 || n3s == 1)\r\n                break n3t;\r\n            if (n3 < l && l > 0 && n3 > 0) {\r\n                removeQ.push([x, y, z + 1]);\r\n            }\r\n            if (n3 > l) {\r\n                updateQ.push([x, y, z + 1]);\r\n            }\r\n        }\r\n        n4t: if (!map.inMap(x, y, z - 1)) {\r\n            const n4 = FM.getLevel(vox, x, y, z - 1);\r\n            const n4s = FM.getLevelState(vox, x, y, z - 1);\r\n            if (n4 <= 0 || n4s == 1)\r\n                break n4t;\r\n            if (n4 < l && l > 0 && n4 > 0) {\r\n                removeQ.push([x, y, z - 1]);\r\n            }\r\n            if (n4 > l) {\r\n                updateQ.push([x, y, z - 1]);\r\n            }\r\n        }\r\n        if (!map.inMap(x, y - 1, z)) {\r\n            const n5 = FM.getLevel(vox, x, y - 1, z);\r\n            if (n5 < 0)\r\n                continue;\r\n            const n5s = FM.getLevelState(vox, x, y - 1, z);\r\n            let add = false;\r\n            if (s == 1 && n5s == 1) {\r\n                if (l < 2) {\r\n                    add = true;\r\n                }\r\n            }\r\n            if (s == 0 && l < 2) {\r\n                add = true;\r\n            }\r\n            if (add) {\r\n                removeQ.push([x, y - 1, z]);\r\n            }\r\n        }\r\n    }\r\n    map.clear();\r\n}\r\nfunction RunFlowReduce(tasks, vox) {\r\n    const queue = tasks.queues.flow.rmeove.queue;\r\n    const map = tasks.queues.flow.rmeove.map;\r\n    const reque = [];\r\n    while (queue.length != 0) {\r\n        const node = queue.shift();\r\n        if (!node) {\r\n            break;\r\n        }\r\n        const x = node[0];\r\n        const y = node[1];\r\n        const z = node[2];\r\n        if (map.inMap(x, y, z))\r\n            continue;\r\n        map.add(x, y, z);\r\n        const l = FM.getLevel(vox, x, y, z);\r\n        const state = FM.getLevelState(vox, x, y, z);\r\n        let syncRebuild = false;\r\n        if (l <= 1) {\r\n            FM.removeVoxel(tasks, x, y, z);\r\n            if (state == 1)\r\n                syncRebuild = true;\r\n        }\r\n        else {\r\n            FM.setLevel(l - 1, x, y, z);\r\n            reque.push([x, y, z]);\r\n        }\r\n        tasks.setBuldMode(syncRebuild ? \"sync\" : \"async\").addToRebuildQueue(x, y, z);\r\n    }\r\n    tasks.queues.flow.rmeove.queue = reque;\r\n    map.clear();\r\n}\r\n","import { FlowManager as FM } from \"../FlowManager.js\";\r\nexport async function FlowUpdate(tasks, rebuild = true, vox = \"\") {\r\n    const [dimension, x, y, z] = tasks.origin;\r\n    vox = FM.getVoxel(x, y, z);\r\n    if (!vox)\r\n        return;\r\n    const level = FM.getLevel(vox, x, y, z);\r\n    if (level < 0)\r\n        return;\r\n    const levelState = FM.getLevelState(vox, x, y, z);\r\n    tasks.queues.flow.update.queue.push([x, y, z, level, levelState]);\r\n    while (tasks.queues.flow.update.queue.length != 0) {\r\n        FM.setDimension(dimension);\r\n        RunFlowPropagation(tasks, vox);\r\n        RunFlowIncrease(tasks, vox);\r\n        if (rebuild) {\r\n            tasks.runRebuildQueue();\r\n            await FM.wait(100);\r\n        }\r\n    }\r\n}\r\nfunction RunFlowPropagation(tasks, vox) {\r\n    const que = tasks.queues.flow.update.queue;\r\n    const noRemoveMap = tasks.queues.flow.rmeove.noRemoveMap;\r\n    for (let i = 0; i < que.length; i++) {\r\n        const node = que[i];\r\n        const x = node[0];\r\n        const y = node[1];\r\n        const z = node[2];\r\n        const l = FM.getLevel(vox, x, y, z);\r\n        const s = FM.getLevelState(vox, x, y, z);\r\n        noRemoveMap.add(x, y, z);\r\n        if (FM.canFlowOutwardTest(vox, x, y, z)) {\r\n            const n1 = FM.getLevel(vox, x + 1, y, z);\r\n            if (n1 + 2 < l && n1 >= 0) {\r\n                let n1l = l - 2;\r\n                que.push([x + 1, y, z, n1l, 0]);\r\n            }\r\n            const n2 = FM.getLevel(vox, x - 1, y, z);\r\n            if (n2 + 2 < l && n2 >= 0) {\r\n                let n2l = l - 2;\r\n                que.push([x - 1, y, z, n2l, 0]);\r\n            }\r\n            const n3 = FM.getLevel(vox, x, y, z + 1);\r\n            if (n3 + 2 < l && n3 >= 0) {\r\n                let n3l = l - 2;\r\n                que.push([x, y, z + 1, n3l, 0]);\r\n            }\r\n            const n4 = FM.getLevel(vox, x, y, z - 1);\r\n            if (n4 + 2 < l && n4 >= 0) {\r\n                let n4l = l - 2;\r\n                que.push([x, y, z - 1, n4l, 0]);\r\n            }\r\n        }\r\n        const n5 = FM.getLevel(vox, x, y - 1, z);\r\n        if (n5 <= l && n5 >= 0) {\r\n            let state = 1;\r\n            let level = 15;\r\n            if (l <= 0 && s != 1) {\r\n                state = 0;\r\n                level = l - 2;\r\n            }\r\n            que.push([x, y - 1, z, level, state]);\r\n        }\r\n    }\r\n}\r\nfunction RunFlowIncrease(tasks, vox) {\r\n    const que = tasks.queues.flow.update.queue;\r\n    const map = tasks.queues.flow.update.map;\r\n    const reque = [];\r\n    while (que.length != 0) {\r\n        const node = que.shift();\r\n        if (!node) {\r\n            break;\r\n        }\r\n        const x = node[0];\r\n        const y = node[1];\r\n        const z = node[2];\r\n        const level = node[3];\r\n        const levelState = node[4];\r\n        if (map.inMap(x, y, z))\r\n            continue;\r\n        map.add(x, y, z);\r\n        if (level > -1) {\r\n            FM.setVoxel(tasks, vox, level, levelState, x, y, z);\r\n            reque.push([x, y, z, -1]);\r\n        }\r\n        tasks.addToRebuildQueue(x, y, z);\r\n    }\r\n    //@ts-ignore\r\n    tasks.queues.flow.update.queue = reque;\r\n    map.clear();\r\n}\r\n","import { IlluminationManager as IM } from \"../IlluminationManager.js\";\r\nexport function RGBUpdate(tasks) {\r\n    IM.setDimension(tasks.origin[0]);\r\n    const queue = tasks.queues.rgb.update;\r\n    while (queue.length != 0) {\r\n        const x = queue.shift();\r\n        const y = queue.shift();\r\n        const z = queue.shift();\r\n        if (!IM._sDataTool.loadInAt(x, y, z))\r\n            continue;\r\n        if (IM._sDataTool.isBarrier())\r\n            continue;\r\n        const sl = IM._sDataTool.getLight();\r\n        if (sl <= 0)\r\n            continue;\r\n        if (IM._nDataTool.loadInAt(x - 1, y, z)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > -1 && IM.lightData.isLessThanForRGBAdd(nl, sl)) {\r\n                queue.push(x - 1, y, z);\r\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForRGB(sl, nl)).commit();\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x + 1, y, z)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > -1 && IM.lightData.isLessThanForRGBAdd(nl, sl)) {\r\n                queue.push(x + 1, y, z);\r\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForRGB(sl, nl)).commit();\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x, y, z - 1)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > -1 && IM.lightData.isLessThanForRGBAdd(nl, sl)) {\r\n                queue.push(x, y, z - 1);\r\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForRGB(sl, nl)).commit();\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x, y, z + 1)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > -1 && IM.lightData.isLessThanForRGBAdd(nl, sl)) {\r\n                queue.push(x, y, z + 1);\r\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForRGB(sl, nl)).commit();\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x, y - 1, z)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > -1 && IM.lightData.isLessThanForRGBAdd(nl, sl)) {\r\n                queue.push(x, y - 1, z);\r\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForRGB(sl, nl)).commit();\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x, y + 1, z)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > -1 && IM.lightData.isLessThanForRGBAdd(nl, sl)) {\r\n                queue.push(x, y + 1, z);\r\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForRGB(sl, nl)).commit();\r\n            }\r\n        }\r\n        tasks.addNeighborsToRebuildQueue(x, y, z);\r\n    }\r\n}\r\nexport function RGBRemove(tasks) {\r\n    IM.setDimension(tasks.origin[0]);\r\n    const remove = tasks.queues.rgb.rmeove;\r\n    const update = tasks.queues.rgb.update;\r\n    const map = tasks.queues.rgb.map;\r\n    while (remove.length != 0) {\r\n        const x = remove.shift();\r\n        const y = remove.shift();\r\n        const z = remove.shift();\r\n        if (map.inMap(x, y, z))\r\n            continue;\r\n        map.add(x, y, z);\r\n        if (!IM._sDataTool.loadInAt(x, y, z))\r\n            continue;\r\n        const sl = IM._sDataTool.getLight();\r\n        if (sl <= 0)\r\n            continue;\r\n        if (IM._nDataTool.loadInAt(x - 1, y, z)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            const n1HasRGB = IM.lightData.hasRGBLight(nl);\r\n            if (n1HasRGB && IM.lightData.isLessThanForRGBRemove(nl, sl)) {\r\n                remove.push(x - 1, y, z);\r\n                if (IM._nDataTool.isLightSource()) {\r\n                    update.push(x - 1, y, z);\r\n                }\r\n            }\r\n            else {\r\n                if (n1HasRGB && IM.lightData.isGreaterOrEqualThanForRGBRemove(nl, sl)) {\r\n                    update.push(x - 1, y, z);\r\n                }\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x + 1, y, z)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            const n1HasRGB = IM.lightData.hasRGBLight(nl);\r\n            if (n1HasRGB && IM.lightData.isLessThanForRGBRemove(nl, sl)) {\r\n                remove.push(x + 1, y, z);\r\n                if (IM._nDataTool.isLightSource()) {\r\n                    update.push(x + 1, y, z);\r\n                }\r\n            }\r\n            else {\r\n                if (n1HasRGB && IM.lightData.isGreaterOrEqualThanForRGBRemove(nl, sl)) {\r\n                    update.push(x + 1, y, z);\r\n                }\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x, y, z - 1)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            const n1HasRGB = IM.lightData.hasRGBLight(nl);\r\n            if (n1HasRGB && IM.lightData.isLessThanForRGBRemove(nl, sl)) {\r\n                remove.push(x, y, z - 1);\r\n            }\r\n            else {\r\n                if (n1HasRGB && IM.lightData.isGreaterOrEqualThanForRGBRemove(nl, sl)) {\r\n                    update.push(x, y, z - 1);\r\n                }\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x, y, z + 1)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            const n1HasRGB = IM.lightData.hasRGBLight(nl);\r\n            if (n1HasRGB && IM.lightData.isLessThanForRGBRemove(nl, sl)) {\r\n                remove.push(x, y, z + 1);\r\n                if (IM._nDataTool.isLightSource()) {\r\n                    update.push(x, y, z + 1);\r\n                }\r\n            }\r\n            else {\r\n                if (n1HasRGB && IM.lightData.isGreaterOrEqualThanForRGBRemove(nl, sl)) {\r\n                    update.push(x, y, z + 1);\r\n                }\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x, y - 1, z)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            const n1HasRGB = IM.lightData.hasRGBLight(nl);\r\n            if (n1HasRGB && IM.lightData.isLessThanForRGBRemove(nl, sl)) {\r\n                remove.push(x, y - 1, z);\r\n                if (IM._nDataTool.isLightSource()) {\r\n                    update.push(x, y - 1, z);\r\n                }\r\n            }\r\n            else {\r\n                if (n1HasRGB && IM.lightData.isGreaterOrEqualThanForRGBRemove(nl, sl)) {\r\n                    update.push(x, y - 1, z);\r\n                }\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x, y + 1, z)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            const n1HasRGB = IM.lightData.hasRGBLight(nl);\r\n            if (n1HasRGB && IM.lightData.isLessThanForRGBRemove(nl, sl)) {\r\n                remove.push(x, y + 1, z);\r\n                if (IM._nDataTool.isLightSource()) {\r\n                    update.push(x, y + 1, z);\r\n                }\r\n            }\r\n            else {\r\n                if (n1HasRGB && IM.lightData.isGreaterOrEqualThanForRGBRemove(nl, sl)) {\r\n                    update.push(x, y + 1, z);\r\n                }\r\n            }\r\n        }\r\n        tasks.addNeighborsToRebuildQueue(x, y, z);\r\n        IM._sDataTool.setLight(IM.lightData.removeRGBLight(sl)).commit();\r\n    }\r\n    map.clear();\r\n}\r\n","import { IlluminationManager as IM } from \"../IlluminationManager.js\";\r\nexport function SunUpdate(tasks) {\r\n    const update = tasks.queues.sun.update;\r\n    while (update.length > 0) {\r\n        const x = update.shift();\r\n        const y = update.shift();\r\n        const z = update.shift();\r\n        if (!IM._sDataTool.loadInAt(x, y, z))\r\n            continue;\r\n        const sl = IM._sDataTool.getLight();\r\n        if (sl <= 0)\r\n            continue;\r\n        if (!IM.lightData.getS(sl))\r\n            continue;\r\n        if (IM._nDataTool.loadInAt(x - 1, y, z)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > -1 && IM.lightData.isLessThanForSunAdd(nl, sl)) {\r\n                update.push(x - 1, y, z);\r\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x + 1, y, z)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > -1 && IM.lightData.isLessThanForSunAdd(nl, sl)) {\r\n                update.push(x + 1, y, z);\r\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x, y, z - 1)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > -1 && IM.lightData.isLessThanForSunAdd(nl, sl)) {\r\n                update.push(x, y, z - 1);\r\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x, y, z + 1)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > -1 && IM.lightData.isLessThanForSunAdd(nl, sl)) {\r\n                update.push(x, y, z + 1);\r\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x, y - 1, z)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > -1 && IM.lightData.isLessThanForSunAddDown(nl, sl)) {\r\n                if (IM._nDataTool.isAir()) {\r\n                    update.push(x, y - 1, z);\r\n                    IM._nDataTool\r\n                        .setLight(IM.lightData.getSunLightForUnderVoxel(sl, nl))\r\n                        .commit();\r\n                }\r\n                else {\r\n                    const substance = IM._nDataTool.getSubstance();\r\n                    if (substance != \"#dve_magma\" && substance != \"#dve_solid\") {\r\n                        update.push(x, y - 1, z);\r\n                        IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x, y + 1, z)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > -1 && IM.lightData.isLessThanForSunAdd(nl, sl)) {\r\n                update.push(x, y + 1, z);\r\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\r\n            }\r\n        }\r\n        tasks.addNeighborsToRebuildQueue(x, y, z);\r\n    }\r\n}\r\nexport function SunRemove(tasks) {\r\n    const remove = tasks.queues.sun.rmeove;\r\n    const update = tasks.queues.sun.update;\r\n    while (remove.length != 0) {\r\n        const x = remove.shift();\r\n        const y = remove.shift();\r\n        const z = remove.shift();\r\n        if (!IM._sDataTool.loadInAt(x, y, z))\r\n            continue;\r\n        const sl = IM._sDataTool.getLight();\r\n        if (sl <= 0)\r\n            continue;\r\n        if (!IM.lightData.getS(sl))\r\n            continue;\r\n        if (IM._nDataTool.loadInAt(x - 1, y, z)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > 0) {\r\n                if (IM.lightData.isLessThanForSunRemove(nl, sl)) {\r\n                    remove.push(x - 1, y, z);\r\n                }\r\n                else {\r\n                    if (IM.lightData.isGreaterOrEqualThanForSunRemove(nl, sl)) {\r\n                        update.push(x - 1, y, z);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x + 1, y, z)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > 0) {\r\n                if (IM.lightData.isLessThanForSunRemove(nl, sl)) {\r\n                    remove.push(x + 1, y, z);\r\n                }\r\n                else {\r\n                    if (IM.lightData.isGreaterOrEqualThanForSunRemove(nl, sl)) {\r\n                        update.push(x + 1, y, z);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x, y, z - 1)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > 0) {\r\n                if (IM.lightData.isLessThanForSunRemove(nl, sl)) {\r\n                    remove.push(x, y, z - 1);\r\n                }\r\n                else {\r\n                    if (IM.lightData.isGreaterOrEqualThanForSunRemove(nl, sl)) {\r\n                        update.push(x, y, z - 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x, y, z + 1)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > 0) {\r\n                if (IM.lightData.isLessThanForSunRemove(nl, sl)) {\r\n                    remove.push(x, y, z + 1);\r\n                }\r\n                else {\r\n                    if (IM.lightData.isGreaterOrEqualThanForSunRemove(nl, sl)) {\r\n                        update.push(x, y, z + 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x, y - 1, z)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > 0) {\r\n                if (IM.lightData.sunLightCompareForDownSunRemove(nl, sl)) {\r\n                    remove.push(x, y - 1, z);\r\n                }\r\n                else {\r\n                    if (IM.lightData.isGreaterOrEqualThanForSunRemove(nl, sl)) {\r\n                        update.push(x, y - 1, z);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x, y + 1, z)) {\r\n            const n6 = IM._nDataTool.getLight();\r\n            if (n6 > 0) {\r\n                if (IM.lightData.isLessThanForSunRemove(n6, sl)) {\r\n                    remove.push(x, y + 1, z);\r\n                }\r\n                else {\r\n                    if (IM.lightData.isGreaterOrEqualThanForSunRemove(n6, sl)) {\r\n                        update.push(x, y + 1, z);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        tasks.addNeighborsToRebuildQueue(x, y, z);\r\n        IM._sDataTool.setLight(IM.lightData.removeSunLight(sl)).commit();\r\n    }\r\n}\r\n","//data\r\nimport { WorldBounds } from \"../../../../Data/World/WorldBounds.js\";\r\nimport { WorldRegister } from \"../../../../Data/World/WorldRegister.js\";\r\nimport { $3dCardinalNeighbors } from \"../../../../Data/Constants/Util/CardinalNeighbors.js\";\r\nimport { WorldSpaces } from \"../../../../Data/World/WorldSpaces.js\";\r\nimport { IlluminationManager as IM } from \"../IlluminationManager.js\";\r\nconst inColumnBounds = (cx, cz, x, z) => {\r\n    if (x >= cx &&\r\n        x <= cx + WorldSpaces.chunk._bounds.x &&\r\n        z >= cz &&\r\n        z <= cz + WorldSpaces.chunk._bounds.z)\r\n        return true;\r\n    return false;\r\n};\r\nexport function RunWorldSun(tasks) {\r\n    IM.setDimension(tasks.origin[0]);\r\n    tasks.start();\r\n    if (!WorldRegister.column.get(tasks.origin))\r\n        return false;\r\n    const [dimension, cx, cy, cz] = tasks.origin;\r\n    const queue = tasks.queues.sun;\r\n    IM._sDataTool.setDimension(dimension);\r\n    const RmaxY = WorldRegister.column.height.getRelative(tasks.origin);\r\n    const AmaxY = WorldRegister.column.height.getAbsolute(tasks.origin);\r\n    //fill\r\n    for (let ix = cx; ix < cx + WorldSpaces.chunk._bounds.x; ix++) {\r\n        for (let iz = cz; iz < cz + WorldSpaces.chunk._bounds.z; iz++) {\r\n            for (let iy = AmaxY; iy < WorldBounds.bounds.MaxY; iy++) {\r\n                if (!IM._sDataTool.loadInAt(ix, iy, iz))\r\n                    continue;\r\n                const l = IM._sDataTool.getLight();\r\n                if (l < 0)\r\n                    continue;\r\n                IM._sDataTool.setLight(IM.lightData.setS(0xf, l)).commit();\r\n            }\r\n        }\r\n    }\r\n    //accumulate\r\n    for (let ix = cx; ix < cx + WorldSpaces.chunk._bounds.x; ix++) {\r\n        for (let iz = cz; iz < cz + WorldSpaces.chunk._bounds.z; iz++) {\r\n            for (let iy = AmaxY; iy <= RmaxY; iy++) {\r\n                if (!IM._sDataTool.loadInAt(ix, iy, iz))\r\n                    continue;\r\n                const l = IM._sDataTool.getLight();\r\n                if (l < 0 && IM.lightData.getS(l) != 0xf)\r\n                    continue;\r\n                let add = false;\r\n                for (const n of $3dCardinalNeighbors) {\r\n                    const nx = ix + n[0];\r\n                    const ny = iy + n[1];\r\n                    const nz = iz + n[2];\r\n                    if (IM._nDataTool.loadInAt(nx, ny, nz)) {\r\n                        const nl = IM._nDataTool.getLight();\r\n                        if (nl >= 0 && IM.lightData.getS(nl) < 0xf) {\r\n                            add = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (add) {\r\n                    queue.push(ix, iy, iz);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    //flood\r\n    while (queue.length) {\r\n        const x = queue.shift();\r\n        const y = queue.shift();\r\n        const z = queue.shift();\r\n        if (!IM._sDataTool.loadInAt(x, y, z))\r\n            continue;\r\n        const sl = IM._sDataTool.getLight();\r\n        if (sl <= 0)\r\n            continue;\r\n        const sunL = IM.lightData.getS(sl);\r\n        if (sunL >= 0xf && !inColumnBounds(cx, cz, x, z))\r\n            continue;\r\n        if (IM._nDataTool.loadInAt(x - 1, y, z)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > -1 && IM.lightData.isLessThanForSunAdd(nl, sl)) {\r\n                queue.push(x - 1, y, z);\r\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x + 1, y, z)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > -1 && IM.lightData.isLessThanForSunAdd(nl, sl)) {\r\n                queue.push(x + 1, y, z);\r\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x, y, z - 1)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > -1 && IM.lightData.isLessThanForSunAdd(nl, sl)) {\r\n                queue.push(x, y, z - 1);\r\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x, y, z + 1)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > -1 && IM.lightData.isLessThanForSunAdd(nl, sl)) {\r\n                queue.push(x, y, z + 1);\r\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x, y - 1, z)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > -1 && IM.lightData.isLessThanForSunAddDown(nl, sl)) {\r\n                if (IM._nDataTool.isAir()) {\r\n                    queue.push(x, y - 1, z);\r\n                    IM._nDataTool\r\n                        .setLight(IM.lightData.getSunLightForUnderVoxel(sl, nl))\r\n                        .commit();\r\n                }\r\n                else {\r\n                    const substance = IM._nDataTool.getSubstance();\r\n                    if (substance != \"#dve_magma\" && substance != \"#dve_solid\") {\r\n                        queue.push(x, y - 1, z);\r\n                        IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (IM._nDataTool.loadInAt(x, y + 1, z)) {\r\n            const nl = IM._nDataTool.getLight();\r\n            if (nl > -1 && IM.lightData.isLessThanForSunAdd(nl, sl)) {\r\n                queue.push(x, y + 1, z);\r\n                IM._nDataTool.setLight(IM.lightData.getMinusOneForSun(sl, nl)).commit();\r\n            }\r\n        }\r\n    }\r\n    tasks.stop();\r\n}\r\n","//functions\r\nimport { DataTool } from \"../../../Tools/Data/DataTool.js\";\r\nimport { LightData } from \"../../../Data/Light/LightByte.js\";\r\nexport const IlluminationManager = {\r\n    lightData: LightData,\r\n    //tools\r\n    _sDataTool: new DataTool(),\r\n    _nDataTool: new DataTool(),\r\n    setDimension(dimension) {\r\n        this._sDataTool.setDimension(dimension);\r\n        this._nDataTool.setDimension(dimension);\r\n    },\r\n};\r\n","import { RGBRemove, RGBUpdate } from \"./Illumanation/Functions/RGBUpdate.js\";\r\nimport { SunRemove, SunUpdate } from \"./Illumanation/Functions/SunUpdate.js\";\r\nimport { RunWorldSun } from \"./Illumanation/Functions/WorldSun.js\";\r\nimport { FlowUpdate } from \"./Flow/Functions/FlowUpdate.js\";\r\nimport { FlowRemove } from \"./Flow/Functions/FlowRemove.js\";\r\nimport { ExplosionManager } from \"./Explosion/ExplosionManager.js\";\r\nexport const Propagation = {\r\n    expolosion: {\r\n        run(tasks) {\r\n            ExplosionManager.runExplosion(tasks);\r\n        },\r\n    },\r\n    flow: {\r\n        async update(tasks) {\r\n            await FlowUpdate(tasks);\r\n        },\r\n        async remove(tasks) {\r\n            await FlowRemove(tasks);\r\n        },\r\n    },\r\n    worldSun: {\r\n        run(tasks) {\r\n            RunWorldSun(tasks);\r\n        },\r\n    },\r\n    rgb: {\r\n        update(tasks) {\r\n            RGBUpdate(tasks);\r\n        },\r\n        remove(tasks) {\r\n            RGBRemove(tasks);\r\n        },\r\n    },\r\n    sun: {\r\n        update(tasks) {\r\n            SunUpdate(tasks);\r\n        },\r\n        remove(tasks) {\r\n            SunRemove(tasks);\r\n        },\r\n    },\r\n};\r\n","import { Propagation } from \"../../Propagation/Propagation.js\";\r\nimport { EngineSettings as ES } from \"../../../Data/Settings/EngineSettings.js\";\r\nimport { DataTool } from \"../../../Tools/Data/DataTool.js\";\r\nimport { $3dCardinalNeighbors } from \"../../../Data/Constants/Util/CardinalNeighbors.js\";\r\nimport { BrushTool } from \"../../../Tools/Brush/Brush.js\";\r\nimport { TasksRequest } from \"../TasksRequest.js\";\r\nimport { LocationDataDistanceSort } from \"../../../Math/Functions/DistnaceSort.js\";\r\nconst dataTool = new DataTool();\r\nconst nDataTool = new DataTool();\r\nconst brushTool = new BrushTool();\r\nbrushTool._update = false;\r\nconst updateLightTask = (tasks) => {\r\n    let doRGB = ES.doRGBPropagation();\r\n    let doSun = ES.doSunPropagation();\r\n    const [dimension, x, y, z] = tasks.origin;\r\n    nDataTool.setDimension(dimension);\r\n    for (const n of $3dCardinalNeighbors) {\r\n        const nx = n[0] + x;\r\n        const ny = n[1] + y;\r\n        const nz = n[2] + z;\r\n        if (!nDataTool.loadInAt(nx, ny, nz))\r\n            continue;\r\n        if (doRGB) {\r\n            if (nDataTool.hasRGBLight()) {\r\n                tasks.queues.rgb.update.push(nx, ny, nz);\r\n            }\r\n        }\r\n        if (doSun) {\r\n            if (nDataTool.hasSunLight()) {\r\n                tasks.queues.sun.update.push(nx, ny, nz);\r\n            }\r\n        }\r\n    }\r\n};\r\nexport async function EreaseAndUpdate(data) {\r\n    if (!dataTool.setLocation(data[0]).loadIn())\r\n        return false;\r\n    const [dimension, x, y, z] = data[0];\r\n    const tasks = TasksRequest.getVoxelUpdateRequests(data[0], data[1], data[2]);\r\n    tasks\r\n        .setPriority(0)\r\n        .start()\r\n        .setBuldMode(\"sync\")\r\n        .addNeighborsToRebuildQueue(x, y, z);\r\n    tasks.setBuldMode(\"async\");\r\n    if (ES.doFlow()) {\r\n        const substance = dataTool.getSubstance();\r\n        if (substance == \"#dve_liquid\" || substance == \"#dve_magma\") {\r\n            await Propagation.flow.remove(tasks);\r\n            tasks.stop();\r\n            return true;\r\n        }\r\n    }\r\n    const light = dataTool.getLight();\r\n    const isLightSource = dataTool.isLightSource();\r\n    dataTool\r\n        .setLight(light > 0 ? light : 0)\r\n        .setAir()\r\n        .commit(2);\r\n    if (ES.doLight()) {\r\n        if (ES.doRGBPropagation() && isLightSource) {\r\n            tasks.queues.rgb.rmeove.push(x, y, z);\r\n            Propagation.rgb.remove(tasks);\r\n        }\r\n        updateLightTask(tasks);\r\n        if (ES.doRGBPropagation()) {\r\n            Propagation.rgb.update(tasks);\r\n        }\r\n        if (ES.doSunPropagation()) {\r\n            Propagation.sun.update(tasks);\r\n        }\r\n    }\r\n    LocationDataDistanceSort(tasks.origin, tasks.syncQueue);\r\n    tasks.runRebuildQueue();\r\n    tasks.stop();\r\n    return true;\r\n}\r\nexport async function PaintAndUpdate(data) {\r\n    if (!dataTool.setLocation(data[0]).loadIn())\r\n        return false;\r\n    const [dimension, x, y, z] = data[0];\r\n    const raw = data[1];\r\n    const tasks = TasksRequest.getVoxelUpdateRequests(data[0], data[2], data[3]);\r\n    tasks\r\n        .start()\r\n        .setPriority(0)\r\n        .setBuldMode(\"sync\")\r\n        .addNeighborsToRebuildQueue(x, y, z);\r\n    tasks.setBuldMode(\"async\");\r\n    brushTool.setLocation(data[0]).setRaw(raw);\r\n    nDataTool.loadInRaw(raw);\r\n    const isOpaque = nDataTool.isOpaque();\r\n    let doRGB = ES.doRGBPropagation();\r\n    let doSun = ES.doSunPropagation();\r\n    lighttest: if (ES.doLight()) {\r\n        const light = dataTool.getLight();\r\n        if (light <= 0)\r\n            break lighttest;\r\n        if (doSun) {\r\n            if (dataTool.hasSunLight()) {\r\n                tasks.queues.sun.rmeove.push(x, y, z);\r\n                Propagation.sun.remove(tasks);\r\n            }\r\n        }\r\n        if (doRGB) {\r\n            if (dataTool.hasRGBLight() && isOpaque) {\r\n                tasks.queues.rgb.rmeove.push(x, y, z);\r\n                Propagation.rgb.remove(tasks);\r\n            }\r\n        }\r\n    }\r\n    brushTool.paint();\r\n    if (ES.doLight()) {\r\n        updateLightTask(tasks);\r\n        if (doRGB) {\r\n            tasks.queues.rgb.update.push(x, y, z);\r\n            Propagation.rgb.update(tasks);\r\n        }\r\n        if (doSun) {\r\n            Propagation.sun.update(tasks);\r\n        }\r\n    }\r\n    if (ES.doFlow()) {\r\n        const substance = brushTool._dt.getSubstance();\r\n        if (substance == \"#dve_liquid\" || substance == \"#dve_magma\") {\r\n            Propagation.flow.update(tasks);\r\n        }\r\n    }\r\n    tasks.runRebuildQueue();\r\n    tasks.stop();\r\n    return;\r\n}\r\n","import { ConstructorTasks } from \"../../Common/Threads/Contracts/ConstructorTasks.js\";\r\nimport { DVEC } from \"../DivineVoxelEngineConstructor.js\";\r\nimport { ThreadComm } from \"threadcomm\";\r\nimport { EreaseAndUpdate, PaintAndUpdate } from \"./Functions/VoxelUpdate.js\";\r\nimport { WorldRegister } from \"../../Data/World/WorldRegister.js\";\r\nimport { ChunkDataTool } from \"../../Tools/Data/WorldData/ChunkDataTool.js\";\r\nimport { TasksRequest } from \"./TasksRequest.js\";\r\nconst chunkTool = new ChunkDataTool();\r\nexport const Tasks = {\r\n    data: {\r\n        syncTextures: ThreadComm.registerTasks(\"sync-uv-texuture-data\", (data) => {\r\n            DVEC.builder.textureManager.setUVTextureMap(data);\r\n            DVEC.hooks.texturesRegistered.run(DVEC.builder.textureManager);\r\n        }),\r\n    },\r\n    build: {\r\n        chunk: {\r\n            tasks: ThreadComm.registerTasks(ConstructorTasks.buildChunk, async (buildData) => {\r\n                if (buildData.priority == 0) {\r\n                    Tasks.build.chunk.run(buildData.data);\r\n                    return;\r\n                }\r\n                DVEC.tasksQueue.addTasks(buildData.priority, buildData.data, Tasks.build.chunk.run);\r\n            }),\r\n            async run(data) {\r\n                const location = data[0];\r\n                await DVEC.builder.buildChunk(location, data[1]);\r\n            },\r\n        },\r\n        column: ThreadComm.registerTasks(ConstructorTasks.buildColumn, async (data, onDone) => {\r\n            const column = WorldRegister.column.get(data[0]);\r\n            if (!column)\r\n                return false;\r\n            if (column.chunks.size == 0)\r\n                return false;\r\n            let totalChunks = 0;\r\n            const location = data[0];\r\n            for (const [key, chunk] of column.chunks) {\r\n                chunkTool.setChunk(chunk);\r\n                const chunkPOS = chunkTool.getPositionData();\r\n                location[1] = chunkPOS.x;\r\n                location[2] = chunkPOS.y;\r\n                location[3] = chunkPOS.z;\r\n                totalChunks++;\r\n                DVEC.tasksQueue.addTasks(2, [[...location], data[1]], async (data) => {\r\n                    await Tasks.build.chunk.run(data);\r\n                    totalChunks--;\r\n                    if (totalChunks == 0) {\r\n                        if (onDone)\r\n                            onDone(true);\r\n                    }\r\n                });\r\n            }\r\n        }, \"deffered\"),\r\n    },\r\n    voxelUpdate: {\r\n        erase: ThreadComm.registerTasks(ConstructorTasks.voxelErease, async (data, onDone) => {\r\n            await EreaseAndUpdate(data);\r\n            if (onDone)\r\n                onDone();\r\n        }, \"deffered\"),\r\n        paint: ThreadComm.registerTasks(ConstructorTasks.voxelPaint, async (data, onDone) => {\r\n            await PaintAndUpdate(data);\r\n            if (onDone)\r\n                onDone();\r\n        }, \"deffered\"),\r\n    },\r\n    explosion: ThreadComm.registerTasks(ConstructorTasks.explosion, async (data) => {\r\n        await DVEC.propagation.expolosion.run(TasksRequest.getExplosionRequests(data[0], data[1], data[2], data[3]));\r\n    }),\r\n    worldSun: ThreadComm.registerTasks(ConstructorTasks.worldSun, (data, onDone) => {\r\n        DVEC.tasksQueue.addTasks(2, data, () => {\r\n            DVEC.propagation.worldSun.run(TasksRequest.getWorldSunRequests(data[0], data[1]));\r\n            if (onDone)\r\n                onDone();\r\n        });\r\n    }, \"deffered\"),\r\n    worldGen: {\r\n        generate: ThreadComm.registerTasks(ConstructorTasks.generate, (data, onDone) => {\r\n            if (!onDone)\r\n                return;\r\n            DVEC.tasksQueue.addTasks(2, data, () => {\r\n                DVEC.worldGen.generate(data, onDone);\r\n            });\r\n        }, \"deffered\"),\r\n    },\r\n    anaylzer: {\r\n        propagation: ThreadComm.registerTasks(ConstructorTasks.analyzerPropagation, async (data, onDone) => {\r\n            await DVEC.analyzer.runPropagation(data);\r\n            if (onDone)\r\n                onDone();\r\n        }, \"deffered\"),\r\n        update: ThreadComm.registerTasks(ConstructorTasks.analyzerUpdate, async (data, onDone) => {\r\n            await DVEC.analyzer.runUpdate(data);\r\n            if (onDone)\r\n                onDone();\r\n        }, \"deffered\"),\r\n    },\r\n    flow: {\r\n        update: ThreadComm.registerTasks(ConstructorTasks.flowUpdate, async (data) => {\r\n            const tasks = TasksRequest.getFlowUpdateRequest(data[0], data[1], data[2]);\r\n            tasks.start();\r\n            await DVEC.propagation.flow.update(tasks);\r\n            tasks.stop();\r\n        }),\r\n        remove: ThreadComm.registerTasks(ConstructorTasks.flowRemove, async (data) => {\r\n            const tasks = TasksRequest.getFlowUpdateRequest(data[0], data[1], data[2]);\r\n            tasks.start();\r\n            await DVEC.propagation.flow.remove(tasks);\r\n            tasks.stop();\r\n        }),\r\n    },\r\n    rgb: {\r\n        update: ThreadComm.registerTasks(ConstructorTasks.RGBlightUpdate, (data) => {\r\n            const tasks = TasksRequest.getLightUpdateRequest(data[0], data[1], data[2]);\r\n            const [dimension, x, y, z] = data[0];\r\n            tasks.queues.rgb.update.push(x, y, z);\r\n            tasks.start();\r\n            DVEC.propagation.rgb.update(tasks);\r\n            tasks.stop();\r\n        }),\r\n        remove: ThreadComm.registerTasks(ConstructorTasks.RGBlightRemove, (data) => {\r\n            const tasks = TasksRequest.getLightUpdateRequest(data[0], data[1], data[2]);\r\n            const [dimension, x, y, z] = data[0];\r\n            tasks.queues.rgb.rmeove.push(x, y, z);\r\n            tasks.start();\r\n            DVEC.propagation.rgb.remove(tasks);\r\n            tasks.stop();\r\n        }),\r\n    },\r\n    sun: {\r\n        update: ThreadComm.registerTasks(ConstructorTasks.sunLightUpdate, (data) => {\r\n            const tasks = TasksRequest.getLightUpdateRequest(data[0], data[1], data[2]);\r\n            const [dimension, x, y, z] = data[0];\r\n            tasks.queues.sun.update.push(x, y, z);\r\n            tasks.start();\r\n            DVEC.propagation.sun.update(tasks);\r\n            tasks.stop();\r\n        }),\r\n        remove: ThreadComm.registerTasks(ConstructorTasks.sunLightRemove, (data) => {\r\n            const tasks = TasksRequest.getLightUpdateRequest(data[0], data[1], data[2]);\r\n            const [dimension, x, y, z] = data[0];\r\n            tasks.queues.sun.rmeove.push(x, y, z);\r\n            tasks.start();\r\n            DVEC.propagation.sun.remove(tasks);\r\n            tasks.stop();\r\n        }),\r\n    },\r\n};\r\n","export const TasksQueue = {\r\n    tasks: new Map(),\r\n    addTasks(priority, data, run) {\r\n        const tasks = this.tasks.get(priority);\r\n        if (!tasks)\r\n            return;\r\n        tasks.push([data, run]);\r\n    },\r\n    $INIT() {\r\n        this.tasks.set(0, []);\r\n        this.tasks.set(1, []);\r\n        this.tasks.set(2, []);\r\n        this.tasks.set(3, []);\r\n        setInterval(() => {\r\n            for (const [priority, tasks] of this.tasks) {\r\n                if (tasks.length) {\r\n                    const node = tasks.shift();\r\n                    if (!node)\r\n                        return;\r\n                    node[1](node[0]);\r\n                    break;\r\n                }\r\n            }\r\n        }, 50);\r\n    },\r\n};\r\n","import { ConstructorRemoteThreadTasks } from \"../../Common/Threads/Contracts/ConstructorRemoteThreadTasks.js\";\r\nimport { EngineSettings } from \"../../Data/Settings/EngineSettings.js\";\r\nimport { ThreadComm } from \"threadcomm\";\r\nimport { $3dMooreNeighborhood } from \"../../Data/Constants/Util/CardinalNeighbors.js\";\r\nimport { WorldSpaces } from \"../../Data/World/WorldSpaces.js\";\r\nimport { WorldRegister } from \"../../Data/World/WorldRegister.js\";\r\nimport { Builder } from \"../../Constructor/Builder/Builder.js\";\r\nimport { ChunkDataTool } from \"../../Tools/Data/WorldData/ChunkDataTool.js\";\r\nimport { VisitedMap } from \"../../Global/Util/VisistedMap.js\";\r\nconst chunkTool = new ChunkDataTool();\r\nclass Request {\r\n    tasksType;\r\n    origin;\r\n    data;\r\n    buildQueue;\r\n    originThread;\r\n    queues;\r\n    rebuildQueMap = new Map();\r\n    comm;\r\n    priority = 2;\r\n    LOD = 0;\r\n    syncQueue = [];\r\n    aSyncQueue = [];\r\n    buildMode = \"sync\";\r\n    buildTasks = {\r\n        data: [[\"main\", 0, 0, 0], 1],\r\n        priority: 0,\r\n    };\r\n    rebuildTasks;\r\n    constructor(tasksType, origin, data, buildQueue = \"none\", originThread = \"self\", queues) {\r\n        this.tasksType = tasksType;\r\n        this.origin = origin;\r\n        this.data = data;\r\n        this.buildQueue = buildQueue;\r\n        this.originThread = originThread;\r\n        this.queues = queues;\r\n        if (originThread != \"self\") {\r\n            this.comm = ThreadComm.getComm(originThread);\r\n        }\r\n        this.rebuildTasks = [this.origin, this.buildQueue, this.priority];\r\n        return this;\r\n    }\r\n    start() {\r\n        WorldRegister.cache.enable();\r\n        return this;\r\n    }\r\n    stop() {\r\n        WorldRegister.cache.disable();\r\n        return this;\r\n    }\r\n    setPriority(priority) {\r\n        this.priority = priority;\r\n        return this;\r\n    }\r\n    getData() {\r\n        return this.data;\r\n    }\r\n    getOriginThread() {\r\n        return this.origin;\r\n    }\r\n    getBuildQueue() {\r\n        return this.buildQueue;\r\n    }\r\n    getOrigin() {\r\n        return this.origin;\r\n    }\r\n    needsRebuild() {\r\n        return this.buildQueue != \"none\";\r\n    }\r\n    needsToUpdateOriginThread() {\r\n        return this.originThread != \"self\";\r\n    }\r\n    setBuldMode(mode) {\r\n        this.buildMode = mode;\r\n        return this;\r\n    }\r\n    addToRebuildQueue(x, y, z) {\r\n        if (EngineSettings.isServer())\r\n            return false;\r\n        if (!this.needsRebuild())\r\n            return false;\r\n        if (!chunkTool.setDimension(this.origin[0]).loadInAt(x, y, z))\r\n            return false;\r\n        const chunkKey = WorldSpaces.chunk.getKeyLocation(chunkTool.location);\r\n        if (this.rebuildQueMap.has(chunkKey))\r\n            return false;\r\n        this.rebuildQueMap.set(chunkKey, true);\r\n        if (this.buildMode == \"async\") {\r\n            this.aSyncQueue.push([...chunkTool.location]);\r\n            return true;\r\n        }\r\n        this.syncQueue.push([...chunkTool.location]);\r\n        return true;\r\n    }\r\n    addNeighborsToRebuildQueue(x, y, z) {\r\n        if (!this.needsRebuild())\r\n            return false;\r\n        const voxelPOS = WorldSpaces.voxel.getPositionXYZ(x, y, z);\r\n        if (voxelPOS.x == 0 ||\r\n            voxelPOS.x == WorldSpaces.chunk._bounds.x - 1 ||\r\n            voxelPOS.y == 0 ||\r\n            voxelPOS.y == WorldSpaces.chunk._bounds.y - 1 ||\r\n            voxelPOS.z == 0 ||\r\n            voxelPOS.z == WorldSpaces.chunk._bounds.z - 1) {\r\n            let i = $3dMooreNeighborhood.length;\r\n            while (i--) {\r\n                this.addToRebuildQueue(x + $3dMooreNeighborhood[i][0], y + $3dMooreNeighborhood[i][1], z + $3dMooreNeighborhood[i][2]);\r\n            }\r\n            return;\r\n        }\r\n        this.addToRebuildQueue(x, y, z);\r\n        return this;\r\n    }\r\n    runRebuildQueue() {\r\n        while (this.aSyncQueue.length !== 0) {\r\n            const node = this.aSyncQueue.shift();\r\n            this.buildTasks.priority = this.priority;\r\n            if (!node)\r\n                break;\r\n            this.buildTasks.data[0] = node;\r\n            this.comm.runTasks(ConstructorRemoteThreadTasks.buildChunk, this.buildTasks);\r\n        }\r\n        while (this.syncQueue.length !== 0) {\r\n            const node = this.syncQueue.shift();\r\n            if (!node)\r\n                break;\r\n            Builder.buildChunk(node);\r\n        }\r\n        this.rebuildQueMap.clear();\r\n        return this;\r\n    }\r\n}\r\nconst getLightQueues = () => {\r\n    return {\r\n        rgb: {\r\n            update: [],\r\n            rmeove: [],\r\n            map: new VisitedMap(),\r\n        },\r\n        sun: {\r\n            update: [],\r\n            rmeove: [],\r\n        },\r\n    };\r\n};\r\nconst getFlowQueues = () => {\r\n    return {\r\n        update: {\r\n            queue: [],\r\n            map: new VisitedMap(),\r\n        },\r\n        rmeove: {\r\n            queue: [],\r\n            map: new VisitedMap(),\r\n            noRemoveMap: new VisitedMap(),\r\n        },\r\n    };\r\n};\r\nconst getVoxelUpdateQueueData = () => {\r\n    return { ...getLightQueues(), flow: getFlowQueues() };\r\n};\r\nconst getExplosionQueuesData = () => {\r\n    return {\r\n        queue: [],\r\n        map: new VisitedMap(),\r\n        ...getLightQueues(),\r\n        flow: getFlowQueues(),\r\n    };\r\n};\r\nexport const TasksRequest = {\r\n    getLightUpdateRequest(origin, buildQueue = \"none\", originThread = \"self\") {\r\n        return new Request(\"light-update\", origin, null, buildQueue, originThread, getLightQueues());\r\n    },\r\n    getFlowUpdateRequest(origin, buildQueue = \"none\", originThread = \"self\") {\r\n        return new Request(\"flow-update\", origin, null, buildQueue, originThread, getVoxelUpdateQueueData());\r\n    },\r\n    getVoxelUpdateRequests(origin, buildQueue = \"none\", originThread = \"self\") {\r\n        return new Request(\"voxel-update\", origin, null, buildQueue, originThread, getVoxelUpdateQueueData());\r\n    },\r\n    getWorldSunRequests(origin, buildQueue = \"none\", originThread = \"self\") {\r\n        return new Request(\"world-sun\", origin, null, buildQueue, originThread, {\r\n            sun: [],\r\n        });\r\n    },\r\n    getExplosionRequests(origin, radius, buildQueue = \"none\", originThread = \"self\") {\r\n        return new Request(\"voxel-update\", origin, radius, buildQueue, originThread, getExplosionQueuesData());\r\n    },\r\n};\r\n","import { ThreadComm } from \"threadcomm\";\r\nimport { DVEC } from \"../../DivineVoxelEngineConstructor.js\";\r\nconst parentComm = ThreadComm.parent;\r\nparentComm.listenForMessage(\"connect-world\", (data, event) => {\r\n    if (!event)\r\n        return;\r\n    const port = event.ports[0];\r\n    DVEC.worldComm.setPort(port);\r\n});\r\nparentComm.listenForMessage(\"sync-settings\", (data, event) => {\r\n    const settings = data[1];\r\n    DVEC.syncSettings(settings);\r\n});\r\nparentComm.listenForMessage(\"re-start\", (data, event) => {\r\n    DVEC.reStart();\r\n});\r\nparentComm.listenForMessage(\"sync-uv-texuture-data\", (data, event) => {\r\n});\r\nexport const ParentComm = parentComm;\r\n","import { ThreadComm } from \"threadcomm\";\r\nconst worldComm = ThreadComm.createComm(\"world\", {});\r\nexport const WorldComm = worldComm;\r\n","import { WorldGenRegister } from \"../../WorldGeneration/Register/WorldGenRegister.js\";\r\nimport { Util } from \"../../../Global/Util.helper.js\";\r\nimport { BrushTool } from \"../../../Tools/Brush/Brush.js\";\r\nimport { WorldPainter } from \"../../../Data/World/WorldPainter.js\";\r\nexport function GetConstructorBrush() {\r\n    const newBrush = Util.merge(new BrushTool(), {\r\n        requestsId: \"\",\r\n        paint() {\r\n            if (!this._dt.loadInAtLocation(this.location)) {\r\n                WorldGenRegister.addToRequest(newBrush.requestsId, this.location, [\r\n                    ...this.getRaw(),\r\n                ]);\r\n                return this;\r\n            }\r\n            WorldPainter.paint.voxel(this.location, this.data);\r\n            return this;\r\n        },\r\n    });\r\n    return newBrush;\r\n}\r\n","import { DataTool } from \"../../../Tools/Data/DataTool.js\";\r\nimport { ShapeManager } from \"../../Builder/Shapes/ShapeManager.js\";\r\nimport { VoxelConstructors } from \"../../Builder/Constructors/Voxel/VoxelConstructors.js\";\r\nimport { Util } from \"../../../Global/Util.helper.js\";\r\nexport function GetConstructorDataTool() {\r\n    const dataTool = new DataTool();\r\n    const mergeObj = {\r\n        getVoxelShapeObj() {\r\n            return ShapeManager.getShape(dataTool.getShapeId());\r\n        },\r\n        getVoxelObj() {\r\n            return VoxelConstructors.getVoxel(dataTool.getStringId());\r\n        },\r\n    };\r\n    return Util.merge(dataTool, mergeObj);\r\n}\r\n","import { BrushTool } from \"../../../Tools/Brush/Brush.js\";\r\nimport { ThreadComm } from \"threadcomm\";\r\nimport { WorldSpaces } from \"../../../Data/World/WorldSpaces.js\";\r\nimport { ChunkDataTool } from \"../../../Tools/Data/WorldData/ChunkDataTool.js\";\r\nconst brush = new BrushTool();\r\nconst dataTool = brush._dt;\r\nconst chunkTool = new ChunkDataTool();\r\nexport const WorldGenRegister = {\r\n    MAX_ATTEMPTS: 100,\r\n    _requests: new Map(),\r\n    registerRequest(dimension, x, y, z) {\r\n        const id = `${dimension}-${x}-${y}-${z}`;\r\n        this._requests.set(id, {\r\n            attempts: 0,\r\n            chunks: new Map(),\r\n            dimension: dimension,\r\n            voxels: [],\r\n        });\r\n        return id;\r\n    },\r\n    addToRequest(registerId, location, rawData) {\r\n        const requests = this._requests.get(registerId);\r\n        if (!requests)\r\n            return;\r\n        const chunkPOS = WorldSpaces.chunk.getPositionLocation(location);\r\n        const chunkKey = WorldSpaces.chunk.getKeyLocation(location);\r\n        if (!chunkTool.loadInAtLocation(location)) {\r\n            if (!requests.chunks.has(chunkKey)) {\r\n                const world = ThreadComm.getComm(\"world\");\r\n                world.runTasks(\"add-chunk\", [\r\n                    requests.dimension,\r\n                    chunkPOS.x,\r\n                    chunkPOS.y,\r\n                    chunkPOS.z,\r\n                ]);\r\n                requests.chunks.set(chunkKey, [chunkPOS.x, chunkPOS.y, chunkPOS.z]);\r\n            }\r\n        }\r\n        const [dim, x, y, z] = location;\r\n        requests.voxels.push([x, y, z, rawData]);\r\n    },\r\n    attemptRequestFullFill(registerId) {\r\n        const requests = this._requests.get(registerId);\r\n        if (!requests)\r\n            return true;\r\n        chunkTool.setDimension(requests.dimension);\r\n        const world = ThreadComm.getComm(\"world\");\r\n        let done = true;\r\n        for (const [key, pos] of requests.chunks) {\r\n            if (!chunkTool.loadInAt(pos[0], pos[1], pos[2])) {\r\n                done = false;\r\n                world.runTasks(\"add-chunk\", [requests.dimension, pos[0], pos[1], pos[2]]);\r\n            }\r\n        }\r\n        if (!done) {\r\n            requests.attempts++;\r\n            if (requests.attempts >= this.MAX_ATTEMPTS) {\r\n                console.error(`World gen requests cancled after max attempts`, requests);\r\n                this._requests.delete(registerId);\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        brush.setDimension(requests.dimension);\r\n        const voxels = requests.voxels;\r\n        brush.start();\r\n        while (voxels.length) {\r\n            const data = voxels.shift();\r\n            if (!data)\r\n                break;\r\n            brush.setXYZ(data[0], data[1], data[2]).setRaw(data[3]).paint();\r\n        }\r\n        brush.stop();\r\n        this._requests.delete(registerId);\r\n        return true;\r\n    },\r\n};\r\n","//objects\r\nimport { WorldBounds } from \"../../Data/World/WorldBounds.js\";\r\nimport { GetConstructorBrush } from \"../../Constructor/Tools/Brush/ConstructorBrush.js\";\r\nimport { WorldGenRegister } from \"./Register/WorldGenRegister.js\";\r\nexport const WorldGeneration = {\r\n    worldGen: null,\r\n    register: WorldGenRegister,\r\n    worldBounds: WorldBounds,\r\n    _brushes: [],\r\n    setWorldGen(worldGen) {\r\n        this.worldGen = worldGen;\r\n    },\r\n    generate(data, onDone) {\r\n        if (!this.worldGen) {\r\n            throw new Error(`A World Generator must be set.`);\r\n        }\r\n        const [dimension, x, y, z] = data[0];\r\n        const genData = data[1];\r\n        const requestsId = WorldGenRegister.registerRequest(dimension, x, y, z);\r\n        for (const brush of this._brushes) {\r\n            brush.requestsId = requestsId;\r\n        }\r\n        this.worldGen.generate(dimension, x, y, z, genData);\r\n        const inte = setInterval(() => {\r\n            if (WorldGenRegister.attemptRequestFullFill(requestsId)) {\r\n                onDone();\r\n                clearInterval(inte);\r\n            }\r\n        }, 100);\r\n    },\r\n    getBrush() {\r\n        const brush = GetConstructorBrush();\r\n        this._brushes.push(brush);\r\n        return brush;\r\n    },\r\n};\r\n","export * from \"./DivineVoxelEngineConstructor.js\";\r\nexport * from \"./Analyzer/Analyzer.js\";\r\nexport * from \"./WorldGeneration/WorldGeneration.js\";\r\nexport * from \"./Tools/Brush/ConstructorBrush.js\";\r\nexport * from \"./Tools/Data/ConstructorDataTool.js\";\r\nexport * from \"./Builder/Tools/VoxelTemplater.js\";\r\n","export const FaceMap = [\r\n    \"top\",\r\n    \"bottom\",\r\n    \"east\",\r\n    \"west\",\r\n    \"south\",\r\n    \"north\",\r\n];\r\nexport const FaceRecord = {\r\n    top: 0,\r\n    bottom: 1,\r\n    east: 2,\r\n    west: 3,\r\n    south: 4,\r\n    north: 5,\r\n};\r\n","//objects\r\nimport { ThreadComm } from \"threadcomm\";\r\nimport { WorldRegister } from \"./World/WorldRegister.js\";\r\nimport { DataSyncTypes } from \"../Common/Threads/Contracts/DataSync.js\";\r\nimport { VoxelPaletteReader } from \"./Voxel/VoxelPalette.js\";\r\nimport { DimensionsRegister } from \"./World/Dimensions/DimensionsRegister.js\";\r\nimport { ChunkTags } from \"./World/Chunk/ChunkTags.js\";\r\nimport { RegionHeaderTags, RegionTags } from \"./World/Region/RegionTags.js\";\r\nimport { ColumnTags } from \"./World/Column/ColumnTags.js\";\r\nimport { VoxelTags } from \"./Voxel/VoxelTags.js\";\r\nimport { Register } from \"./Register/Register.js\";\r\nimport { RegionHeaderRegister } from \"./World/Region/RegionHeaderRegister.js\";\r\nexport const DataSyncNode = {\r\n    _states: {\r\n        voxelData: false,\r\n    },\r\n    isReady() {\r\n        let done = true;\r\n        for (const state of Object.keys(this._states)) {\r\n            if (!this._states[state]) {\r\n                done = false;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    voxelPalette: ThreadComm.onDataSync(DataSyncTypes.voxelPalette, (data) => {\r\n        VoxelPaletteReader.setVoxelPalette(data[0], data[1]);\r\n    }),\r\n    voxelData: ThreadComm.onDataSync(DataSyncTypes.voxelTags, (data) => {\r\n        VoxelTags.$INIT(data[0]);\r\n        VoxelTags.sync(new Uint16Array(data[1]));\r\n        DataSyncNode._states.voxelData = true;\r\n    }),\r\n    dimension: ThreadComm.onDataSync(DataSyncTypes.dimesnion),\r\n    chunk: ThreadComm.onDataSync(DataSyncTypes.chunk),\r\n    column: ThreadComm.onDataSync(DataSyncTypes.column),\r\n    region: ThreadComm.onDataSync(DataSyncTypes.region),\r\n    regionHeader: ThreadComm.onDataSync(DataSyncTypes.regionHeader),\r\n    chunkTags: ThreadComm.onDataSync(DataSyncTypes.chunkTags),\r\n    columnTags: ThreadComm.onDataSync(DataSyncTypes.columnTags),\r\n    regionTags: ThreadComm.onDataSync(DataSyncTypes.regionTags),\r\n    stringMap: ThreadComm.onDataSync(DataSyncTypes.registerStringMap, (data) => {\r\n        Register.stringMaps.syncStringMap(data);\r\n    }),\r\n};\r\nDataSyncNode.dimension.addOnSync((data) => {\r\n    DimensionsRegister.registerDimension(data.id, data.options);\r\n});\r\nDataSyncNode.chunk.addOnSync((data) => {\r\n    WorldRegister.chunk.add(data[0], data[1]);\r\n});\r\nDataSyncNode.chunk.addOnUnSync((data) => {\r\n    WorldRegister.chunk.remove(data);\r\n});\r\nDataSyncNode.column.addOnSync((data) => {\r\n    WorldRegister.column.add(data[0], data[1]);\r\n});\r\nDataSyncNode.column.addOnUnSync((data) => {\r\n    WorldRegister.column.remove(data);\r\n});\r\nDataSyncNode.region.addOnSync((data) => {\r\n    WorldRegister.region.add(data[0], data[1]);\r\n});\r\nDataSyncNode.region.addOnUnSync((data) => {\r\n    WorldRegister.region.remove(data);\r\n});\r\nDataSyncNode.regionHeader.addOnSync((data) => {\r\n    RegionHeaderRegister.add(data[0], data[1]);\r\n});\r\nDataSyncNode.chunkTags.addOnSync((data) => {\r\n    ChunkTags.$INIT(data);\r\n});\r\nDataSyncNode.columnTags.addOnSync((data) => {\r\n    ColumnTags.$INIT(data);\r\n});\r\nDataSyncNode.regionTags.addOnSync((data) => {\r\n    RegionTags.$INIT(data[0]);\r\n    RegionHeaderTags.$INIT(data[1]);\r\n});\r\n","// (this.byteValue >>> index) & 1\r\nconst faceMasks = {\r\n    top: 0b11111,\r\n    bottom: 0b11111_00000,\r\n    north: 0b11111_00000_00000,\r\n    south: 0b11111_00000_00000_00000,\r\n    east: 0b11111_00000_00000_00000_00000,\r\n    west: 0b11111_00000_00000_00000_00000_00000,\r\n};\r\nexport const FaceByte = {\r\n    _rotationMap: {\r\n        0: 0,\r\n        90: 1,\r\n        180: 2,\r\n        270: 3,\r\n    },\r\n    _rotationReverseMap: {\r\n        0: 0,\r\n        1: 90,\r\n        2: 180,\r\n        3: 270,\r\n    },\r\n    _setFaceTextureState: {\r\n        top: (state, faceBit) => {\r\n            faceBit = (faceBit & (0b00 << 3)) | faceBit;\r\n            return faceBit | (state << 3);\r\n        },\r\n        bottom: (state, faceBit) => {\r\n            faceBit = (faceBit & (0b00 << 8)) | faceBit;\r\n            return faceBit | (state << 8);\r\n        },\r\n        north: (state, faceBit) => {\r\n            faceBit = (faceBit & (0b00 << 13)) | faceBit;\r\n            return faceBit | (state << 13);\r\n        },\r\n        south: (state, faceBit) => {\r\n            faceBit = (faceBit & (0b00 << 18)) | faceBit;\r\n            return faceBit | (state << 18);\r\n        },\r\n        east: (state, faceBit) => {\r\n            faceBit = (faceBit & (0b00 << 23)) | faceBit;\r\n            return faceBit | (state << 23);\r\n        },\r\n        west: (state, faceBit) => {\r\n            faceBit = (faceBit & (0b00 << 28)) | faceBit;\r\n            return faceBit | (state << 28);\r\n        },\r\n    },\r\n    _getFaceTextureState: {\r\n        top: (faceBit) => {\r\n            let newBit = faceMasks.top & faceBit;\r\n            return (newBit >>> 3) & 0b11;\r\n        },\r\n        bottom: (faceBit) => {\r\n            let newBit = faceMasks.bottom & faceBit;\r\n            return (newBit >>> 8) & 0b11;\r\n        },\r\n        north: (faceBit) => {\r\n            let newBit = faceMasks.north & faceBit;\r\n            return (newBit >>> 13) & 0b11;\r\n        },\r\n        south: (faceBit) => {\r\n            let newBit = faceMasks.south & faceBit;\r\n            return (newBit >>> 18) & 0b11;\r\n        },\r\n        east: (faceBit) => {\r\n            let newBit = faceMasks.east & faceBit;\r\n            return (newBit >>> 23) & 0b11;\r\n        },\r\n        west: (faceBit) => {\r\n            let newBit = faceMasks.west & faceBit;\r\n            return (newBit >>> 28) & 0b11;\r\n        },\r\n    },\r\n    _setFaceRotateState: {\r\n        top: (state, faceBit) => {\r\n            faceBit = (faceBit & (0b00 << 1)) | faceBit;\r\n            return faceBit | (state << 1);\r\n        },\r\n        bottom: (state, faceBit) => {\r\n            faceBit = (faceBit & (0b00 << 6)) | faceBit;\r\n            return faceBit | (state << 6);\r\n        },\r\n        north: (state, faceBit) => {\r\n            faceBit = (faceBit & (0b00 << 11)) | faceBit;\r\n            return faceBit | (state << 11);\r\n        },\r\n        south: (state, faceBit) => {\r\n            faceBit = (faceBit & (0b00 << 16)) | faceBit;\r\n            return faceBit | (state << 16);\r\n        },\r\n        east: (state, faceBit) => {\r\n            faceBit = (faceBit & (0b00 << 21)) | faceBit;\r\n            return faceBit | (state << 21);\r\n        },\r\n        west: (state, faceBit) => {\r\n            faceBit = (faceBit & (0b00 << 26)) | faceBit;\r\n            return faceBit | (state << 26);\r\n        },\r\n    },\r\n    _getFaceRotateState: {\r\n        top: (faceBit) => {\r\n            let newBit = faceMasks.top & faceBit;\r\n            return (newBit >>> 1) & 0b11;\r\n        },\r\n        bottom: (faceBit) => {\r\n            let newBit = faceMasks.bottom & faceBit;\r\n            return (newBit >>> 6) & 0b11;\r\n        },\r\n        north: (faceBit) => {\r\n            let newBit = faceMasks.north & faceBit;\r\n            return (newBit >>> 11) & 0b11;\r\n        },\r\n        south: (faceBit) => {\r\n            let newBit = faceMasks.south & faceBit;\r\n            return (newBit >>> 16) & 0b11;\r\n        },\r\n        east: (faceBit) => {\r\n            let newBit = faceMasks.east & faceBit;\r\n            return (newBit >>> 21) & 0b11;\r\n        },\r\n        west: (faceBit) => {\r\n            let newBit = faceMasks.west & faceBit;\r\n            return (newBit >>> 26) & 0b11;\r\n        },\r\n    },\r\n    _markExposedFace: {\r\n        top: (faceBit) => {\r\n            return faceBit | (1 << 0);\r\n        },\r\n        bottom: (faceBit) => {\r\n            return faceBit | (1 << 5);\r\n        },\r\n        north: (faceBit) => {\r\n            return faceBit | (1 << 10);\r\n        },\r\n        south: (faceBit) => {\r\n            return faceBit | (1 << 15);\r\n        },\r\n        east: (faceBit) => {\r\n            return faceBit | (1 << 20);\r\n        },\r\n        west: (faceBit) => {\r\n            return faceBit | (1 << 25);\r\n        },\r\n    },\r\n    _checkExposedFace: {\r\n        top: (faceBit) => {\r\n            return ((faceBit >>> 0) & 1) == 1;\r\n        },\r\n        bottom: (faceBit) => {\r\n            return ((faceBit >>> 5) & 1) == 1;\r\n        },\r\n        north: (faceBit) => {\r\n            return ((faceBit >>> 10) & 1) == 1;\r\n        },\r\n        south: (faceBit) => {\r\n            return ((faceBit >>> 15) & 1) == 1;\r\n        },\r\n        east: (faceBit) => {\r\n            return ((faceBit >>> 20) & 1) == 1;\r\n        },\r\n        west: (faceBit) => {\r\n            return ((faceBit >>> 25) & 1) == 1;\r\n        },\r\n    },\r\n    markFaceAsExposed(direction, rawData) {\r\n        return this._markExposedFace[direction](rawData);\r\n    },\r\n    isFaceExposed(direction, rawData) {\r\n        return this._checkExposedFace[direction](rawData);\r\n    },\r\n    setFaceRotateState(direction, state, rawData) {\r\n        return this._setFaceRotateState[direction](state, rawData);\r\n    },\r\n    getFaceRotateState(direction, rawData) {\r\n        return this._getFaceRotateState[direction](rawData);\r\n    },\r\n    setFaceTextureState(direction, rotation, rawData) {\r\n        const state = this._rotationMap[rotation];\r\n        return this._setFaceTextureState[direction](state, rawData);\r\n    },\r\n    getFaceTextureState(direction, rawData) {\r\n        const state = this._getFaceTextureState[direction](rawData);\r\n        return this._rotationReverseMap[state];\r\n    },\r\n};\r\n","export const MeshFaceDataByte = {\r\n    setAnimationType(animationType, rawData) {\r\n        return (rawData & ~(0xff << 0)) | (animationType << 0);\r\n    },\r\n    getAnimationType(rawData) {\r\n        return (rawData & (0xff));\r\n    },\r\n};\r\n","export const StairStates = {\r\n    normal: {\r\n        bottom: {\r\n            north: 0,\r\n            south: 1,\r\n            east: 2,\r\n            west: 3,\r\n        },\r\n        top: {\r\n            north: 4,\r\n            south: 5,\r\n            east: 6,\r\n            west: 7,\r\n        },\r\n    },\r\n    connected: {\r\n        bottom: {\r\n            northEast: 8,\r\n            northWest: 9,\r\n            southEast: 10,\r\n            southWest: 11,\r\n        },\r\n        top: {\r\n            northEast: 12,\r\n            northWest: 13,\r\n            southEast: 14,\r\n            southWest: 15,\r\n        },\r\n    },\r\n};\r\n","export class VisitedMap {\r\n    _map = new Map();\r\n    get size() {\r\n        return this._map.size;\r\n    }\r\n    _getKey(x, y, z) {\r\n        return `${x}_${y}_${z}`;\r\n    }\r\n    inMap(x, y, z) {\r\n        return this._map.has(this._getKey(x, y, z));\r\n    }\r\n    add(x, y, z) {\r\n        this._map.set(this._getKey(x, y, z), true);\r\n    }\r\n    remove(x, y, z) {\r\n        this._map.delete(this._getKey(x, y, z));\r\n    }\r\n    removeDiffernce(map) {\r\n        for (const [key] of map._map) {\r\n            if (this._map.has(key)) {\r\n                this._map.delete(key);\r\n            }\r\n        }\r\n        return map;\r\n    }\r\n    clear() {\r\n        this._map.clear();\r\n    }\r\n}\r\n","import { DataTool } from \"../../Tools/Data/DataTool.js\";\r\nimport { WorldPainter } from \"../../Data/World/WorldPainter.js\";\r\nimport { WorldRegister } from \"../../Data/World/WorldRegister.js\";\r\nimport { VoxelPaletteReader } from \"../../Data/Voxel/VoxelPalette.js\";\r\nimport { LocationBoundTool } from \"../Classes/LocationBoundTool.js\";\r\nexport class BrushTool extends LocationBoundTool {\r\n    data = {\r\n        id: \"dve_air\",\r\n        state: 0,\r\n        shapeState: 0,\r\n        secondaryState: 0,\r\n        secondaryVoxelId: \"dve_air\",\r\n        level: 0,\r\n        levelState: 0,\r\n    };\r\n    _update = true;\r\n    _dt = new DataTool();\r\n    setId(id, state = 0, shapeState = 0) {\r\n        this.data.id = id;\r\n        this.data.state = state;\r\n        this.data.shapeState = shapeState;\r\n        return this;\r\n    }\r\n    setDimension(dimensionId) {\r\n        this.location[0] = dimensionId;\r\n        this._dt.setDimension(dimensionId);\r\n        return this;\r\n    }\r\n    setSecondaryId(id, state = 0) {\r\n        this.data.secondaryVoxelId = id;\r\n        this.data.secondaryState = state;\r\n        return this;\r\n    }\r\n    setState(state) {\r\n        this.data.state = state;\r\n        return this;\r\n    }\r\n    setShapeState(state) {\r\n        this.data.shapeState = state;\r\n        return this;\r\n    }\r\n    clear() {\r\n        this.data.id = \"dve_air\";\r\n        this.data.secondaryVoxelId = \"dve_air\";\r\n        this.data.level = 0;\r\n        this.data.levelState = 0;\r\n        this.data.state = 0;\r\n        this.data.secondaryState = 0;\r\n        this.location[1] = 0;\r\n        this.location[2] = 0;\r\n        this.location[3] = 0;\r\n    }\r\n    setRaw(data) {\r\n        this._dt.loadInRaw(data);\r\n        this.data.id = this._dt.getStringId();\r\n        this.data.shapeState = this._dt.getShapeState();\r\n        this.data.state = this._dt.getState();\r\n        this._dt.setSecondary(true);\r\n        if (this._dt.data.secondaryId >= 2) {\r\n            this.data.secondaryVoxelId = this._dt.getStringId();\r\n            this.data.secondaryState = this._dt.getState();\r\n        }\r\n        this._dt.setSecondary(false);\r\n        return this;\r\n    }\r\n    getRaw() {\r\n        this._dt.setId(VoxelPaletteReader.id.getPaletteId(this.data.id, this.data.state));\r\n        this._dt\r\n            .setSecondary(true)\r\n            .setId(VoxelPaletteReader.id.getPaletteId(this.data.secondaryVoxelId, this.data.secondaryState))\r\n            .setSecondary(false);\r\n        this._dt.setLevel(this.data.state);\r\n        this._dt.setLevelState(this.data.levelState);\r\n        this._dt.setShapeState(this.data.shapeState);\r\n        return this._dt.data.raw;\r\n    }\r\n    getData() {\r\n        return this.data;\r\n    }\r\n    paint() {\r\n        WorldPainter.paint.voxel(this.location, this.data, this._update);\r\n        return this;\r\n    }\r\n    erase() {\r\n        WorldPainter.paint.erase(this.location);\r\n        return this;\r\n    }\r\n    start() {\r\n        WorldRegister.cache.enable();\r\n        return this;\r\n    }\r\n    stop() {\r\n        WorldRegister.cache.disable();\r\n        return this;\r\n    }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [\"DSLIBS_divineVoxelEngine_dist_Data_Settings_EngineSettings_js-DSLIBS_threadComm_dist_index_js\",\"DSLIBS_divineVoxelEngine_dist_Common_Threads_Contracts_DataSync_js-DSLIBS_divineVoxelEngine_d-d7fdd9\",\"DSLIBS_divineVoxelEngine_dist_Math_index_js\"], () => (__webpack_require__(\"./compiled/client/Constructor/constructor.js\")))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var webpackQueues = typeof Symbol === \"function\" ? Symbol(\"webpack queues\") : \"__webpack_queues__\";\nvar webpackExports = typeof Symbol === \"function\" ? Symbol(\"webpack exports\") : \"__webpack_exports__\";\nvar webpackError = typeof Symbol === \"function\" ? Symbol(\"webpack error\") : \"__webpack_error__\";\nvar resolveQueue = (queue) => {\n\tif(queue && !queue.d) {\n\t\tqueue.d = 1;\n\t\tqueue.forEach((fn) => (fn.r--));\n\t\tqueue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));\n\t}\n}\nvar wrapDeps = (deps) => (deps.map((dep) => {\n\tif(dep !== null && typeof dep === \"object\") {\n\t\tif(dep[webpackQueues]) return dep;\n\t\tif(dep.then) {\n\t\t\tvar queue = [];\n\t\t\tqueue.d = 0;\n\t\t\tdep.then((r) => {\n\t\t\t\tobj[webpackExports] = r;\n\t\t\t\tresolveQueue(queue);\n\t\t\t}, (e) => {\n\t\t\t\tobj[webpackError] = e;\n\t\t\t\tresolveQueue(queue);\n\t\t\t});\n\t\t\tvar obj = {};\n\t\t\tobj[webpackQueues] = (fn) => (fn(queue));\n\t\t\treturn obj;\n\t\t}\n\t}\n\tvar ret = {};\n\tret[webpackQueues] = x => {};\n\tret[webpackExports] = dep;\n\treturn ret;\n}));\n__webpack_require__.a = (module, body, hasAwait) => {\n\tvar queue;\n\thasAwait && ((queue = []).d = 1);\n\tvar depQueues = new Set();\n\tvar exports = module.exports;\n\tvar currentDeps;\n\tvar outerResolve;\n\tvar reject;\n\tvar promise = new Promise((resolve, rej) => {\n\t\treject = rej;\n\t\touterResolve = resolve;\n\t});\n\tpromise[webpackExports] = exports;\n\tpromise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise[\"catch\"](x => {}));\n\tmodule.exports = promise;\n\tbody((deps) => {\n\t\tcurrentDeps = wrapDeps(deps);\n\t\tvar fn;\n\t\tvar getResult = () => (currentDeps.map((d) => {\n\t\t\tif(d[webpackError]) throw d[webpackError];\n\t\t\treturn d[webpackExports];\n\t\t}))\n\t\tvar promise = new Promise((resolve) => {\n\t\t\tfn = () => (resolve(getResult));\n\t\t\tfn.r = 0;\n\t\t\tvar fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));\n\t\t\tcurrentDeps.map((dep) => (dep[webpackQueues](fnQueue)));\n\t\t});\n\t\treturn fn.r ? promise : getResult();\n\t}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));\n\tqueue && (queue.d = 0);\n};","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".DVE.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t\"compiled_client_Constructor_constructor_js\": 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkdve_testing\"] = self[\"webpackChunkdve_testing\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn Promise.all([\"DSLIBS_divineVoxelEngine_dist_Data_Settings_EngineSettings_js-DSLIBS_threadComm_dist_index_js\",\"DSLIBS_divineVoxelEngine_dist_Common_Threads_Contracts_DataSync_js-DSLIBS_divineVoxelEngine_d-d7fdd9\",\"DSLIBS_divineVoxelEngine_dist_Math_index_js\"].map(__webpack_require__.e, __webpack_require__)).then(next);\n};","","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n",""],"names":[],"sourceRoot":""}